[{"categories":["KeyAttestation"],"content":" 一、Key Attestation密钥认证根据官方文档的阐述 Keymaster在Android7.0 (Keymaster 2) 中引入了密钥认证 在 Android8.0 (Keymaster 3) 中引入了ID认证 ","date":"2023-12-09","objectID":"/keyattestationke%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95/:0:1","series":null,"tags":["设备异常性检测"],"title":"KeyAttestation原理理解","uri":"/keyattestationke%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95/#一key-attestation密钥认证"},{"categories":["KeyAttestation"],"content":" 二、检测方式有关于KeyAttestation的检测方式目前已有了完成的开源方式—KeyAttestation 从源码上看看具体的检测思路，首先从入口上看 # AndroidManifest.xml \u003capplication android:name=\".AppApplication\" android:icon=\"@drawable/ic_launcher\" android:label=\"@string/app_name\" android:roundIcon=\"@drawable/ic_launcher\" android:supportsRtl=\"true\" android:theme=\"@style/AppTheme\" tools:ignore=\"AllowBackup\"\u003e \u003cactivity android:name=\".home.HomeActivity\" android:exported=\"true\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.intent.action.MAIN\" /\u003e \u003ccategory android:name=\"android.intent.category.LAUNCHER\" /\u003e \u003c/intent-filter\u003e \u003c/activity\u003e \u003cprovider android:name=\"androidx.startup.InitializationProvider\" android:authorities=\"${applicationId}.androidx-startup\" android:exported=\"false\" tools:ignore=\"MissingClass\" tools:node=\"remove\" /\u003e \u003creceiver android:name=\"androidx.profileinstaller.ProfileInstallReceiver\" android:exported=\"false\" tools:ignore=\"MissingClass\" tools:node=\"remove\" /\u003e \u003c/application\u003e AppApplication绑定了HomeActivity，对应的Fragment是HomeFragment，ViewModel是HomeViewModel，看看HomeViewModel初始化时做了什么 // io.github.vvb2060.keyattestation.home.HomeViewModel init { load() } fun load() = AppApplication.executor.execute { currentCerts = null attestationResult.postValue(Resource.loading(null)) val useStrongBox = hasStrongBox \u0026\u0026 preferStrongBox val includeProps = hasDeviceIds \u0026\u0026 preferIncludeProps val useAttestKey = hasAttestKey \u0026\u0026 preferAttestKey val result = try { // 核心验证方式 val attestationResult = doAttestation(useStrongBox, includeProps, useAttestKey) Resource.success(attestationResult) } catch (e: Throwable) { val cause = if (e is AttestationException) e.cause else e Log.w(AppApplication.TAG, \"Do attestation error.\", cause) when (e) { is AttestationException -\u003e Resource.error(e, null) else -\u003e Resource.error(AttestationException(CODE_UNKNOWN, e), null) } } attestationResult.postValue(result) } 深入看看doAttestation函数做了什么 // io.github.vvb2060.keyattestation.home.HomeViewModel private fun doAttestation(useStrongBox: Boolean, includeProps: Boolean, useAttestKey: Boolean): AttestationResult { // useAttestKey通常是false val certs: List\u003cCertificate\u003e val alias = AppApplication.TAG val attestKeyAlias = if (useAttestKey) \"${alias}_persistent\" else null try { // 获取AndroidKeyStore实例 val keyStore = KeyStore.getInstance(\"AndroidKeyStore\") keyStore.load(null) if (useAttestKey \u0026\u0026 !keyStore.containsAlias(attestKeyAlias)) { generateKey(attestKeyAlias!!, useStrongBox, includeProps, attestKeyAlias) } // 生成key generateKey(alias, useStrongBox, includeProps, attestKeyAlias) // 获取密钥别名的列表 val chainAlias = if (useAttestKey) attestKeyAlias else alias // 获取密钥证书链 val certificates = keyStore.getCertificateChain(chainAlias) ?: throw CertificateException(\"Unable to get certificate chain\") certs = ArrayList() // 获取证书工厂类实例 val cf = CertificateFactory.getInstance(\"X.509\") if (useAttestKey) { val certificate = keyStore.getCertificate(alias) ?: throw CertificateException(\"Unable to get certificate\") val buf = ByteArrayInputStream(certificate.encoded) certs.add(cf.generateCertificate(buf)) } for (i in certificates.indices) { val buf = ByteArrayInputStream(certificates[i].encoded) // 生成证书类实例 certs.add(cf.generateCertificate(buf)) } } catch (e: ProviderException) { val cause = e.cause if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.P \u0026\u0026 e is StrongBoxUnavailableException) { throw AttestationException(CODE_STRONGBOX_UNAVAILABLE, e) } else if (Build.VERSION.SDK_INT \u003e= Build.VERSION_CODES.TIRAMISU \u0026\u0026 cause is KeyStoreException) { when (cause.numericErrorCode) { ERROR_ID_ATTESTATION_FAILURE -\u003e throw AttestationException(CODE_DEVICEIDS_UNAVAILABLE, e) ERROR_ATTESTATION_KEYS_UNAVAILABLE -\u003e if (cause.isTransientFailure) { throw AttestationException(CODE_OUT_OF_KEYS_TRANSIENT, e) } else { throw AttestationException(CODE_OUT_OF_KEYS, e) } else -\u003e if (cause.isTransientFailure) { throw AttestationException(CODE_UNAVAILABLE_TRANSIENT, e) } else { throw AttestationException(CODE_UNAVAILABLE, e) } } } else if (cause?.message?.contains(\"device ids\") == true) { throw Att","date":"2023-12-09","objectID":"/keyattestationke%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95/:0:2","series":null,"tags":["设备异常性检测"],"title":"KeyAttestation原理理解","uri":"/keyattestationke%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95/#二检测方式"},{"categories":["KeyAttestation"],"content":" 三、验证效果测试已解BL锁的Xiaomi Note11测试效果 未解BL锁的Samsung S21+测试效果 ","date":"2023-12-09","objectID":"/keyattestationke%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95/:0:3","series":null,"tags":["设备异常性检测"],"title":"KeyAttestation原理理解","uri":"/keyattestationke%E5%8F%AF%E7%94%A8%E6%80%A7%E6%B5%8B%E8%AF%95/#三验证效果测试"},{"categories":["系统定制"],"content":" 前言","date":"2023-09-24","objectID":"/android11aosp%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:1","series":null,"tags":["AOSP编译"],"title":"Android11AOSP编译流程","uri":"/android11aosp%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#前言"},{"categories":["系统定制"],"content":" 一、编译环境搭建 1 物料准备 设备：pixel2（walleye） 源码：aosp源码 build id：RP1A.200720.009 tag：android-11.0.0_r1 sdk version：Android11 驱动源码准备：驱动源码 2 工具准备 编译支撑系统：centos7，使用公司的云容器（16核32G、600G磁盘） 三方库准备 yum install -y gcc make libstdc++.i686 libstdc++-devel.i686 zlib-devel openssl-devel perl cpio expat-devel gettext-devel autoconf glibc.i686 glibc-devel.i686 zlib-devel.i686 libstdc++.i686 libX11-devel.i686 ncurses-devel.i686 ncurses-libs.i686 gperf flex gcc-c++ bison patch Java/Python环境准备 ","date":"2023-09-24","objectID":"/android11aosp%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:2","series":null,"tags":["AOSP编译"],"title":"Android11AOSP编译流程","uri":"/android11aosp%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#一编译环境搭建"},{"categories":["系统定制"],"content":" 一、编译环境搭建 1 物料准备 设备：pixel2（walleye） 源码：aosp源码 build id：RP1A.200720.009 tag：android-11.0.0_r1 sdk version：Android11 驱动源码准备：驱动源码 2 工具准备 编译支撑系统：centos7，使用公司的云容器（16核32G、600G磁盘） 三方库准备 yum install -y gcc make libstdc++.i686 libstdc++-devel.i686 zlib-devel openssl-devel perl cpio expat-devel gettext-devel autoconf glibc.i686 glibc-devel.i686 zlib-devel.i686 libstdc++.i686 libX11-devel.i686 ncurses-devel.i686 ncurses-libs.i686 gperf flex gcc-c++ bison patch Java/Python环境准备 ","date":"2023-09-24","objectID":"/android11aosp%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:2","series":null,"tags":["AOSP编译"],"title":"Android11AOSP编译流程","uri":"/android11aosp%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#1-物料准备"},{"categories":["系统定制"],"content":" 一、编译环境搭建 1 物料准备 设备：pixel2（walleye） 源码：aosp源码 build id：RP1A.200720.009 tag：android-11.0.0_r1 sdk version：Android11 驱动源码准备：驱动源码 2 工具准备 编译支撑系统：centos7，使用公司的云容器（16核32G、600G磁盘） 三方库准备 yum install -y gcc make libstdc++.i686 libstdc++-devel.i686 zlib-devel openssl-devel perl cpio expat-devel gettext-devel autoconf glibc.i686 glibc-devel.i686 zlib-devel.i686 libstdc++.i686 libX11-devel.i686 ncurses-devel.i686 ncurses-libs.i686 gperf flex gcc-c++ bison patch Java/Python环境准备 ","date":"2023-09-24","objectID":"/android11aosp%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:2","series":null,"tags":["AOSP编译"],"title":"Android11AOSP编译流程","uri":"/android11aosp%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#2-工具准备"},{"categories":["系统定制"],"content":" 二、编译流程 源码下载 // repo工具下载 curl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo \u003e repo chmod a+x repo // 指定版本AOSP源码拉取 ./repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-11.0.0_r48 。/repo sync // 驱动解压放在源码根目录下，执行驱动脚本，会自动填充到vendor目录 ./extract-google_devices-blueline.sh ./extract-qcom-blueline.sh 编译环境配置 source build/envsetup.sh // 选择对应设备 lunch 执行编译 // 根据系统性能选择线程数 make -j 4 ","date":"2023-09-24","objectID":"/android11aosp%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:3","series":null,"tags":["AOSP编译"],"title":"Android11AOSP编译流程","uri":"/android11aosp%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#二编译流程"},{"categories":["unidbg生态"],"content":"Unidbg对抗点 不支持信号机制 内存布局检测 Unidbg通过Java实现JNI的逻辑，导致JNI函数地址控制在0xfffe0000L - 0xffff0000L范围内，检测JNI函数地址是否处于该范围或者相邻两个函数的地址差值 类检测：Unidbg通常会对不存在的类也会正常返回 函数检测：对比methodid是否是hashcode 文件描述符：Unidbg的文件描述符通常是3-6 uname判断 hook框架检测（xhook、dobby） 依赖库对抗：Unidbg只实现了十余个常用so库 字节对齐？ getenv 增加目标函数前置执行条件 ","date":"2023-08-31","objectID":"/unidbg%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E6%B1%87%E6%80%BB/:0:0","series":null,"tags":["unidbg特征对抗"],"title":"Unidbg特征检测汇总","uri":"/unidbg%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E6%B1%87%E6%80%BB/#"},{"categories":["frida生态"],"content":" 端口检测：frida默认暴露端口为27047 通信方式检测：frida使用App低频使用的D-Bus通信协议来进行通信，可以遍历端口对它们发送D-Bus AUTH消息来判断是否存在REJECT的情况 内存检测 so列表检测 maps文件内容遍历检测 通过linker获取so list遍历检测 可执行段字符检测：遍历maps文件中带有可执行属性的segment，检测是否包含libfrida/frida:rpc等字符特征 线程检测：遍历proc/self/task的文件内容，查找字符特征 命名通道检测：遍历proc/self/fd，反查fd判断是否包含linjector字符特征 section crc检验：对比内存中的so 各个section与本地的section的crc值对比 segment属性检测：针对inline hook，由于frida是基于inline hook的，因此会改动libart，进而暴露在maps中会有rwxp属性的地址段 inline hook跳转检测：frida inline hook和其他inline hook的原理相同，在函数的头几个字节通常是ldr、br这类的指令 目录检测：针对/data/local/tmp下面的re.frida.server 代码漏洞 elf头字节魔改：frida gum_try_parse_linker_proc_maps_line函数中在获取linker时会判断elf头字节是否匹配，可以选择修改elf头字节 libc属性修改：使用目标libc的mmap将自身的相关so注册到目标maps表中;再执行目标libc的dlopen和dlsym函数将自身so中的函数进行执行，做法是主动mmap只读的libc从而让frida启动崩溃 检测线程保护 匿名内存检测 额外需要注意的是 自定义syscall：从上面的特征检测来看，文件是重要的检测介质，为了要获取到真实的文件，还需要使用自定义syscall，例如open/read/close等 自定义pthread_create ","date":"2023-08-21","objectID":"/frida%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E6%B1%87%E6%80%BB/:0:0","series":null,"tags":["frida特征对抗"],"title":"Frida特征检测汇总","uri":"/frida%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E6%B1%87%E6%80%BB/#"},{"categories":["frida生态"],"content":" 一、编译环境搭建这次编译的目标版本是14.2.18 1 物料准备 设备：红米note11（MIUI12 Android11） frida源码：https://github.com/frida/frida 2 工具准备参照官方编译指南 编译支撑系统：ubuntu23 Linux ubuntu23 6.2.0-27-generic #28-Ubuntu SMP PREEMPT_DYNAMIC Wed Jul 12 22:39:51 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux 之所以选择ubuntu23而不是其他版本是因为在安装三方库的时候不用再额外考虑版本问题了，亲测这点太坑了 frida源码下载 git clone -b 14.2.18 --recurse-submodules https://github.com/frida/frida 选择tag为14.2.18，不必全量clone再切换，后续的版本和当前版本差别较大，会造成无法正常编译，原因是因为直接使用checkout的话只是针对frida这个仓库，但是对于submodule来说版本依旧未变，需要执行如下命令 git submodule update --recursive toolchain/sdk 可以选择自己编译，但是为了减少不必要的麻烦，直接选择官方已经打好的编译产物，frida官方是存在toolchain/sdk的编译后的产物，可以直接下，下载链接的格式参考 https://build.frida.re/deps/{frida_toolchain_version}/toolchain-linux-x86_64.tar.bz2 frida_toolchain_version可以从releng/deps.mk中获取 frida_toolchain_version = 20210419 最终可得的下载地址是 https://build.frida.re/deps/20210419/toolchain-linux-x86_64.tar.bz2 # toolchains 工具 https://build.frida.re/deps/20210419/sdk-linux-x86_64.tar.bz2 # sdk 工具 # 下面是需要编译的对应架构的文件 https://build.frida.re/deps/20210419/sdk-android-x86.tar.bz2 https://build.frida.re/deps/20210419/sdk-android-x86_64.tar.bz2 https://build.frida.re/deps/20210419/sdk-android-arm.tar.bz2 https://build.frida.re/deps/20210419/sdk-android-arm64.tar.bz2 将上面的四个文件分别下载好后放在frida/build目录下（没有可新建），执行命令 bash releng/setup-env.sh 输出结果如下 Assuming host is linux-x86_64 Set FRIDA_HOST to override. Deploying local toolchain toolchain-linux-x86_64.tar.bz2... Deploying local SDK sdk-linux-x86_64.tar.bz2... 三方库安装 sudo apt-get install build-essential curl git lib32stdc++-9-dev libc6-dev-i386 nodejs npm python3-dev python3-pip ndk安装 wget https://dl.google.com/android/repository/android-ndk-r22b-linux-x86_64.zip unzip android-ndk-r22-linux-x86_64.zip 再添加到环境变量中 export ANDROID_NDK_ROOT=xxxxxx export PATH=$ANDROID_NDK_ROOT:$PATH 执行ndk-build --v如果有版本信息输出，说明环境变量配置生效了 ","date":"2023-08-20","objectID":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/:0:1","series":null,"tags":["frida源码编译"],"title":"Frida源码编译说明","uri":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/#一编译环境搭建"},{"categories":["frida生态"],"content":" 一、编译环境搭建这次编译的目标版本是14.2.18 1 物料准备 设备：红米note11（MIUI12 Android11） frida源码：https://github.com/frida/frida 2 工具准备参照官方编译指南 编译支撑系统：ubuntu23 Linux ubuntu23 6.2.0-27-generic #28-Ubuntu SMP PREEMPT_DYNAMIC Wed Jul 12 22:39:51 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux 之所以选择ubuntu23而不是其他版本是因为在安装三方库的时候不用再额外考虑版本问题了，亲测这点太坑了 frida源码下载 git clone -b 14.2.18 --recurse-submodules https://github.com/frida/frida 选择tag为14.2.18，不必全量clone再切换，后续的版本和当前版本差别较大，会造成无法正常编译，原因是因为直接使用checkout的话只是针对frida这个仓库，但是对于submodule来说版本依旧未变，需要执行如下命令 git submodule update --recursive toolchain/sdk 可以选择自己编译，但是为了减少不必要的麻烦，直接选择官方已经打好的编译产物，frida官方是存在toolchain/sdk的编译后的产物，可以直接下，下载链接的格式参考 https://build.frida.re/deps/{frida_toolchain_version}/toolchain-linux-x86_64.tar.bz2 frida_toolchain_version可以从releng/deps.mk中获取 frida_toolchain_version = 20210419 最终可得的下载地址是 https://build.frida.re/deps/20210419/toolchain-linux-x86_64.tar.bz2 # toolchains 工具 https://build.frida.re/deps/20210419/sdk-linux-x86_64.tar.bz2 # sdk 工具 # 下面是需要编译的对应架构的文件 https://build.frida.re/deps/20210419/sdk-android-x86.tar.bz2 https://build.frida.re/deps/20210419/sdk-android-x86_64.tar.bz2 https://build.frida.re/deps/20210419/sdk-android-arm.tar.bz2 https://build.frida.re/deps/20210419/sdk-android-arm64.tar.bz2 将上面的四个文件分别下载好后放在frida/build目录下（没有可新建），执行命令 bash releng/setup-env.sh 输出结果如下 Assuming host is linux-x86_64 Set FRIDA_HOST to override. Deploying local toolchain toolchain-linux-x86_64.tar.bz2... Deploying local SDK sdk-linux-x86_64.tar.bz2... 三方库安装 sudo apt-get install build-essential curl git lib32stdc++-9-dev libc6-dev-i386 nodejs npm python3-dev python3-pip ndk安装 wget https://dl.google.com/android/repository/android-ndk-r22b-linux-x86_64.zip unzip android-ndk-r22-linux-x86_64.zip 再添加到环境变量中 export ANDROID_NDK_ROOT=xxxxxx export PATH=$ANDROID_NDK_ROOT:$PATH 执行ndk-build --v如果有版本信息输出，说明环境变量配置生效了 ","date":"2023-08-20","objectID":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/:0:1","series":null,"tags":["frida源码编译"],"title":"Frida源码编译说明","uri":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/#1-物料准备"},{"categories":["frida生态"],"content":" 一、编译环境搭建这次编译的目标版本是14.2.18 1 物料准备 设备：红米note11（MIUI12 Android11） frida源码：https://github.com/frida/frida 2 工具准备参照官方编译指南 编译支撑系统：ubuntu23 Linux ubuntu23 6.2.0-27-generic #28-Ubuntu SMP PREEMPT_DYNAMIC Wed Jul 12 22:39:51 UTC 2023 x86_64 x86_64 x86_64 GNU/Linux 之所以选择ubuntu23而不是其他版本是因为在安装三方库的时候不用再额外考虑版本问题了，亲测这点太坑了 frida源码下载 git clone -b 14.2.18 --recurse-submodules https://github.com/frida/frida 选择tag为14.2.18，不必全量clone再切换，后续的版本和当前版本差别较大，会造成无法正常编译，原因是因为直接使用checkout的话只是针对frida这个仓库，但是对于submodule来说版本依旧未变，需要执行如下命令 git submodule update --recursive toolchain/sdk 可以选择自己编译，但是为了减少不必要的麻烦，直接选择官方已经打好的编译产物，frida官方是存在toolchain/sdk的编译后的产物，可以直接下，下载链接的格式参考 https://build.frida.re/deps/{frida_toolchain_version}/toolchain-linux-x86_64.tar.bz2 frida_toolchain_version可以从releng/deps.mk中获取 frida_toolchain_version = 20210419 最终可得的下载地址是 https://build.frida.re/deps/20210419/toolchain-linux-x86_64.tar.bz2 # toolchains 工具 https://build.frida.re/deps/20210419/sdk-linux-x86_64.tar.bz2 # sdk 工具 # 下面是需要编译的对应架构的文件 https://build.frida.re/deps/20210419/sdk-android-x86.tar.bz2 https://build.frida.re/deps/20210419/sdk-android-x86_64.tar.bz2 https://build.frida.re/deps/20210419/sdk-android-arm.tar.bz2 https://build.frida.re/deps/20210419/sdk-android-arm64.tar.bz2 将上面的四个文件分别下载好后放在frida/build目录下（没有可新建），执行命令 bash releng/setup-env.sh 输出结果如下 Assuming host is linux-x86_64 Set FRIDA_HOST to override. Deploying local toolchain toolchain-linux-x86_64.tar.bz2... Deploying local SDK sdk-linux-x86_64.tar.bz2... 三方库安装 sudo apt-get install build-essential curl git lib32stdc++-9-dev libc6-dev-i386 nodejs npm python3-dev python3-pip ndk安装 wget https://dl.google.com/android/repository/android-ndk-r22b-linux-x86_64.zip unzip android-ndk-r22-linux-x86_64.zip 再添加到环境变量中 export ANDROID_NDK_ROOT=xxxxxx export PATH=$ANDROID_NDK_ROOT:$PATH 执行ndk-build --v如果有版本信息输出，说明环境变量配置生效了 ","date":"2023-08-20","objectID":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/:0:1","series":null,"tags":["frida源码编译"],"title":"Frida源码编译说明","uri":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/#2-工具准备"},{"categories":["frida生态"],"content":" 二、编译流程切换到frida项目根目录下执行命令make core-android-arm64 1 缺少build/frida-version.h make[1]: *** No rule to make target '.git/refs/heads/master', needed by 'build/frida-version.h'. Stop. 需要在build目录下手动添加build/frida-version.h文件，内容如 #ifndef __FRIDA_VERSION_H__ #define __FRIDA_VERSION_H__ #define FRIDA_VERSION \"14.2.2\" #define FRIDA_MAJOR_VERSION 14 #define FRIDA_MINOR_VERSION 2 #define FRIDA_MICRO_VERSION 2 #define FRIDA_NANO_VERSION 0 #endif 2 分支修改下载的14.2.18版本，需要将frida-deps.vcxproj（4处）和frida.mk（1处）中的master修改为main 3 执行编译执行make core-android-arm64命令之后正常输出如下 Installing lib/gadget/frida-gadget.so to /home/linhanqiu/proj/frida/build/frida-android-arm64/lib/frida/64 This file does not have an rpath. This file does not have a runpath. Installing src/api/frida-core.h to /home/linhanqiu/proj/frida/build/frida-android-arm64/include/frida-1.0 Installing src/api/frida-core-1.0.vapi to /home/linhanqiu/proj/frida/build/frida-android-arm64/share/vala/vapi Installing src/api/frida-core-1.0.deps to /home/linhanqiu/proj/frida/build/frida-android-arm64/share/vala/vapi Installing src/api/libfrida-core-1.0.a to /home/linhanqiu/proj/frida/build/frida-android-arm64/lib Installing server/frida-server to /home/linhanqiu/proj/frida/build/frida-android-arm64/bin This file does not have an rpath. This file does not have a runpath. Installing inject/frida-inject to /home/linhanqiu/proj/frida/build/frida-android-arm64/bin This file does not have an rpath. This file does not have a runpath. Installing /home/linhanqiu/proj/frida/frida-core/lib/selinux/frida-selinux.h to /home/linhanqiu/proj/frida/build/frida-android-arm64/include/frida-1.0 Installing /home/linhanqiu/proj/frida/build/tmp-android-arm64/frida-core/meson-private/frida-core-1.0.pc to /home/linhanqiu/proj/frida/build/frida-android-arm64/lib/pkgconfig make[1]: Leaving directory '/home/linhanqiu/proj/frida' 由于选择的架构是arm64，对应的输出目录是build/tmp-android-arm64 ","date":"2023-08-20","objectID":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/:0:2","series":null,"tags":["frida源码编译"],"title":"Frida源码编译说明","uri":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/#二编译流程"},{"categories":["frida生态"],"content":" 二、编译流程切换到frida项目根目录下执行命令make core-android-arm64 1 缺少build/frida-version.h make[1]: *** No rule to make target '.git/refs/heads/master', needed by 'build/frida-version.h'. Stop. 需要在build目录下手动添加build/frida-version.h文件，内容如 #ifndef __FRIDA_VERSION_H__ #define __FRIDA_VERSION_H__ #define FRIDA_VERSION \"14.2.2\" #define FRIDA_MAJOR_VERSION 14 #define FRIDA_MINOR_VERSION 2 #define FRIDA_MICRO_VERSION 2 #define FRIDA_NANO_VERSION 0 #endif 2 分支修改下载的14.2.18版本，需要将frida-deps.vcxproj（4处）和frida.mk（1处）中的master修改为main 3 执行编译执行make core-android-arm64命令之后正常输出如下 Installing lib/gadget/frida-gadget.so to /home/linhanqiu/proj/frida/build/frida-android-arm64/lib/frida/64 This file does not have an rpath. This file does not have a runpath. Installing src/api/frida-core.h to /home/linhanqiu/proj/frida/build/frida-android-arm64/include/frida-1.0 Installing src/api/frida-core-1.0.vapi to /home/linhanqiu/proj/frida/build/frida-android-arm64/share/vala/vapi Installing src/api/frida-core-1.0.deps to /home/linhanqiu/proj/frida/build/frida-android-arm64/share/vala/vapi Installing src/api/libfrida-core-1.0.a to /home/linhanqiu/proj/frida/build/frida-android-arm64/lib Installing server/frida-server to /home/linhanqiu/proj/frida/build/frida-android-arm64/bin This file does not have an rpath. This file does not have a runpath. Installing inject/frida-inject to /home/linhanqiu/proj/frida/build/frida-android-arm64/bin This file does not have an rpath. This file does not have a runpath. Installing /home/linhanqiu/proj/frida/frida-core/lib/selinux/frida-selinux.h to /home/linhanqiu/proj/frida/build/frida-android-arm64/include/frida-1.0 Installing /home/linhanqiu/proj/frida/build/tmp-android-arm64/frida-core/meson-private/frida-core-1.0.pc to /home/linhanqiu/proj/frida/build/frida-android-arm64/lib/pkgconfig make[1]: Leaving directory '/home/linhanqiu/proj/frida' 由于选择的架构是arm64，对应的输出目录是build/tmp-android-arm64 ","date":"2023-08-20","objectID":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/:0:2","series":null,"tags":["frida源码编译"],"title":"Frida源码编译说明","uri":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/#1-缺少buildfrida-versionh"},{"categories":["frida生态"],"content":" 二、编译流程切换到frida项目根目录下执行命令make core-android-arm64 1 缺少build/frida-version.h make[1]: *** No rule to make target '.git/refs/heads/master', needed by 'build/frida-version.h'. Stop. 需要在build目录下手动添加build/frida-version.h文件，内容如 #ifndef __FRIDA_VERSION_H__ #define __FRIDA_VERSION_H__ #define FRIDA_VERSION \"14.2.2\" #define FRIDA_MAJOR_VERSION 14 #define FRIDA_MINOR_VERSION 2 #define FRIDA_MICRO_VERSION 2 #define FRIDA_NANO_VERSION 0 #endif 2 分支修改下载的14.2.18版本，需要将frida-deps.vcxproj（4处）和frida.mk（1处）中的master修改为main 3 执行编译执行make core-android-arm64命令之后正常输出如下 Installing lib/gadget/frida-gadget.so to /home/linhanqiu/proj/frida/build/frida-android-arm64/lib/frida/64 This file does not have an rpath. This file does not have a runpath. Installing src/api/frida-core.h to /home/linhanqiu/proj/frida/build/frida-android-arm64/include/frida-1.0 Installing src/api/frida-core-1.0.vapi to /home/linhanqiu/proj/frida/build/frida-android-arm64/share/vala/vapi Installing src/api/frida-core-1.0.deps to /home/linhanqiu/proj/frida/build/frida-android-arm64/share/vala/vapi Installing src/api/libfrida-core-1.0.a to /home/linhanqiu/proj/frida/build/frida-android-arm64/lib Installing server/frida-server to /home/linhanqiu/proj/frida/build/frida-android-arm64/bin This file does not have an rpath. This file does not have a runpath. Installing inject/frida-inject to /home/linhanqiu/proj/frida/build/frida-android-arm64/bin This file does not have an rpath. This file does not have a runpath. Installing /home/linhanqiu/proj/frida/frida-core/lib/selinux/frida-selinux.h to /home/linhanqiu/proj/frida/build/frida-android-arm64/include/frida-1.0 Installing /home/linhanqiu/proj/frida/build/tmp-android-arm64/frida-core/meson-private/frida-core-1.0.pc to /home/linhanqiu/proj/frida/build/frida-android-arm64/lib/pkgconfig make[1]: Leaving directory '/home/linhanqiu/proj/frida' 由于选择的架构是arm64，对应的输出目录是build/tmp-android-arm64 ","date":"2023-08-20","objectID":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/:0:2","series":null,"tags":["frida源码编译"],"title":"Frida源码编译说明","uri":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/#2-分支修改"},{"categories":["frida生态"],"content":" 二、编译流程切换到frida项目根目录下执行命令make core-android-arm64 1 缺少build/frida-version.h make[1]: *** No rule to make target '.git/refs/heads/master', needed by 'build/frida-version.h'. Stop. 需要在build目录下手动添加build/frida-version.h文件，内容如 #ifndef __FRIDA_VERSION_H__ #define __FRIDA_VERSION_H__ #define FRIDA_VERSION \"14.2.2\" #define FRIDA_MAJOR_VERSION 14 #define FRIDA_MINOR_VERSION 2 #define FRIDA_MICRO_VERSION 2 #define FRIDA_NANO_VERSION 0 #endif 2 分支修改下载的14.2.18版本，需要将frida-deps.vcxproj（4处）和frida.mk（1处）中的master修改为main 3 执行编译执行make core-android-arm64命令之后正常输出如下 Installing lib/gadget/frida-gadget.so to /home/linhanqiu/proj/frida/build/frida-android-arm64/lib/frida/64 This file does not have an rpath. This file does not have a runpath. Installing src/api/frida-core.h to /home/linhanqiu/proj/frida/build/frida-android-arm64/include/frida-1.0 Installing src/api/frida-core-1.0.vapi to /home/linhanqiu/proj/frida/build/frida-android-arm64/share/vala/vapi Installing src/api/frida-core-1.0.deps to /home/linhanqiu/proj/frida/build/frida-android-arm64/share/vala/vapi Installing src/api/libfrida-core-1.0.a to /home/linhanqiu/proj/frida/build/frida-android-arm64/lib Installing server/frida-server to /home/linhanqiu/proj/frida/build/frida-android-arm64/bin This file does not have an rpath. This file does not have a runpath. Installing inject/frida-inject to /home/linhanqiu/proj/frida/build/frida-android-arm64/bin This file does not have an rpath. This file does not have a runpath. Installing /home/linhanqiu/proj/frida/frida-core/lib/selinux/frida-selinux.h to /home/linhanqiu/proj/frida/build/frida-android-arm64/include/frida-1.0 Installing /home/linhanqiu/proj/frida/build/tmp-android-arm64/frida-core/meson-private/frida-core-1.0.pc to /home/linhanqiu/proj/frida/build/frida-android-arm64/lib/pkgconfig make[1]: Leaving directory '/home/linhanqiu/proj/frida' 由于选择的架构是arm64，对应的输出目录是build/tmp-android-arm64 ","date":"2023-08-20","objectID":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/:0:2","series":null,"tags":["frida源码编译"],"title":"Frida源码编译说明","uri":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/#3-执行编译"},{"categories":["frida生态"],"content":" 三、产物测试在官方版本列表上看frida-server14.2.18对应的python工具库版本 pip install frida==14.2.18 pip install frida-tools==9.2.4 测试具体案例 ","date":"2023-08-20","objectID":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/:0:3","series":null,"tags":["frida源码编译"],"title":"Frida源码编译说明","uri":"/frida%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E8%AF%B4%E6%98%8E/#三产物测试"},{"categories":["frida生态"],"content":" 一、资源准备 com.jingdong.app.mall 12.1.0 pixel2 android10.0 frida 14.2.2 ","date":"2023-08-19","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B2/:0:1","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例2","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B2/#一资源准备"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `com.jingdong.app.mall`. Resuming main thread! [Pixel 2::com.jingdong.app.mall]-\u003e Process terminated [Pixel 2::com.jingdong.app.mall]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libJDMobileSec之后，进程就崩溃了，可以猜测反调试点在libJDMobileSec中 Spawned `com.jingdong.app.mall`. Resuming main thread! [Pixel 2::com.jingdong.app.mall]-\u003e load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/com.jingdong.app.mall-OXNoca8Sb7xq1IC0YJW2PA==/oat/arm/base.odex load /data/app/com.jingdong.app.mall-OXNoca8Sb7xq1IC0YJW2PA==/lib/arm/libJDMobileSec.so Process terminated 同样需要判断具体检测的函数在哪个部分，优先确定JNI_OnLoad的偏移是0x56BC function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libJDMobileSec.so\") Interceptor.attach(module.base.add(0x56BC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen,\"libJDMobileSec.so\") 看到是在JNI_OnLoad之后进程崩溃的，说明检测逻辑应该是JNI_OnLoad里面 Spawned `com.jingdong.app.mall`. Resuming main thread! [Pixel 2::com.jingdong.app.mall]-\u003e call JNI_OnLoad Process terminated 测试下是否有新起线程检测 function hook_pthread_create(){ var base = Process.findModuleByName(\"libJDMobileSec.so\").base console.log(\"libJDMobileSec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } 可以看到有个新起的线程 Spawned `com.jingdong.app.mall`. Resuming main thread! [Pixel 2::com.jingdong.app.mall]-\u003e call JNI_OnLoad libJDMobileSec.so --- 0xce055000 The thread function address is 0xce06151d offset:c51d Process terminated 优先nop掉看是否该点是检测点，追溯到JNI_OnLoad方法里面偏移0x688A上 function bypass(){ let module = Process.findModuleByName(\"libJDMobileSec.so\") nop(module.base.add(0x688A)) } nop掉之后还是崩溃，看来检测点可能不是这里或者不止一个，继续尝试其他hook点 function replace_str() { var pt_strstr = Module.findExportByName(\"libc.so\", 'strstr'); Interceptor.attach(pt_strstr, { onEnter: function (args) { var str1 = args[0].readCString(); var str2 = args[1].readCString(); console.log(\"strstr--\u003e\", str1, str2); // console.log('strstr called from:\\\\n' + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join('\\\\n') + '\\\\n'); // console.log('strstr called from:\\\\n' + Thread.backtrace(this.context, Backtracer.FUZZY).map(DebugSymbol.fromAddress).join('\\\\n') + '\\\\n'); } }); } 看看字符比较会不会有发现 strstr--\u003e bb123000-bb222000 r--p 00000000 103:1d 2720259 /data/app/com.jingdong.app.mall-OXNoca8Sb7xq1IC0YJW2PA==/oat/arm/base.odex com.saurik.substrate strstr called from:\\n0xcdf5dbfb libJDMobileSec.so!0xabfb\\n0xcdf6e5a1 libJDMobileSec.so!0x1b5a1\\n strstr--\u003e bb222000-bb272000 r--p 00000000 103:06 1437 /system/framework/oat/arm/org.apache.http.legacy.odex re.frida.server/frida-agent-32.so strstr called from:\\n0xcdf5da3f libJDMobileSec.so!0xaa3f\\n0xcdf6e5a1 libJDMobileSec.so!0x1b5a1\\n strstr--\u003e bb222000-bb272000 r--p 00000000 103:06 1437 /system/framework/oat/arm/org.apache.http.legacy.odex re.frida.server/frida-agent-64.so strstr called from:\\n0xcdf5da85 libJDMobileSec.so!0xaa85\\n0xcdf6e5a1 libJDMobileSec.so!0x1b5a1\\n strstr--\u003e bb222000-bb272000 r--p 00000000 103:06 1437 /system/framework/oat/arm/org.apache.http.legacy.odex com.saurik.substrate strstr called from:\\n0xcdf5dbfb lib","date":"2023-08-19","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B2/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例2","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B2/#二分析思路"},{"categories":["frida生态"],"content":" 三 总结完整代码看这里libJDMobileSec.js ","date":"2023-08-19","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B2/:0:3","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例2","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B2/#三-总结"},{"categories":["frida生态"],"content":" 一、资源准备 tv.danmaku.bili 7.43.0 pixel2 android10.0 frida 14.2.2 ","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:1","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#一资源准备"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#二分析思路"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#1-反调试检测"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#11-0x11129"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#111-sub_10be8"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#112-sub_10d1c"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#113-sub_10dec"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#114-sub_16b48"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#12-0x10975"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#121-sub_1041c"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#122-sub_1025c"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#123-sub_10850"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#124-sub_af84"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#2-字符解密"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#3-对抗方式"},{"categories":["frida生态"],"content":" 二、分析思路使用frida以spawn模式启动，可以发现进程直接崩溃，说明存在反调试 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 通常检测逻辑是放在native层的，因此进一步判断是哪个so导致的 function hook_dlopen() { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); console.log(\"load \" + path); } } } ); } 由so的加载流程可知，so都是是顺序加载，从命令行中当加载libmsaoaidsec.so之后，进程就崩溃了，可以猜测反调试点在libmsaoaidsec.so中 [Pixel 2::tv.danmaku.bili]-\u003e load /system/framework/oat/arm/com.android.future.usb.accessory.odex load /system/framework/oat/arm/org.apache.http.legacy.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/oat/arm/base.odex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libblkv.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbili_core.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libbilicr.88.0.4324.188.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libijkffmpeg.so load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libavif-jni.so load /data/dalvik-cache/arm/system@product@app@TrichromeLibrary@TrichromeLibrary.apk@classes.dex load /data/dalvik-cache/arm/system@product@app@WebViewGoogle@WebViewGoogle.apk@classes.dex load /data/app/tv.danmaku.bili-j_iiq65L9CsVGLfbrhaTgA==/lib/arm/libmsaoaidsec.so Process terminated 而libmsaoaidsec.so从字面上可知是MSA（移动安全联盟）出品的，确定了so之后，需要进一步确定具体的函数，so的函数执行顺序是.init函数-\u003eJNI_OnLoad，先判断下是在JNI_OnLoad前后进行检测的 从libmsaoaidsec.so的export函数表中可以知道JNI_OnLoad的偏移量是0xC6DC，先hook JNI_OnLoad尝试下 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { this.is_can_hook = true; } } }, onLeave: function (retval) { if (this.is_can_hook) { hook_JNI_OnLoad() } } } ); } function hook_JNI_OnLoad(){ let module = Process.findModuleByName(\"libmsaoaidsec.so\") Interceptor.attach(module.base.add(0xC6DC + 1), { onEnter(args){ console.log(\"call JNI_OnLoad\") } }) } setImmediate(hook_dlopen, \"libmsaoaidsec.so\") 结果依旧是进程崩溃 Spawned `tv.danmaku.bili`. Resuming main thread! [Pixel 2::tv.danmaku.bili]-\u003e Process terminated [Pixel 2::tv.danmaku.bili]-\u003e 那么可以断定检测位置在JNI_OnLoad之前，因此需要hook .init函数，选取.init_proc中的外部函数引用来做入口 int sub_B1B4() { _DWORD *v0; // r5 int result; // r0 int v2; // r1 int v3; // [sp+0h] [bp-20h] int v4; // [sp+4h] [bp-1Ch] int v5; // [sp+Ch] [bp-14h] v0 = off_1FC04; v5 = *(_DWORD *)off_1FC04; v4 = 0; v3 = 0; // 选取 _system_property_get(\"ro.build.version.sdk\", \u0026v3); result = atoi((const char *)\u0026v3); v2 = *v0 - v5; return result; } 以pthread_create函数为例，尝试下是否有启动线程来做检测 function hook_dlopen(soName = '') { Interceptor.attach(Module.findExportByName(null, \"android_dlopen_ext\"), { onEnter: function (args) { var pathptr = args[0]; if (pathptr !== undefined \u0026\u0026 pathptr != null) { var path = ptr(pathptr).readCString(); if (path.indexOf(soName) \u003e= 0) { locate_init() } } } } ); } function locate_init() { let secmodule = null Interceptor.attach(Module.findExportByName(null, \"__system_property_get\"), { // _system_property_get(\"ro.build.version.sdk\", v1); onEnter: function (args) { secmodule = Process.findModuleByName(\"libmsaoaidsec.so\") var name = args[0]; if (name !== undefined \u0026\u0026 name != null) { name = ptr(name).readCString(); if (name.indexOf(\"ro.build.version.sdk\") \u003e= 0) { hook_pthread_create() } } } } ); } function hook_pthread_create(){ var base = Process.findModuleByName(\"libmsaoaidsec.so\").base console.log(\"libmsaoaidsec.so --- \" + base) Interceptor.attach(Module.findExportByName(\"libc.so\", \"pthread_create\"),{ onEnter(args){ let func_addr = args[2] console.log(\"The thread function address is \" + func_addr + \" offset:\" + (func_addr-base).toString(16)) } }) } setImmediate(hook_dlo","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:2","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#31-调用点指令nop"},{"categories":["frida生态"],"content":" 三、总结从上面的检测方式可以大概总结如下： frida特征 inlinehoook特征 trace特征 通常都是通过strstr来做判断，但是某些情况，例如验证inlinehook指令时无法直接定位，杀死进程通常都是使用exit或是通过svc exit_group来操作 完整代码看这里libmsaoaidsec.js ","date":"2023-08-18","objectID":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/:0:3","series":null,"tags":["frida特征对抗"],"title":"Frida特征对抗案例1","uri":"/frida%E7%89%B9%E5%BE%81%E5%AF%B9%E6%8A%97%E6%A1%88%E4%BE%8B1/#三总结"},{"categories":["riru"],"content":" 前言最近在搜索riru相关的项目时偶尔发现了HuskyDG riru项目中的一个实验性想法 也就是更换加载riru的方式，众所周知，riru.so load是通过赋值ro.dalvik.vm.native.bridge为libriruloader.so来完成的，而HuskyDG则提出了一个新的试验性加载方式—通过修改libandroid_runtime.so替换ro.zygote属性来完成加载 而ro.zygote属性是指的什么呢？它所表达的含义是指定zygote的执行程序时什么，通常情况下它的取值有四种，zygote32、zygote64、zygote32_64、zygote64_32，分别对应着四种.rc文件 init.zygote32.rc：zygote 进程对应的执行程序是 app_process（纯 32bit 模式） init.zygote64.rc：zygote 进程对应的执行程序是 app_process64（纯 64bit 模式） init.zygote32_64.rc：启动两个 zygote 进程（名为 zygote 和 zygote_secondary），对应的执行程序分别是 app_process32（主模式）、app_process64 init.zygote64_32.rc：启动两个 zygote 进程（名为 zygote 和 zygote_secondary），对应的执行程序分别是 app_process64（主模式）、app_process32 而之所以要定义这么多种模式时因为在Android5.0之后开始支持64位程序，为了保证兼容性而推出的 看起来ro.zygote与load并没有什么直接联系，那么HuskyDG的这种新的load方式是怎么实现的呢？ ","date":"2023-08-18","objectID":"/%E6%8E%A2%E8%AE%A8%E6%96%B0%E7%9A%84riru%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["riru原理"],"title":"探讨新的riru加载方式","uri":"/%E6%8E%A2%E8%AE%A8%E6%96%B0%E7%9A%84riru%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/#前言"},{"categories":["riru"],"content":" 一、原理分析核心代码在commit: 90ec934上，关键代码在两处 # template/magisk_module/service.sh mkdir -p \"$(magisk --path)/riru\" patch_lib(){ /data/adb/magisk/magiskboot hexpatch \"$1\" \\ 726f2e64616c76696b2e766d2e6e61746976652e62726964676500 \\ 726f2e7a79676f7465000000000000000000000000000000000000 } if [ -f /system/lib/libandroid_runtime.so ]; then cp -af /system/lib/libandroid_runtime.so \"$(magisk --path)/riru/libandroid_runtime.so.32\" magisk --clone-attr /system/lib/libandroid_runtime.so \"$(magisk --path)/riru/libandroid_runtime.so.32\" patch_lib \"$(magisk --path)/riru/libandroid_runtime.so.32\" mount --bind \"$(magisk --path)/riru/libandroid_runtime.so.32\" /system/lib/libandroid_runtime.so fi if [ -f /system/lib64/libandroid_runtime.so ]; then cp -af /system/lib64/libandroid_runtime.so \"$(magisk --path)/riru/libandroid_runtime.so.64\" magisk --clone-attr /system/lib64/libandroid_runtime.so \"$(magisk --path)/riru/libandroid_runtime.so.64\" patch_lib \"$(magisk --path)/riru/libandroid_runtime.so.64\" mount --bind \"$(magisk --path)/riru/libandroid_runtime.so.64\" /system/lib64/libandroid_runtime.so fi // restart zygote stop; start; 这里是service.sh新增的代码，从代码中可以看到操作步骤是提取libandroid_runtime.so-\u003epatch libandroid_runtime.so-\u003emount bind将修改同步，主要看patch的过程，将726f2e64616c76696b2e766d2e6e61746976652e62726964676500的hex值修改成726f2e7a79676f7465000000000000000000000000000000000000，也就是将ro.dalvik.vm.native.bridge修改成ro.zygote 为了保证libandroid_runtime.so的总体长度不变，这里额外补充了0来补位 而这么做的意义是什么呢？从libandroid_runtime.so的源码来看 // core/jni/AndroidRuntime.cpp // Native bridge library. \"0\" means that native bridge is disabled. // // Note: bridging is only enabled for the zygote. Other runs of // app_process may not have the permissions to mount etc. property_get(\"ro.dalvik.vm.native.bridge\", propBuf, \"\"); if (propBuf[0] == '\\0') { ALOGW(\"ro.dalvik.vm.native.bridge is not expected to be empty\"); } else if (zygote \u0026\u0026 strcmp(propBuf, \"0\") != 0) { snprintf(nativeBridgeLibrary, sizeof(\"-XX:NativeBridge=\") + PROPERTY_VALUE_MAX, \"-XX:NativeBridge=%s\", propBuf); addOption(nativeBridgeLibrary); } 将原先读取ro.dalvik.vm.native.bridge属性的地方改成了读取ro.zygote属性，避免了对ro.dalvik.vm.native.bridge的赋值，而ro.zygote属性在原生设备上已经赋值，当ro.zygote有值时，就会去加载/system/lib/$(getprop ro.zygote)的so文件 # template/magisk_module/post-fs-data.sh cd \"$MODDIR\" || exit flock \"module.prop\" mount --bind \"$TMPPROP\" \"$MODDIR/module.prop\" # 新增 ln -s ./libriruloader.so \"$MODDIR/system/lib/$(getprop ro.zygote)\" ln -s ./libriruloader.so \"$MODDIR/system/lib64/$(getprop ro.zygote)\" # unshare -m sh -c \"/system/bin/app_process -Djava.class.path=rirud.apk /system/bin --nice-name=rirud riru.Daemon $(magisk -V) $(magisk --path) $(getprop ro.dalvik.vm.native.bridge)\u0026\" umount \"$MODDIR/module.prop\" 而在post-fs-data阶段，又操作了软链，让/system/lib/$(getprop ro.zygote)实际指向的是libriruloader.so，从而完成libriruloader.so的加载 基本的实现流程就是这样，可以看出HuskyDG的这种方式还是很巧妙的，另外在实现这种方式的同时，HuskyDG也针对性的修改了原有代码和增加了maps隐藏的逻辑 // rirud/src/main/java/riru/DaemonUtils.java public static void resetNativeBridgeProp(String value) { //resetProperty(\"ro.dalvik.vm.native.bridge\", value); return; } 去除原有对于ro.dalvik.vm.native.bridge属性的修改，移除template/magisk_module/system.prop // riru/src/main/cpp/jni_hooks.cpp static std::vector\u003clsplt::MapInfo\u003e find_maps(const char *name) { auto maps = lsplt::MapInfo::Scan(); for (auto iter = maps.begin(); iter != maps.end();) { if (iter-\u003epath != name) { iter = maps.erase(iter); } else { ++iter; } } return maps; } void remap_all(const char *name) { // 过滤出带有libandroid_runtime.so的segment auto maps = find_maps(name); for (auto \u0026info : maps) { void *addr = reinterpret_cast\u003cvoid *\u003e(info.start); // 获取size size_t size = info.end - info.start; // 重新mmap申请内存地址 void *copy = mmap(nullptr, size, PROT_WRITE, MAP_ANONYMOUS | MAP_PRIVATE, -1, 0); // 设置读权限 if ((info.perms \u0026 PROT_READ) == 0) { mprotect(addr, size, PROT_READ); } // 复制到刚申请的内存上 memcpy(copy, addr, size); // 匹配大小 mremap(copy, size, size, MREMAP_MAYMOVE | MREMAP_FIXED, addr); // 重新授权 mprotect(addr, size, info.perms); } } void fakemap_file(const char *name) { a","date":"2023-08-18","objectID":"/%E6%8E%A2%E8%AE%A8%E6%96%B0%E7%9A%84riru%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/:0:2","series":null,"tags":["riru原理"],"title":"探讨新的riru加载方式","uri":"/%E6%8E%A2%E8%AE%A8%E6%96%B0%E7%9A%84riru%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/#一原理分析"},{"categories":["riru"],"content":" 二、新方式的思考相比于老方式来说，新方案没有更改系统属性，而是借助于Magisk修改libandroid_runtime.so。来在HuskyDG的电报群内和一些开发者讨论过，都一致认为这种新方式所暴露出来的风险是大于老方案的，确实如HuskyDG所说，这种新方式只是一种探索吧 ","date":"2023-08-18","objectID":"/%E6%8E%A2%E8%AE%A8%E6%96%B0%E7%9A%84riru%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/:0:3","series":null,"tags":["riru原理"],"title":"探讨新的riru加载方式","uri":"/%E6%8E%A2%E8%AE%A8%E6%96%B0%E7%9A%84riru%E5%8A%A0%E8%BD%BD%E6%96%B9%E5%BC%8F/#二新方式的思考"},{"categories":null,"content":" dobby jnitrace lsposed lsplant lspatch frida sandhook ","date":"2023-08-08","objectID":"/todo/:0:0","series":null,"tags":null,"title":"待更清单","uri":"/todo/#"},{"categories":null,"content":"Focus On Android Security| ","date":"2023-08-08","objectID":"/about/:0:0","series":null,"tags":null,"title":"关于","uri":"/about/#"},{"categories":null,"content":"福州话中“碎讲”指的是碎碎念，可以认为是日常生活中的一些零碎想法 ","date":"2023-08-08","objectID":"/talk/:0:0","series":null,"tags":null,"title":"碎讲","uri":"/talk/#"},{"categories":["特征检测对抗"],"content":" 一、前言maps文件在Android中一般指/proc/pid/maps，记录着每个进程的内存映射信息，也就是每个进程都会有一个对应的文件。在之前的特征分析中，发现像dobby hook框架、frida等工具都会造成maps中的数据改变，因此想深入分析下这种特征的形成原因以及可以采用什么方式进行对抗 ","date":"2023-08-06","objectID":"/maps%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/:0:1","series":null,"tags":["maps特征"],"title":"Maps特征检测对抗","uri":"/maps%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/#一前言"},{"categories":["特征检测对抗"],"content":" 二、maps文件形成以微信进程为例，看看它的maps文件 selene:/ # cat /proc/9336/maps|head -n 10 020f4000-020f6000 r--p 00000000 fd:01 424 /system/bin/app_process32 020f6000-020fa000 r-xp 00001000 fd:01 424 /system/bin/app_process32 020fa000-020fb000 r--p 00004000 fd:01 424 /system/bin/app_process32 020fb000-020fc000 rw-p 00004000 fd:01 424 /system/bin/app_process32 020fc000-020fd000 rw-p 00000000 00:00 0 [anon:.bss] 12c00000-4af00000 rw-p 00000000 00:00 0 [anon:dalvik-main space (region space)] 57400000-57401000 ---p 00000000 00:00 0 [anon:partition_alloc] 57401000-57402000 rw-p 00000000 00:00 0 [anon:partition_alloc] 57402000-57404000 ---p 00000000 00:00 0 [anon:partition_alloc] 57404000-57430000 rw-p 00000000 00:00 0 [anon:partition_alloc] 从文件内容可以看到，每行内容都对应着一个地址段，可以划分为七列，在内核中每行数据使用vm_area_struct结构体，也就是VMA来表示 // include/linux/mm_types.h /* * This struct defines a memory VMM memory area. There is one of these * per VM-area/task. A VM area is any part of the process virtual memory * space that has a special rule for the page-fault handlers (ie a shared * library, the executable area etc). */ struct vm_area_struct { /* The first cache line has the info for VMA tree walking. */ unsigned long vm_start; /* Our start address within vm_mm. */ unsigned long vm_end; /* The first byte after our end address within vm_mm. */ /* linked list of VM areas per task, sorted by address */ struct vm_area_struct *vm_next, *vm_prev; struct rb_node vm_rb; /* * Largest free memory gap in bytes to the left of this VMA. * Either between this VMA and vma-\u003evm_prev, or between one of the * VMAs below us in the VMA rbtree and its -\u003evm_prev. This helps * get_unmapped_area find a free area of the right size. */ unsigned long rb_subtree_gap; /* Second cache line starts here. */ struct mm_struct *vm_mm; /* The address space we belong to. */ pgprot_t vm_page_prot; /* Access permissions of this VMA. */ unsigned long vm_flags; /* Flags, see mm.h. */ /* * For areas with an address space and backing store, * linkage into the address_space-\u003ei_mmap interval tree. * * For private anonymous mappings, a pointer to a null terminated string * in the user process containing the name given to the vma, or NULL * if unnamed. */ union { struct { struct rb_node rb; unsigned long rb_subtree_last; } shared; const char __user *anon_name; }; /* * A file's MAP_PRIVATE vma can be in both i_mmap tree and anon_vma * list, after a COW of one of the file pages. A MAP_SHARED vma * can only be in the i_mmap tree. An anonymous MAP_PRIVATE, stack * or brk vma (with NULL file) can only be in an anon_vma list. */ struct list_head anon_vma_chain; /* Serialized by mmap_sem \u0026 * page_table_lock */ struct anon_vma *anon_vma; /* Serialized by page_table_lock */ /* Function pointers to deal with this struct. */ const struct vm_operations_struct *vm_ops; /* Information about our backing store: */ unsigned long vm_pgoff; /* Offset (within vm_file) in PAGE_SIZE units */ struct file * vm_file; /* File we map to (can be NULL). */ void * vm_private_data; /* was vm_pte (shared mem) */ atomic_long_t swap_readahead_info; #ifndef CONFIG_MMU struct vm_region *vm_region; /* NOMMU mapping region */ #endif #ifdef CONFIG_NUMA struct mempolicy *vm_policy; /* NUMA policy for the VMA */ #endif struct vm_userfaultfd_ctx vm_userfaultfd_ctx; #ifdef CONFIG_SPECULATIVE_PAGE_FAULT seqcount_t vm_sequence; atomic_t vm_ref_count; /* see vma_get(), vma_put() */ #endif } __randomize_layout; 而最终展示到maps文件中的是以下七列 列数 对应的vm_area_struct属性 含义 “-”前一列，如00377000 vm_start 此段虚拟地址空间起始地址 “-”后一列，如00390000 vm_end 此段虚拟地址空间结束地址 第三列，如r-xp vm_flags 此段虚拟地址空间的属性。每种属性用一个字段表示，r表示可读，w表示可写，x表示可执行，p和s共用一个字段，互斥关系，p表示私有段，s表示共享段，如果没有相应权限，则用’-’代替 第四列，如00000000 vm_pgoff 对有名映射，表示此段虚拟内存起始地址在文件中以页为单位的偏移。对匿名映射，它等于0或者vm_start/PAGE_SIZE 第五列，如fd:00 vm_file-\u003ef_dentry-\u003ed_inode-\u003ei_sb-\u003es_dev 映射文件所属设备号。对匿名映射来说，因为没有文件在磁盘上，所以没有设备号，始终为00:00。对有名映射来说，是映射的文件所在设备的设备号 第六列，如9176473 vm_file-\u003ef_dentry-\u003ed_inode-\u003ei_ino 映射文件所属节点号。对匿名映射来说，因为没有文件在磁盘上，所以没有节点号，始终为00:00。对有名映射来说，是映射的文件的节点号 第七列，如/lib/ld-2.5.so 对有名来说","date":"2023-08-06","objectID":"/maps%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/:0:2","series":null,"tags":["maps特征"],"title":"Maps特征检测对抗","uri":"/maps%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/#二maps文件形成"},{"categories":["特征检测对抗"],"content":" 三、maps特征上面大概了解了maps的形成以及展示过程后，结合hook框架中常暴露的特征来说下 1 lsposed maps特征目前手头上的项目是基于lsposed 1.6.0魔改的，因此以1.6.0的代码为例 // core/src/main/cpp/main/src/context.cpp void Context::OnNativeForkSystemServerPost(JNIEnv *env, jint res) { if (res != 0) return; if (!skip_) { LoadDex(env); Service::instance()-\u003eHookBridge(*this, env); auto binder = Service::instance()-\u003eRequestBinderForSystemServer(env); if (binder) { InstallInlineHooks(); Init(env); FindAndCall(env, \"forkSystemServerPost\", \"(Landroid/os/IBinder;)V\", binder); } else skip_ = true; } setAllowUnload(skip_); } void Context::OnNativeForkAndSpecializePost(JNIEnv *env) { const JUTFString process_name(env, nice_name_); auto binder = skip_ ? ScopedLocalRef\u003cjobject\u003e{env, nullptr} : Service::instance()-\u003eRequestBinder(env, nice_name_); if (binder) { InstallInlineHooks(); LoadDex(env); Init(env); LOGD(\"Done prepare\"); FindAndCall(env, \"forkAndSpecializePost\", \"(Ljava/lang/String;Ljava/lang/String;Landroid/os/IBinder;)V\", app_data_dir_, nice_name_, binder); LOGD(\"injected xposed into %s\", process_name.get()); setAllowUnload(false); } else { auto context = Context::ReleaseInstance(); auto service = Service::ReleaseInstance(); art_img.reset(); LOGD(\"skipped %s\", process_name.get()); setAllowUnload(true); } } 在ForkSystemServerPost和ForkAndSpecializePost函数时会触发inlinehook的操作 void InstallInlineHooks() { if (installed.exchange(true)) [[unlikely]] { LOGD(\"Inline hooks have been installed, skip\"); return; } LOGD(\"Start to install inline hooks\"); const auto \u0026handle_libart = *art_img; if (!handle_libart.isValid()) { LOGE(\"Failed to fetch libart.so\"); } art::Runtime::Setup(handle_libart); art::hidden_api::DisableHiddenApi(handle_libart); art::art_method::Setup(handle_libart); art::Thread::Setup(handle_libart); art::ClassLinker::Setup(handle_libart); art::mirror::Class::Setup(handle_libart); art::JNIEnvExt::Setup(handle_libart); art::instrumentation::DisableUpdateHookedMethodsCode(handle_libart); art::thread_list::ScopedSuspendAll::Setup(handle_libart); art::gc::ScopedGCCriticalSection::Setup(handle_libart); art::jit::jit_code_cache::Setup(handle_libart); art_img.reset(); LOGD(\"Inline hooks installed\"); } 主要是对libart.so的修改，以art::instrumentation::DisableUpdateHookedMethodsCode(handle_libart);为例 // core/src/main/cpp/main/include/art/runtime/instrumentation.h namespace art { namespace instrumentation { CREATE_MEM_HOOK_STUB_ENTRIES( \"_ZN3art15instrumentation15Instrumentation21UpdateMethodsCodeImplEPNS_9ArtMethodEPKv\", void, UpdateMethodsCode, (void * thiz, void * art_method, const void *quick_code), { if (lspd::isHooked(art_method)) [[unlikely]] { LOGD(\"Skip update method code for hooked method %s\", art_method::PrettyMethod(art_method).c_str()); return; } else { backup(thiz, art_method, quick_code); } }); inline void DisableUpdateHookedMethodsCode(const SandHook::ElfImg \u0026handle) { lspd::HookSym(handle, UpdateMethodsCode); } } } // core/src/main/cpp/main/include/base/object.h inline static bool HookSym(H \u0026\u0026handle, T \u0026arg) { auto original = Dlsym(std::forward\u003cH\u003e(handle), arg.sym); return HookSymNoHandle(original, arg); } inline static bool HookSymNoHandle(void *original, T \u0026arg) { if (original) { if constexpr(is_instance\u003cdecltype(arg.backup), MemberFunction\u003e::value) { void *backup; HookFunction(original, reinterpret_cast\u003cvoid *\u003e(arg.replace), \u0026backup); arg.backup = reinterpret_cast\u003ctypename decltype(arg.backup)::FunType\u003e(backup); } else { HookFunction(original, reinterpret_cast\u003cvoid *\u003e(arg.replace), reinterpret_cast\u003cvoid **\u003e(\u0026arg.backup)); } return true; } else { return false; } } inline int HookFunction(void *original, void *replace, void **backup) { _make_rwx(original, _page_size); if constexpr (isDebug) { Dl_info info; if (dladdr(original, \u0026info)) LOGD(\"Hooking %s (%p) from %s (%p)\", info.dli_sname ? info.dli_sname : \"(unknown symbol)\", info.dli_saddr, info.dli_fname ? info.dli_fname : \"(unknown file)\", info.dli_fbase); } return DobbyHook(original, replace, backup); } 这个版本的lsposed所使用到的inlinehook还是基于dobby hook来做的，而dob","date":"2023-08-06","objectID":"/maps%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/:0:3","series":null,"tags":["maps特征"],"title":"Maps特征检测对抗","uri":"/maps%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/#三maps特征"},{"categories":["特征检测对抗"],"content":" 三、maps特征上面大概了解了maps的形成以及展示过程后，结合hook框架中常暴露的特征来说下 1 lsposed maps特征目前手头上的项目是基于lsposed 1.6.0魔改的，因此以1.6.0的代码为例 // core/src/main/cpp/main/src/context.cpp void Context::OnNativeForkSystemServerPost(JNIEnv *env, jint res) { if (res != 0) return; if (!skip_) { LoadDex(env); Service::instance()-\u003eHookBridge(*this, env); auto binder = Service::instance()-\u003eRequestBinderForSystemServer(env); if (binder) { InstallInlineHooks(); Init(env); FindAndCall(env, \"forkSystemServerPost\", \"(Landroid/os/IBinder;)V\", binder); } else skip_ = true; } setAllowUnload(skip_); } void Context::OnNativeForkAndSpecializePost(JNIEnv *env) { const JUTFString process_name(env, nice_name_); auto binder = skip_ ? ScopedLocalRef{env, nullptr} : Service::instance()-\u003eRequestBinder(env, nice_name_); if (binder) { InstallInlineHooks(); LoadDex(env); Init(env); LOGD(\"Done prepare\"); FindAndCall(env, \"forkAndSpecializePost\", \"(Ljava/lang/String;Ljava/lang/String;Landroid/os/IBinder;)V\", app_data_dir_, nice_name_, binder); LOGD(\"injected xposed into %s\", process_name.get()); setAllowUnload(false); } else { auto context = Context::ReleaseInstance(); auto service = Service::ReleaseInstance(); art_img.reset(); LOGD(\"skipped %s\", process_name.get()); setAllowUnload(true); } } 在ForkSystemServerPost和ForkAndSpecializePost函数时会触发inlinehook的操作 void InstallInlineHooks() { if (installed.exchange(true)) [[unlikely]] { LOGD(\"Inline hooks have been installed, skip\"); return; } LOGD(\"Start to install inline hooks\"); const auto \u0026handle_libart = *art_img; if (!handle_libart.isValid()) { LOGE(\"Failed to fetch libart.so\"); } art::Runtime::Setup(handle_libart); art::hidden_api::DisableHiddenApi(handle_libart); art::art_method::Setup(handle_libart); art::Thread::Setup(handle_libart); art::ClassLinker::Setup(handle_libart); art::mirror::Class::Setup(handle_libart); art::JNIEnvExt::Setup(handle_libart); art::instrumentation::DisableUpdateHookedMethodsCode(handle_libart); art::thread_list::ScopedSuspendAll::Setup(handle_libart); art::gc::ScopedGCCriticalSection::Setup(handle_libart); art::jit::jit_code_cache::Setup(handle_libart); art_img.reset(); LOGD(\"Inline hooks installed\"); } 主要是对libart.so的修改，以art::instrumentation::DisableUpdateHookedMethodsCode(handle_libart);为例 // core/src/main/cpp/main/include/art/runtime/instrumentation.h namespace art { namespace instrumentation { CREATE_MEM_HOOK_STUB_ENTRIES( \"_ZN3art15instrumentation15Instrumentation21UpdateMethodsCodeImplEPNS_9ArtMethodEPKv\", void, UpdateMethodsCode, (void * thiz, void * art_method, const void *quick_code), { if (lspd::isHooked(art_method)) [[unlikely]] { LOGD(\"Skip update method code for hooked method %s\", art_method::PrettyMethod(art_method).c_str()); return; } else { backup(thiz, art_method, quick_code); } }); inline void DisableUpdateHookedMethodsCode(const SandHook::ElfImg \u0026handle) { lspd::HookSym(handle, UpdateMethodsCode); } } } // core/src/main/cpp/main/include/base/object.h inline static bool HookSym(H \u0026\u0026handle, T \u0026arg) { auto original = Dlsym(std::forward(handle), arg.sym); return HookSymNoHandle(original, arg); } inline static bool HookSymNoHandle(void *original, T \u0026arg) { if (original) { if constexpr(is_instance::value) { void *backup; HookFunction(original, reinterpret_cast(arg.replace), \u0026backup); arg.backup = reinterpret_cast(backup); } else { HookFunction(original, reinterpret_cast(arg.replace), reinterpret_cast(\u0026arg.backup)); } return true; } else { return false; } } inline int HookFunction(void *original, void *replace, void **backup) { _make_rwx(original, _page_size); if constexpr (isDebug) { Dl_info info; if (dladdr(original, \u0026info)) LOGD(\"Hooking %s (%p) from %s (%p)\", info.dli_sname ? info.dli_sname : \"(unknown symbol)\", info.dli_saddr, info.dli_fname ? info.dli_fname : \"(unknown file)\", info.dli_fbase); } return DobbyHook(original, replace, backup); } 这个版本的lsposed所使用到的inlinehook还是基于dobby hook来做的，而dob","date":"2023-08-06","objectID":"/maps%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/:0:3","series":null,"tags":["maps特征"],"title":"Maps特征检测对抗","uri":"/maps%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/#1-lsposed-maps特征"},{"categories":["特征检测对抗"],"content":" 三、maps特征上面大概了解了maps的形成以及展示过程后，结合hook框架中常暴露的特征来说下 1 lsposed maps特征目前手头上的项目是基于lsposed 1.6.0魔改的，因此以1.6.0的代码为例 // core/src/main/cpp/main/src/context.cpp void Context::OnNativeForkSystemServerPost(JNIEnv *env, jint res) { if (res != 0) return; if (!skip_) { LoadDex(env); Service::instance()-\u003eHookBridge(*this, env); auto binder = Service::instance()-\u003eRequestBinderForSystemServer(env); if (binder) { InstallInlineHooks(); Init(env); FindAndCall(env, \"forkSystemServerPost\", \"(Landroid/os/IBinder;)V\", binder); } else skip_ = true; } setAllowUnload(skip_); } void Context::OnNativeForkAndSpecializePost(JNIEnv *env) { const JUTFString process_name(env, nice_name_); auto binder = skip_ ? ScopedLocalRef{env, nullptr} : Service::instance()-\u003eRequestBinder(env, nice_name_); if (binder) { InstallInlineHooks(); LoadDex(env); Init(env); LOGD(\"Done prepare\"); FindAndCall(env, \"forkAndSpecializePost\", \"(Ljava/lang/String;Ljava/lang/String;Landroid/os/IBinder;)V\", app_data_dir_, nice_name_, binder); LOGD(\"injected xposed into %s\", process_name.get()); setAllowUnload(false); } else { auto context = Context::ReleaseInstance(); auto service = Service::ReleaseInstance(); art_img.reset(); LOGD(\"skipped %s\", process_name.get()); setAllowUnload(true); } } 在ForkSystemServerPost和ForkAndSpecializePost函数时会触发inlinehook的操作 void InstallInlineHooks() { if (installed.exchange(true)) [[unlikely]] { LOGD(\"Inline hooks have been installed, skip\"); return; } LOGD(\"Start to install inline hooks\"); const auto \u0026handle_libart = *art_img; if (!handle_libart.isValid()) { LOGE(\"Failed to fetch libart.so\"); } art::Runtime::Setup(handle_libart); art::hidden_api::DisableHiddenApi(handle_libart); art::art_method::Setup(handle_libart); art::Thread::Setup(handle_libart); art::ClassLinker::Setup(handle_libart); art::mirror::Class::Setup(handle_libart); art::JNIEnvExt::Setup(handle_libart); art::instrumentation::DisableUpdateHookedMethodsCode(handle_libart); art::thread_list::ScopedSuspendAll::Setup(handle_libart); art::gc::ScopedGCCriticalSection::Setup(handle_libart); art::jit::jit_code_cache::Setup(handle_libart); art_img.reset(); LOGD(\"Inline hooks installed\"); } 主要是对libart.so的修改，以art::instrumentation::DisableUpdateHookedMethodsCode(handle_libart);为例 // core/src/main/cpp/main/include/art/runtime/instrumentation.h namespace art { namespace instrumentation { CREATE_MEM_HOOK_STUB_ENTRIES( \"_ZN3art15instrumentation15Instrumentation21UpdateMethodsCodeImplEPNS_9ArtMethodEPKv\", void, UpdateMethodsCode, (void * thiz, void * art_method, const void *quick_code), { if (lspd::isHooked(art_method)) [[unlikely]] { LOGD(\"Skip update method code for hooked method %s\", art_method::PrettyMethod(art_method).c_str()); return; } else { backup(thiz, art_method, quick_code); } }); inline void DisableUpdateHookedMethodsCode(const SandHook::ElfImg \u0026handle) { lspd::HookSym(handle, UpdateMethodsCode); } } } // core/src/main/cpp/main/include/base/object.h inline static bool HookSym(H \u0026\u0026handle, T \u0026arg) { auto original = Dlsym(std::forward(handle), arg.sym); return HookSymNoHandle(original, arg); } inline static bool HookSymNoHandle(void *original, T \u0026arg) { if (original) { if constexpr(is_instance::value) { void *backup; HookFunction(original, reinterpret_cast(arg.replace), \u0026backup); arg.backup = reinterpret_cast(backup); } else { HookFunction(original, reinterpret_cast(arg.replace), reinterpret_cast(\u0026arg.backup)); } return true; } else { return false; } } inline int HookFunction(void *original, void *replace, void **backup) { _make_rwx(original, _page_size); if constexpr (isDebug) { Dl_info info; if (dladdr(original, \u0026info)) LOGD(\"Hooking %s (%p) from %s (%p)\", info.dli_sname ? info.dli_sname : \"(unknown symbol)\", info.dli_saddr, info.dli_fname ? info.dli_fname : \"(unknown file)\", info.dli_fbase); } return DobbyHook(original, replace, backup); } 这个版本的lsposed所使用到的inlinehook还是基于dobby hook来做的，而dob","date":"2023-08-06","objectID":"/maps%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/:0:3","series":null,"tags":["maps特征"],"title":"Maps特征检测对抗","uri":"/maps%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/#2-frida-maps特征"},{"categories":["特征检测对抗"],"content":" 四、对抗思路 复用riru_hide 具体流程可参考之前的文章-Riru原理理解，原理是将对应每个segment对应内存的数据替换，并去除文件关联 open重定向 例如内核层修改函数do_sys_open，返回指定伪装文件的fd来做展示，需要注意的是maps内容是随时变动的，那么伪装文件的生成也需要每次动态生成 内核层修改展示函数show_map_vma 代码可参考task_mmu.c，修改展示内容 ","date":"2023-08-06","objectID":"/maps%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/:0:4","series":null,"tags":["maps特征"],"title":"Maps特征检测对抗","uri":"/maps%E7%89%B9%E5%BE%81%E6%A3%80%E6%B5%8B%E5%AF%B9%E6%8A%97/#四对抗思路"},{"categories":["frida生态"],"content":" 一、背景参考项目strongR-frida对frida14.2.18进行魔改 ","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:1","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#一背景"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-\u003carch\u003e.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-\u003carch\u003e.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#二魔改点"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#1-0001-strongr-frida-string_frida_rpcpatch"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#原理"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#2-0002-strongr-frida-io_re_frida_serverpatch"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#原理-1"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#3-0003-strongr-frida-pipe_linjectorpatch"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#原理-2"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#4-0004-strongr-frida-io_frida_agent_sopatch"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#原理-3"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#5-0005-strongr-frida-symbol_frida_agent_mainpatch"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#原理-4"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#6-0006-strongr-frida-thread_gum_js_looppatch"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#原理-5"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#7-0007-strongr-frida-thread_gmainpatch"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#原理-6"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#8-0008-strongr-frida-protocol_unexpected_commandpatch"},{"categories":["frida生态"],"content":" 二、魔改点patch文件总共有八个，分别是对八个主要特征进行魔改，下面逐个分析下 1 0001-strongR-frida-string_frida_rpc.patch针对frida-core/lib/interfaces/session.vala文件，修改了frida:rpc字符串，使用了base64 decode来隐去字符串的特征 具体修改如下 // .add_string_value (\"frida:rpc\") .add_string_value ((string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) // if (raw_message.index_of (\"\\\"frida:rpc\\\"\") == -1) if (raw_message.index_of ((string) GLib.Base64.decode(\"ImZyaWRhOnJwYyI=\")) == -1) // if (type == null || type != \"frida:rpc\") if (type == null || type != (string) GLib.Base64.decode(\"ZnJpZGE6cnBj=\")) 原理应对内存特征的扫描，App会对关键代码的可读代码段进行扫描，而frida:rpc是很明显的字符串特征，因此对字符串做了一层base来隐藏 2 0002-strongR-frida-io_re_frida_server.patch // private const string DEFAULT_DIRECTORY = \"re.frida.server\"; private static string DEFAULT_DIRECTORY = null; private static int main (string[] args) { DEFAULT_DIRECTORY = GLib.Uuid.string_random(); Environment.init (); 原理re.frida.server是frida在启动时会创建的目录，里面有包括frida-agent等关键so，这些会在App的maps里面被检测到 3 0003-strongR-frida-pipe_linjector.patch // self-\u003efifo_path = g_strdup_printf (\"%s/linjector-%u\", self-\u003etemp_path, self-\u003eid); self-\u003efifo_path = g_strdup_printf (\"%s/%p%u\", self-\u003etemp_path, self ,self-\u003eid); 原理linjector是linux上提供注入能力的工具，当frida注入进程时，可以在App的/proc/self/fd看到某个fd的软链是指向frida目录的linjector的 4 0004-strongR-frida-io_frida_agent_so.patch // agent = new AgentDescriptor (PathTemplate (\"frida-agent-.so\"), var random_prefix = GLib.Uuid.string_random(); agent = new AgentDescriptor (PathTemplate (random_prefix + \"-.so\"), // new AgentResource (\"frida-agent-arm.so\", new Bytes.static (emulated_arm.data), tempdir), // new AgentResource (\"frida-agent-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), new AgentResource (random_prefix + \"-arm.so\", new Bytes.static (emulated_arm.data), tempdir), new AgentResource (random_prefix + \"-arm64.so\", new Bytes.static (emulated_arm64.data), tempdir), 原理和第二个是相同的，都是在maps中存在的特征 5 0005-strongR-frida-symbol_frida_agent_main.patch针对frida-agent特征进行隐藏 // frida-core/src/agent-container.vala // var main_func_found = container.module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = container.module.symbol (\"main\", out main_func_symbol); // frida-core/src/darwin/darwin-host-session.vala // unowned string entrypoint = \"frida_agent_main\"; unowned string entrypoint = \"main\"; // frida-core/tests/test-injector.vala // yield injector.inject_library_file (process.id, path, \"frida_agent_main\", data); yield injector.inject_library_file (process.id, path, \"main\", data); // frida-core/tests/test-agent.vala // var main_func_found = module.symbol (\"frida_agent_main\", out main_func_symbol); var main_func_found = module.symbol (\"main\", out main_func_symbol); // frida-core/src/linux/linux-host-session.vala // string entrypoint = \"frida_agent_main\"; string entrypoint = \"main\"; // frida-core/src/windows/windows-host-session.vala // var id = yield winjector.inject_library_resource (pid, agent, \"frida_agent_main\", t.remote_address, cancellable); var id = yield winjector.inject_library_resource (pid, agent, \"main\", t.remote_address, cancellable); // frida-core/src/qnx/qnx-host-session.vala // var id = yield qinjector.inject_library_resource (pid, agent_desc, \"frida_agent_main\", t.remote_address, // cancellable); var id = yield qinjector.inject_library_resource (pid, agent_desc, \"main\", t.remote_address, cancellable); 原理定位所有frida_agent_main进行隐藏 6 0006-strongR-frida-thread_gum_js_loop.patch无 原理 7 0007-strongR-frida-thread_gmain.patch无 原理 8 0008-strongR-frida-protocol_unexpected_command.patch case \"OPEN\": case \"CLSE\": case \"WRTE\": // throw new Error.PROTOCOL (\"Unexpected command\"); break; //throw new Error.PROTOCOL (\"Unexpected command\"); 原理","date":"2023-08-01","objectID":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/:0:2","series":null,"tags":["frida特征魔改"],"title":"StrongR Frid特征魔改","uri":"/strongr-frid%E7%89%B9%E5%BE%81%E9%AD%94%E6%94%B9/#原理-7"},{"categories":["系统定制"],"content":" 一、编译环境搭建 1 物料准备 设备：红米note11（MIUI12 Android11） 原生super.img镜像文件，参考下载网站 2 工具准备 编译支撑系统：ubuntu14（经测试不受版本影响，正常来说ubuntu都可以安装所有的工具） simg2img lpunpack/lmake imjtool ","date":"2023-07-31","objectID":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/:0:1","series":null,"tags":["super分区定制"],"title":"Super分区定制","uri":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/#一编译环境搭建"},{"categories":["系统定制"],"content":" 一、编译环境搭建 1 物料准备 设备：红米note11（MIUI12 Android11） 原生super.img镜像文件，参考下载网站 2 工具准备 编译支撑系统：ubuntu14（经测试不受版本影响，正常来说ubuntu都可以安装所有的工具） simg2img lpunpack/lmake imjtool ","date":"2023-07-31","objectID":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/:0:1","series":null,"tags":["super分区定制"],"title":"Super分区定制","uri":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/#1-物料准备"},{"categories":["系统定制"],"content":" 一、编译环境搭建 1 物料准备 设备：红米note11（MIUI12 Android11） 原生super.img镜像文件，参考下载网站 2 工具准备 编译支撑系统：ubuntu14（经测试不受版本影响，正常来说ubuntu都可以安装所有的工具） simg2img lpunpack/lmake imjtool ","date":"2023-07-31","objectID":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/:0:1","series":null,"tags":["super分区定制"],"title":"Super分区定制","uri":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/#2-工具准备"},{"categories":["系统定制"],"content":" 二、案例说明（内置应用） 1 镜像格式转化正常image镜像都是Android sparse image格式的 (base) 大慈大悲观世音菩萨  ~/Projects/小米rom/原生12511/images  file super.img super.img: Android sparse image, version: 1.0, Total of 2197864 4096-byte output blocks in 4352 input chunks. 但是要挂载使用的话需要转换成data格式，利用到simg2img super.img super.raw.img命令，得到的文件如下 (base) 大慈大悲观世音菩萨  ~/tt  file super.img.raw super.img.raw: data 2 镜像拆解Android10以上的设备通常都是动态分区，也就是system、vendor、product等逻辑分区合并成一个物理分区，可以使用imjtool来看当前镜像的具体信息 (base) 大慈大悲观世音菩萨  ~/tt  imjtool super.img.raw MMapped: 0x1103a2000, imgMeta 0x1103a3000 liblp dynamic partition (super.img) - Blocksize 0x1000, 3 slots LP MD Header @0x3000, version 10.2, with 6 logical partitions @0x0 on block device of 8704 GB, at partition super, first sector: 0x800 Partitions @0x3100 in 3 groups: Group 0: default Group 1: main_a Name: product_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0x100000 spanning 1 extents of 237 MB) Name: vendor_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0xef00000 spanning 1 extents of 869 MB) Name: system_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0x45500000 spanning 1 extents of 4 GB) Group 2: main_b Name: product_b (read-only, empty) Name: vendor_b (read-only, empty) Name: system_b (read-only, Linux Ext2/3/4/? Filesystem Image, @0x161200000 spanning 1 extents of 345 MB) 默认镜像中存在三个槽，但实际上可用的只是两个槽，负责用来做AB分区转换的，但是小米使用的应该是VAB分区，B分区其实只是个假分区，通常都是空的 因此想要动其中的分区需要额外进行一步镜像拆解，需要利用到lpunpack工具，执行命令 lpunpack super.img.raw super/ 得到的拆解后的文件如下 (base) 大慈大悲观世音菩萨  ~/tt/super  ll total 15558584 -rw-r--r-- 1 linhanqiu staff 237M 4 24 16:35 product_a.img -rw-r--r-- 1 linhanqiu staff 0B 4 24 16:36 product_b.img drwxr-xr-x 2 linhanqiu staff 64B 4 24 16:39 sys1 -rw-r--r-- 1 linhanqiu staff 6.0G 5 8 18:13 system_a.img -rw-r--r-- 1 linhanqiu staff 346M 4 24 16:29 system_b.img -rw-r--r-- 1 linhanqiu staff 870M 4 24 16:36 vendor_a.img -rw-r--r-- 1 linhanqiu staff 0B 4 24 16:35 vendor_b.img 3 定制修改修改的是system_a.img镜像，需要mount到指定目录上，但现在system_a.img的空间是满的，需要额外扩充空间保证我们的修改和新增生效，有的Linux系统可以直接使用fallocate命令，但是ubuntu不可以，替换成 dd if=system_a.img of=system_a.img bs=1G seek=7 count=0 resize2fs system_a.img 7G 原本的system_a.img是5G，现在额外扩展到7G mount -t ext4 -o loop system_a.img system 挂载到system目录上，可得到以下文件列表，根据自身需求修改即可 4 镜像重打包针对system目录修改完成后，取消挂载 umount system 利用lpmake工具打包，具体的值需要计算 lpmake --metadata-size 65536 --device super:9002450944 --metadata-slots 3 --group main_a:7603306496 --partition product_a:none:248659968:main_a --partition system_a:none:6442450944:main_a --partition vendor_a:none:912195584:main_a --image product_a=./product_a.img --image system_a=./system_a.img --image vendor_a=./vendor_a.img --group main_b:362688512 --partition system_b:none:362688512:main_b --image system_b=./system_b.img --sparse --output ./super.new.img ","date":"2023-07-31","objectID":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/:0:2","series":null,"tags":["super分区定制"],"title":"Super分区定制","uri":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/#二案例说明内置应用"},{"categories":["系统定制"],"content":" 二、案例说明（内置应用） 1 镜像格式转化正常image镜像都是Android sparse image格式的 (base) 大慈大悲观世音菩萨  ~/Projects/小米rom/原生12511/images  file super.img super.img: Android sparse image, version: 1.0, Total of 2197864 4096-byte output blocks in 4352 input chunks. 但是要挂载使用的话需要转换成data格式，利用到simg2img super.img super.raw.img命令，得到的文件如下 (base) 大慈大悲观世音菩萨  ~/tt  file super.img.raw super.img.raw: data 2 镜像拆解Android10以上的设备通常都是动态分区，也就是system、vendor、product等逻辑分区合并成一个物理分区，可以使用imjtool来看当前镜像的具体信息 (base) 大慈大悲观世音菩萨  ~/tt  imjtool super.img.raw MMapped: 0x1103a2000, imgMeta 0x1103a3000 liblp dynamic partition (super.img) - Blocksize 0x1000, 3 slots LP MD Header @0x3000, version 10.2, with 6 logical partitions @0x0 on block device of 8704 GB, at partition super, first sector: 0x800 Partitions @0x3100 in 3 groups: Group 0: default Group 1: main_a Name: product_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0x100000 spanning 1 extents of 237 MB) Name: vendor_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0xef00000 spanning 1 extents of 869 MB) Name: system_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0x45500000 spanning 1 extents of 4 GB) Group 2: main_b Name: product_b (read-only, empty) Name: vendor_b (read-only, empty) Name: system_b (read-only, Linux Ext2/3/4/? Filesystem Image, @0x161200000 spanning 1 extents of 345 MB) 默认镜像中存在三个槽，但实际上可用的只是两个槽，负责用来做AB分区转换的，但是小米使用的应该是VAB分区，B分区其实只是个假分区，通常都是空的 因此想要动其中的分区需要额外进行一步镜像拆解，需要利用到lpunpack工具，执行命令 lpunpack super.img.raw super/ 得到的拆解后的文件如下 (base) 大慈大悲观世音菩萨  ~/tt/super  ll total 15558584 -rw-r--r-- 1 linhanqiu staff 237M 4 24 16:35 product_a.img -rw-r--r-- 1 linhanqiu staff 0B 4 24 16:36 product_b.img drwxr-xr-x 2 linhanqiu staff 64B 4 24 16:39 sys1 -rw-r--r-- 1 linhanqiu staff 6.0G 5 8 18:13 system_a.img -rw-r--r-- 1 linhanqiu staff 346M 4 24 16:29 system_b.img -rw-r--r-- 1 linhanqiu staff 870M 4 24 16:36 vendor_a.img -rw-r--r-- 1 linhanqiu staff 0B 4 24 16:35 vendor_b.img 3 定制修改修改的是system_a.img镜像，需要mount到指定目录上，但现在system_a.img的空间是满的，需要额外扩充空间保证我们的修改和新增生效，有的Linux系统可以直接使用fallocate命令，但是ubuntu不可以，替换成 dd if=system_a.img of=system_a.img bs=1G seek=7 count=0 resize2fs system_a.img 7G 原本的system_a.img是5G，现在额外扩展到7G mount -t ext4 -o loop system_a.img system 挂载到system目录上，可得到以下文件列表，根据自身需求修改即可 4 镜像重打包针对system目录修改完成后，取消挂载 umount system 利用lpmake工具打包，具体的值需要计算 lpmake --metadata-size 65536 --device super:9002450944 --metadata-slots 3 --group main_a:7603306496 --partition product_a:none:248659968:main_a --partition system_a:none:6442450944:main_a --partition vendor_a:none:912195584:main_a --image product_a=./product_a.img --image system_a=./system_a.img --image vendor_a=./vendor_a.img --group main_b:362688512 --partition system_b:none:362688512:main_b --image system_b=./system_b.img --sparse --output ./super.new.img ","date":"2023-07-31","objectID":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/:0:2","series":null,"tags":["super分区定制"],"title":"Super分区定制","uri":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/#1-镜像格式转化"},{"categories":["系统定制"],"content":" 二、案例说明（内置应用） 1 镜像格式转化正常image镜像都是Android sparse image格式的 (base) 大慈大悲观世音菩萨  ~/Projects/小米rom/原生12511/images  file super.img super.img: Android sparse image, version: 1.0, Total of 2197864 4096-byte output blocks in 4352 input chunks. 但是要挂载使用的话需要转换成data格式，利用到simg2img super.img super.raw.img命令，得到的文件如下 (base) 大慈大悲观世音菩萨  ~/tt  file super.img.raw super.img.raw: data 2 镜像拆解Android10以上的设备通常都是动态分区，也就是system、vendor、product等逻辑分区合并成一个物理分区，可以使用imjtool来看当前镜像的具体信息 (base) 大慈大悲观世音菩萨  ~/tt  imjtool super.img.raw MMapped: 0x1103a2000, imgMeta 0x1103a3000 liblp dynamic partition (super.img) - Blocksize 0x1000, 3 slots LP MD Header @0x3000, version 10.2, with 6 logical partitions @0x0 on block device of 8704 GB, at partition super, first sector: 0x800 Partitions @0x3100 in 3 groups: Group 0: default Group 1: main_a Name: product_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0x100000 spanning 1 extents of 237 MB) Name: vendor_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0xef00000 spanning 1 extents of 869 MB) Name: system_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0x45500000 spanning 1 extents of 4 GB) Group 2: main_b Name: product_b (read-only, empty) Name: vendor_b (read-only, empty) Name: system_b (read-only, Linux Ext2/3/4/? Filesystem Image, @0x161200000 spanning 1 extents of 345 MB) 默认镜像中存在三个槽，但实际上可用的只是两个槽，负责用来做AB分区转换的，但是小米使用的应该是VAB分区，B分区其实只是个假分区，通常都是空的 因此想要动其中的分区需要额外进行一步镜像拆解，需要利用到lpunpack工具，执行命令 lpunpack super.img.raw super/ 得到的拆解后的文件如下 (base) 大慈大悲观世音菩萨  ~/tt/super  ll total 15558584 -rw-r--r-- 1 linhanqiu staff 237M 4 24 16:35 product_a.img -rw-r--r-- 1 linhanqiu staff 0B 4 24 16:36 product_b.img drwxr-xr-x 2 linhanqiu staff 64B 4 24 16:39 sys1 -rw-r--r-- 1 linhanqiu staff 6.0G 5 8 18:13 system_a.img -rw-r--r-- 1 linhanqiu staff 346M 4 24 16:29 system_b.img -rw-r--r-- 1 linhanqiu staff 870M 4 24 16:36 vendor_a.img -rw-r--r-- 1 linhanqiu staff 0B 4 24 16:35 vendor_b.img 3 定制修改修改的是system_a.img镜像，需要mount到指定目录上，但现在system_a.img的空间是满的，需要额外扩充空间保证我们的修改和新增生效，有的Linux系统可以直接使用fallocate命令，但是ubuntu不可以，替换成 dd if=system_a.img of=system_a.img bs=1G seek=7 count=0 resize2fs system_a.img 7G 原本的system_a.img是5G，现在额外扩展到7G mount -t ext4 -o loop system_a.img system 挂载到system目录上，可得到以下文件列表，根据自身需求修改即可 4 镜像重打包针对system目录修改完成后，取消挂载 umount system 利用lpmake工具打包，具体的值需要计算 lpmake --metadata-size 65536 --device super:9002450944 --metadata-slots 3 --group main_a:7603306496 --partition product_a:none:248659968:main_a --partition system_a:none:6442450944:main_a --partition vendor_a:none:912195584:main_a --image product_a=./product_a.img --image system_a=./system_a.img --image vendor_a=./vendor_a.img --group main_b:362688512 --partition system_b:none:362688512:main_b --image system_b=./system_b.img --sparse --output ./super.new.img ","date":"2023-07-31","objectID":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/:0:2","series":null,"tags":["super分区定制"],"title":"Super分区定制","uri":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/#2-镜像拆解"},{"categories":["系统定制"],"content":" 二、案例说明（内置应用） 1 镜像格式转化正常image镜像都是Android sparse image格式的 (base) 大慈大悲观世音菩萨  ~/Projects/小米rom/原生12511/images  file super.img super.img: Android sparse image, version: 1.0, Total of 2197864 4096-byte output blocks in 4352 input chunks. 但是要挂载使用的话需要转换成data格式，利用到simg2img super.img super.raw.img命令，得到的文件如下 (base) 大慈大悲观世音菩萨  ~/tt  file super.img.raw super.img.raw: data 2 镜像拆解Android10以上的设备通常都是动态分区，也就是system、vendor、product等逻辑分区合并成一个物理分区，可以使用imjtool来看当前镜像的具体信息 (base) 大慈大悲观世音菩萨  ~/tt  imjtool super.img.raw MMapped: 0x1103a2000, imgMeta 0x1103a3000 liblp dynamic partition (super.img) - Blocksize 0x1000, 3 slots LP MD Header @0x3000, version 10.2, with 6 logical partitions @0x0 on block device of 8704 GB, at partition super, first sector: 0x800 Partitions @0x3100 in 3 groups: Group 0: default Group 1: main_a Name: product_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0x100000 spanning 1 extents of 237 MB) Name: vendor_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0xef00000 spanning 1 extents of 869 MB) Name: system_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0x45500000 spanning 1 extents of 4 GB) Group 2: main_b Name: product_b (read-only, empty) Name: vendor_b (read-only, empty) Name: system_b (read-only, Linux Ext2/3/4/? Filesystem Image, @0x161200000 spanning 1 extents of 345 MB) 默认镜像中存在三个槽，但实际上可用的只是两个槽，负责用来做AB分区转换的，但是小米使用的应该是VAB分区，B分区其实只是个假分区，通常都是空的 因此想要动其中的分区需要额外进行一步镜像拆解，需要利用到lpunpack工具，执行命令 lpunpack super.img.raw super/ 得到的拆解后的文件如下 (base) 大慈大悲观世音菩萨  ~/tt/super  ll total 15558584 -rw-r--r-- 1 linhanqiu staff 237M 4 24 16:35 product_a.img -rw-r--r-- 1 linhanqiu staff 0B 4 24 16:36 product_b.img drwxr-xr-x 2 linhanqiu staff 64B 4 24 16:39 sys1 -rw-r--r-- 1 linhanqiu staff 6.0G 5 8 18:13 system_a.img -rw-r--r-- 1 linhanqiu staff 346M 4 24 16:29 system_b.img -rw-r--r-- 1 linhanqiu staff 870M 4 24 16:36 vendor_a.img -rw-r--r-- 1 linhanqiu staff 0B 4 24 16:35 vendor_b.img 3 定制修改修改的是system_a.img镜像，需要mount到指定目录上，但现在system_a.img的空间是满的，需要额外扩充空间保证我们的修改和新增生效，有的Linux系统可以直接使用fallocate命令，但是ubuntu不可以，替换成 dd if=system_a.img of=system_a.img bs=1G seek=7 count=0 resize2fs system_a.img 7G 原本的system_a.img是5G，现在额外扩展到7G mount -t ext4 -o loop system_a.img system 挂载到system目录上，可得到以下文件列表，根据自身需求修改即可 4 镜像重打包针对system目录修改完成后，取消挂载 umount system 利用lpmake工具打包，具体的值需要计算 lpmake --metadata-size 65536 --device super:9002450944 --metadata-slots 3 --group main_a:7603306496 --partition product_a:none:248659968:main_a --partition system_a:none:6442450944:main_a --partition vendor_a:none:912195584:main_a --image product_a=./product_a.img --image system_a=./system_a.img --image vendor_a=./vendor_a.img --group main_b:362688512 --partition system_b:none:362688512:main_b --image system_b=./system_b.img --sparse --output ./super.new.img ","date":"2023-07-31","objectID":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/:0:2","series":null,"tags":["super分区定制"],"title":"Super分区定制","uri":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/#3-定制修改"},{"categories":["系统定制"],"content":" 二、案例说明（内置应用） 1 镜像格式转化正常image镜像都是Android sparse image格式的 (base) 大慈大悲观世音菩萨  ~/Projects/小米rom/原生12511/images  file super.img super.img: Android sparse image, version: 1.0, Total of 2197864 4096-byte output blocks in 4352 input chunks. 但是要挂载使用的话需要转换成data格式，利用到simg2img super.img super.raw.img命令，得到的文件如下 (base) 大慈大悲观世音菩萨  ~/tt  file super.img.raw super.img.raw: data 2 镜像拆解Android10以上的设备通常都是动态分区，也就是system、vendor、product等逻辑分区合并成一个物理分区，可以使用imjtool来看当前镜像的具体信息 (base) 大慈大悲观世音菩萨  ~/tt  imjtool super.img.raw MMapped: 0x1103a2000, imgMeta 0x1103a3000 liblp dynamic partition (super.img) - Blocksize 0x1000, 3 slots LP MD Header @0x3000, version 10.2, with 6 logical partitions @0x0 on block device of 8704 GB, at partition super, first sector: 0x800 Partitions @0x3100 in 3 groups: Group 0: default Group 1: main_a Name: product_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0x100000 spanning 1 extents of 237 MB) Name: vendor_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0xef00000 spanning 1 extents of 869 MB) Name: system_a (read-only, Linux Ext2/3/4/? Filesystem Image, @0x45500000 spanning 1 extents of 4 GB) Group 2: main_b Name: product_b (read-only, empty) Name: vendor_b (read-only, empty) Name: system_b (read-only, Linux Ext2/3/4/? Filesystem Image, @0x161200000 spanning 1 extents of 345 MB) 默认镜像中存在三个槽，但实际上可用的只是两个槽，负责用来做AB分区转换的，但是小米使用的应该是VAB分区，B分区其实只是个假分区，通常都是空的 因此想要动其中的分区需要额外进行一步镜像拆解，需要利用到lpunpack工具，执行命令 lpunpack super.img.raw super/ 得到的拆解后的文件如下 (base) 大慈大悲观世音菩萨  ~/tt/super  ll total 15558584 -rw-r--r-- 1 linhanqiu staff 237M 4 24 16:35 product_a.img -rw-r--r-- 1 linhanqiu staff 0B 4 24 16:36 product_b.img drwxr-xr-x 2 linhanqiu staff 64B 4 24 16:39 sys1 -rw-r--r-- 1 linhanqiu staff 6.0G 5 8 18:13 system_a.img -rw-r--r-- 1 linhanqiu staff 346M 4 24 16:29 system_b.img -rw-r--r-- 1 linhanqiu staff 870M 4 24 16:36 vendor_a.img -rw-r--r-- 1 linhanqiu staff 0B 4 24 16:35 vendor_b.img 3 定制修改修改的是system_a.img镜像，需要mount到指定目录上，但现在system_a.img的空间是满的，需要额外扩充空间保证我们的修改和新增生效，有的Linux系统可以直接使用fallocate命令，但是ubuntu不可以，替换成 dd if=system_a.img of=system_a.img bs=1G seek=7 count=0 resize2fs system_a.img 7G 原本的system_a.img是5G，现在额外扩展到7G mount -t ext4 -o loop system_a.img system 挂载到system目录上，可得到以下文件列表，根据自身需求修改即可 4 镜像重打包针对system目录修改完成后，取消挂载 umount system 利用lpmake工具打包，具体的值需要计算 lpmake --metadata-size 65536 --device super:9002450944 --metadata-slots 3 --group main_a:7603306496 --partition product_a:none:248659968:main_a --partition system_a:none:6442450944:main_a --partition vendor_a:none:912195584:main_a --image product_a=./product_a.img --image system_a=./system_a.img --image vendor_a=./vendor_a.img --group main_b:362688512 --partition system_b:none:362688512:main_b --image system_b=./system_b.img --sparse --output ./super.new.img ","date":"2023-07-31","objectID":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/:0:2","series":null,"tags":["super分区定制"],"title":"Super分区定制","uri":"/super%E5%88%86%E5%8C%BA%E5%AE%9A%E5%88%B6/#4-镜像重打包"},{"categories":["riru"],"content":" 一、前言什么是riru？正如它Github上面所提到的那样，它提供的能力是允许模块能够将自己的代码注入到各个App进程或者是system_server进程中，而这一切的实现就是基于它对于zygote进程的注入。 那具体是怎么对于zygote进行注入的呢？文档中也提到，在早期的版本中，riru通过替换libmemtrack.so这个系统库的方式，原因是一方面zygote会加载该系统库，另一方面则是因为这个库足够小，仅仅只有十个函数，也就意味着替换掉它所造成的影响面是很小的，但是后续来看，由于使用到这个so的进程比较多，除了zygote还有SurfaceFlinger（用于显示系统）、mediaserver（用于媒体处理）等等，因此会造成一些意想不到的错误。 因此在v22，riru使用了一个新的注入方式，设置native bridge，也就是指定ro.dalvik.vm.native.bridge的值为riri的so来实现注入，这个思路是来源于canyie的一篇文章通过系统的native bridge实现注入zygote，它的原理大概是 void AndroidRuntime::start(const char* className, const Vector\u003cString8\u003e\u0026 options, bool zygote) { ALOGD(\"\u003e\u003e\u003e\u003e\u003e\u003e START %s uid %d \u003c\u003c\u003c\u003c\u003c\u003c\\n\", className != NULL ? className : \"(unknown)\", getuid()); /* start the virtual machine */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; // 启动虚拟机 if (startVm(\u0026mJavaVM, \u0026env, zygote, primary_zygote) != 0) { return; } onVmCreated(env); } int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote, bool primary_zygote) { JavaVMInitArgs initArgs; // ... // Native bridge library. \"0\" means that native bridge is disabled. // // Note: bridging is only enabled for the zygote. Other runs of // app_process may not have the permissions to mount etc. // 读取ro.dalvik.vm.native.bridge属性 property_get(\"ro.dalvik.vm.native.bridge\", propBuf, \"\"); if (propBuf[0] == '\\0') { ALOGW(\"ro.dalvik.vm.native.bridge is not expected to be empty\"); } else if (zygote \u0026\u0026 strcmp(propBuf, \"0\") != 0) { snprintf(nativeBridgeLibrary, sizeof(\"-XX:NativeBridge=\") + PROPERTY_VALUE_MAX, \"-XX:NativeBridge=%s\", propBuf); addOption(nativeBridgeLibrary); } // ... initArgs.version = JNI_VERSION_1_4; initArgs.options = mOptions.editArray(); initArgs.nOptions = mOptions.size(); initArgs.ignoreUnrecognized = JNI_FALSE; /* * Initialize the VM. * * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread. * If this call succeeds, the VM is ready, and we can start issuing * JNI calls. */ if (JNI_CreateJavaVM(pJavaVM, pEnv, \u0026initArgs) \u003c 0) { ALOGE(\"JNI_CreateJavaVM failed\\n\"); return -1; } return 0; } bool Runtime::Init(RuntimeArgumentMap\u0026\u0026 runtime_options_in) { // ... // Look for a native bridge. // // The intended flow here is, in the case of a running system: // // Runtime::Init() (zygote): // LoadNativeBridge -\u003e dlopen from cmd line parameter. // | // V // Runtime::Start() (zygote): // No-op wrt native bridge. // | // | start app // V // DidForkFromZygote(action) // action = kUnload -\u003e dlclose native bridge. // action = kInitialize -\u003e initialize library // // // The intended flow here is, in the case of a simple dalvikvm call: // // Runtime::Init(): // LoadNativeBridge -\u003e dlopen from cmd line parameter. // | // V // Runtime::Start(): // DidForkFromZygote(kInitialize) -\u003e try to initialize any native bridge given. // No-op wrt native bridge. { std::string native_bridge_file_name = runtime_options.ReleaseOrDefault(Opt::NativeBridge); // 加载native bridge is_native_bridge_loaded_ = LoadNativeBridge(native_bridge_file_name); } // ... } bool LoadNativeBridge(const char* nb_library_filename, const NativeBridgeRuntimeCallbacks* runtime_cbs) { // We expect only one place that calls LoadNativeBridge: Runtime::Init. At that point we are not // multi-threaded, so we do not need locking here. if (nb_library_filename == nullptr || *nb_library_filename == 0) { CloseNativeBridge(false); return false; } else { if (!NativeBridgeNameAcceptable(nb_library_filename)) { CloseNativeBridge(true); } else { // Try to open the library. // 调用dlopen打开指定so void* handle = dlopen(nb_library_filename, RTLD_LAZY); if (handle != nullptr) { callbacks = reinterpret_cast\u003cNativeBridgeCallbacks*\u003e(dlsym(handle, kNativeBridgeInterfaceSymbol)); if (callbacks != nullptr) { if (isCompatibleWith(NAMESPACE_VERSION)) { // Store the handle for later. native_bridge_handle = handle; } else { callbacks = nullptr; dlclose(handle); ALOGW(\"Unsupported native bridge interface.\"); } } else { dlclose(handle); } } // Two failure conditions: could not find library (dlopen failed), or could ","date":"2023-07-25","objectID":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/:0:1","series":null,"tags":["riru原理"],"title":"Riru原理理解","uri":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/#一前言"},{"categories":["riru"],"content":" 二、实现细节 1 riru结构先从riru的项目结构入手，riru是个Magisk模块，自然是以Magisk模块模板为基础，首先来看看Magisk模块模板都具备哪些 参考开发者文档，Magisk模块都会放在/data/adb/modules目录下，结构如 /data/adb/modules ├── . ├── . | ├── $MODID 模块名称 \u003c--- The folder is named with the ID of the module │ │ │ │ *** Module Identity *** │ │ │ ├── module.prop 模块的基础信息 \u003c--- This file stores the metadata of the module │ │ │ │ *** Main Contents *** │ │ │ ├── system 挂载到system目录 \u003c--- This folder will be mounted if skip_mount does not exist │ │ ├── ... │ │ ├── ... │ │ └── ... │ │ │ ├── zygisk \u003c--- This folder contains the module's Zygisk native libraries │ │ ├── arm64-v8a.so │ │ ├── armeabi-v7a.so │ │ ├── x86.so │ │ ├── x86_64.so │ │ └── unloaded \u003c--- If exists, the native libraries are incompatible │ │ │ │ *** Status Flags *** │ │ │ ├── skip_mount \u003c--- If exists, Magisk will NOT mount your system folder │ ├── disable \u003c--- If exists, the module will be disabled │ ├── remove \u003c--- If exists, the module will be removed next reboot │ │ │ │ *** Optional Files *** │ │ │ ├── post-fs-data.sh 定制脚本 \u003c--- This script will be executed in post-fs-data │ ├── service.sh \u003c--- This script will be executed in late_start service | ├── uninstall.sh \u003c--- This script will be executed when Magisk removes your module │ ├── system.prop 系统属性修改 \u003c--- Properties in this file will be loaded as system properties by resetprop │ ├── sepolicy.rule sepolicy规则修改 \u003c--- Additional custom sepolicy rules │ │ │ │ *** Auto Generated, DO NOT MANUALLY CREATE OR MODIFY *** │ │ │ ├── vendor \u003c--- A symlink to $MODID/system/vendor │ ├── product \u003c--- A symlink to $MODID/system/product │ ├── system_ext \u003c--- A symlink to $MODID/system/system_ext │ │ │ │ *** Any additional files / folders are allowed *** │ │ │ ├── ... │ └── ... | ├── another_module │ ├── . │ └── . ├── . ├── . 再看看模块的安装过程 module.zip │ ├── META-INF │ └── com │ └── google │ └── android │ ├── update-binary \u003c--- The module_installer.sh you downloaded │ └── updater-script \u003c--- Should only contain the string \"#MAGISK\" │ ├── customize.sh \u003c--- (Optional, more details later) │ This script will be sourced by update-binary ├── ... ├── ... /* The rest of module's files */ customize.sh和update-binary是互相配合来完成安装过程中定制的部分 具体看看riru修改了 module.prop id=${id} name=${name} version=${version} versionCode=${versionCode} author=${author} description=${description} riruApi=${riruApi} riruMinApi=${riruMinApi} 设置全局变量 post-fs-data #!/system/bin/sh MODDIR=${0%/*} TMPPROP=\"$(magisk --path)/riru.prop\" MIRRORPROP=\"$(magisk --path)/.magisk/modules/riru-core/module.prop\" sh -Cc \"cat '$MODDIR/module.prop' \u003e '$TMPPROP'\" if [ $? -ne 0 ]; then exit fi mount --bind \"$TMPPROP\" \"$MIRRORPROP\" if [ \"$ZYGISK_ENABLE\" = \"1\" ]; then sed -Ei 's/^description=(\\[.*][[:space:]]*)?/description=[ ⛔ Riru is not loaded because of Zygisk. ] /g' \"$MIRRORPROP\" exit fi sed -Ei 's/^description=(\\[.*][[:space:]]*)?/description=[ ⛔ app_process fails to run. ] /g' \"$MIRRORPROP\" cd \"$MODDIR\" || exit flock \"module.prop\" mount --bind \"$TMPPROP\" \"$MODDIR/module.prop\" unshare -m sh -c \"/system/bin/app_process -Djava.class.path=rirud.apk /system/bin --nice-name=rirud riru.Daemon $(magisk -V) $(magisk --path) $(getprop ro.dalvik.vm.native.bridge)\u0026\" umount \"$MODDIR/module.prop\" 主要在于使用unshare资源隔离的方式启动rirud的守护进程，和magiskd类似，都是在post-fs-data阶段启动的 system.prop ro.dalvik.vm.native.bridge=libriruloader.so 最关键的修改，修改了ro.dalvik.vm.native.bridge属性指向libriruloader.so customize // template/magisk_module/customize.sh // 文件解压 if [ \"$ARCH\" = \"x86\" ] || [ \"$ARCH\" = \"x64\" ]; then ui_print \"- Extracting x86 libraries\" extract \"$ZIPFILE\" 'lib/x86/libriru.so' \"$MODPATH/lib\" true extract \"$ZIPFILE\" 'lib/x86/libriruhide.so' \"$MODPATH/lib\" true extract \"$ZIPFILE\" 'lib/x86/libriruloader.so' \"$MODPATH/system/lib\" true if [ \"$IS64BIT\" = true ]; then ui_print \"- Extracting x64 libraries\" extract \"$ZIPFILE\" 'lib/x86_64/libriru.so' \"$MODPATH/lib64\" true extract \"$ZIPFILE\" 'lib/x86_64/libriruhide.so' \"$MODPATH/lib64\" true extract \"$ZIPFILE\" 'lib/x86_64/libriruloader.so' \"$MODPATH/system/lib64\" true fi else","date":"2023-07-25","objectID":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/:0:2","series":null,"tags":["riru原理"],"title":"Riru原理理解","uri":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/#二实现细节"},{"categories":["riru"],"content":" 二、实现细节 1 riru结构先从riru的项目结构入手，riru是个Magisk模块，自然是以Magisk模块模板为基础，首先来看看Magisk模块模板都具备哪些 参考开发者文档，Magisk模块都会放在/data/adb/modules目录下，结构如 /data/adb/modules ├── . ├── . | ├── $MODID 模块名称 \u003c--- The folder is named with the ID of the module │ │ │ │ *** Module Identity *** │ │ │ ├── module.prop 模块的基础信息 \u003c--- This file stores the metadata of the module │ │ │ │ *** Main Contents *** │ │ │ ├── system 挂载到system目录 \u003c--- This folder will be mounted if skip_mount does not exist │ │ ├── ... │ │ ├── ... │ │ └── ... │ │ │ ├── zygisk \u003c--- This folder contains the module's Zygisk native libraries │ │ ├── arm64-v8a.so │ │ ├── armeabi-v7a.so │ │ ├── x86.so │ │ ├── x86_64.so │ │ └── unloaded \u003c--- If exists, the native libraries are incompatible │ │ │ │ *** Status Flags *** │ │ │ ├── skip_mount \u003c--- If exists, Magisk will NOT mount your system folder │ ├── disable \u003c--- If exists, the module will be disabled │ ├── remove \u003c--- If exists, the module will be removed next reboot │ │ │ │ *** Optional Files *** │ │ │ ├── post-fs-data.sh 定制脚本 \u003c--- This script will be executed in post-fs-data │ ├── service.sh \u003c--- This script will be executed in late_start service | ├── uninstall.sh \u003c--- This script will be executed when Magisk removes your module │ ├── system.prop 系统属性修改 \u003c--- Properties in this file will be loaded as system properties by resetprop │ ├── sepolicy.rule sepolicy规则修改 \u003c--- Additional custom sepolicy rules │ │ │ │ *** Auto Generated, DO NOT MANUALLY CREATE OR MODIFY *** │ │ │ ├── vendor \u003c--- A symlink to $MODID/system/vendor │ ├── product \u003c--- A symlink to $MODID/system/product │ ├── system_ext \u003c--- A symlink to $MODID/system/system_ext │ │ │ │ *** Any additional files / folders are allowed *** │ │ │ ├── ... │ └── ... | ├── another_module │ ├── . │ └── . ├── . ├── . 再看看模块的安装过程 module.zip │ ├── META-INF │ └── com │ └── google │ └── android │ ├── update-binary \u003c--- The module_installer.sh you downloaded │ └── updater-script \u003c--- Should only contain the string \"#MAGISK\" │ ├── customize.sh \u003c--- (Optional, more details later) │ This script will be sourced by update-binary ├── ... ├── ... /* The rest of module's files */ customize.sh和update-binary是互相配合来完成安装过程中定制的部分 具体看看riru修改了 module.prop id=${id} name=${name} version=${version} versionCode=${versionCode} author=${author} description=${description} riruApi=${riruApi} riruMinApi=${riruMinApi} 设置全局变量 post-fs-data #!/system/bin/sh MODDIR=${0%/*} TMPPROP=\"$(magisk --path)/riru.prop\" MIRRORPROP=\"$(magisk --path)/.magisk/modules/riru-core/module.prop\" sh -Cc \"cat '$MODDIR/module.prop' \u003e '$TMPPROP'\" if [ $? -ne 0 ]; then exit fi mount --bind \"$TMPPROP\" \"$MIRRORPROP\" if [ \"$ZYGISK_ENABLE\" = \"1\" ]; then sed -Ei 's/^description=(\\[.*][[:space:]]*)?/description=[ ⛔ Riru is not loaded because of Zygisk. ] /g' \"$MIRRORPROP\" exit fi sed -Ei 's/^description=(\\[.*][[:space:]]*)?/description=[ ⛔ app_process fails to run. ] /g' \"$MIRRORPROP\" cd \"$MODDIR\" || exit flock \"module.prop\" mount --bind \"$TMPPROP\" \"$MODDIR/module.prop\" unshare -m sh -c \"/system/bin/app_process -Djava.class.path=rirud.apk /system/bin --nice-name=rirud riru.Daemon $(magisk -V) $(magisk --path) $(getprop ro.dalvik.vm.native.bridge)\u0026\" umount \"$MODDIR/module.prop\" 主要在于使用unshare资源隔离的方式启动rirud的守护进程，和magiskd类似，都是在post-fs-data阶段启动的 system.prop ro.dalvik.vm.native.bridge=libriruloader.so 最关键的修改，修改了ro.dalvik.vm.native.bridge属性指向libriruloader.so customize // template/magisk_module/customize.sh // 文件解压 if [ \"$ARCH\" = \"x86\" ] || [ \"$ARCH\" = \"x64\" ]; then ui_print \"- Extracting x86 libraries\" extract \"$ZIPFILE\" 'lib/x86/libriru.so' \"$MODPATH/lib\" true extract \"$ZIPFILE\" 'lib/x86/libriruhide.so' \"$MODPATH/lib\" true extract \"$ZIPFILE\" 'lib/x86/libriruloader.so' \"$MODPATH/system/lib\" true if [ \"$IS64BIT\" = true ]; then ui_print \"- Extracting x64 libraries\" extract \"$ZIPFILE\" 'lib/x86_64/libriru.so' \"$MODPATH/lib64\" true extract \"$ZIPFILE\" 'lib/x86_64/libriruhide.so' \"$MODPATH/lib64\" true extract \"$ZIPFILE\" 'lib/x86_64/libriruloader.so' \"$MODPATH/system/lib64\" true fi else","date":"2023-07-25","objectID":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/:0:2","series":null,"tags":["riru原理"],"title":"Riru原理理解","uri":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/#1-riru结构"},{"categories":["riru"],"content":" 二、实现细节 1 riru结构先从riru的项目结构入手，riru是个Magisk模块，自然是以Magisk模块模板为基础，首先来看看Magisk模块模板都具备哪些 参考开发者文档，Magisk模块都会放在/data/adb/modules目录下，结构如 /data/adb/modules ├── . ├── . | ├── $MODID 模块名称 \u003c--- The folder is named with the ID of the module │ │ │ │ *** Module Identity *** │ │ │ ├── module.prop 模块的基础信息 \u003c--- This file stores the metadata of the module │ │ │ │ *** Main Contents *** │ │ │ ├── system 挂载到system目录 \u003c--- This folder will be mounted if skip_mount does not exist │ │ ├── ... │ │ ├── ... │ │ └── ... │ │ │ ├── zygisk \u003c--- This folder contains the module's Zygisk native libraries │ │ ├── arm64-v8a.so │ │ ├── armeabi-v7a.so │ │ ├── x86.so │ │ ├── x86_64.so │ │ └── unloaded \u003c--- If exists, the native libraries are incompatible │ │ │ │ *** Status Flags *** │ │ │ ├── skip_mount \u003c--- If exists, Magisk will NOT mount your system folder │ ├── disable \u003c--- If exists, the module will be disabled │ ├── remove \u003c--- If exists, the module will be removed next reboot │ │ │ │ *** Optional Files *** │ │ │ ├── post-fs-data.sh 定制脚本 \u003c--- This script will be executed in post-fs-data │ ├── service.sh \u003c--- This script will be executed in late_start service | ├── uninstall.sh \u003c--- This script will be executed when Magisk removes your module │ ├── system.prop 系统属性修改 \u003c--- Properties in this file will be loaded as system properties by resetprop │ ├── sepolicy.rule sepolicy规则修改 \u003c--- Additional custom sepolicy rules │ │ │ │ *** Auto Generated, DO NOT MANUALLY CREATE OR MODIFY *** │ │ │ ├── vendor \u003c--- A symlink to $MODID/system/vendor │ ├── product \u003c--- A symlink to $MODID/system/product │ ├── system_ext \u003c--- A symlink to $MODID/system/system_ext │ │ │ │ *** Any additional files / folders are allowed *** │ │ │ ├── ... │ └── ... | ├── another_module │ ├── . │ └── . ├── . ├── . 再看看模块的安装过程 module.zip │ ├── META-INF │ └── com │ └── google │ └── android │ ├── update-binary \u003c--- The module_installer.sh you downloaded │ └── updater-script \u003c--- Should only contain the string \"#MAGISK\" │ ├── customize.sh \u003c--- (Optional, more details later) │ This script will be sourced by update-binary ├── ... ├── ... /* The rest of module's files */ customize.sh和update-binary是互相配合来完成安装过程中定制的部分 具体看看riru修改了 module.prop id=${id} name=${name} version=${version} versionCode=${versionCode} author=${author} description=${description} riruApi=${riruApi} riruMinApi=${riruMinApi} 设置全局变量 post-fs-data #!/system/bin/sh MODDIR=${0%/*} TMPPROP=\"$(magisk --path)/riru.prop\" MIRRORPROP=\"$(magisk --path)/.magisk/modules/riru-core/module.prop\" sh -Cc \"cat '$MODDIR/module.prop' \u003e '$TMPPROP'\" if [ $? -ne 0 ]; then exit fi mount --bind \"$TMPPROP\" \"$MIRRORPROP\" if [ \"$ZYGISK_ENABLE\" = \"1\" ]; then sed -Ei 's/^description=(\\[.*][[:space:]]*)?/description=[ ⛔ Riru is not loaded because of Zygisk. ] /g' \"$MIRRORPROP\" exit fi sed -Ei 's/^description=(\\[.*][[:space:]]*)?/description=[ ⛔ app_process fails to run. ] /g' \"$MIRRORPROP\" cd \"$MODDIR\" || exit flock \"module.prop\" mount --bind \"$TMPPROP\" \"$MODDIR/module.prop\" unshare -m sh -c \"/system/bin/app_process -Djava.class.path=rirud.apk /system/bin --nice-name=rirud riru.Daemon $(magisk -V) $(magisk --path) $(getprop ro.dalvik.vm.native.bridge)\u0026\" umount \"$MODDIR/module.prop\" 主要在于使用unshare资源隔离的方式启动rirud的守护进程，和magiskd类似，都是在post-fs-data阶段启动的 system.prop ro.dalvik.vm.native.bridge=libriruloader.so 最关键的修改，修改了ro.dalvik.vm.native.bridge属性指向libriruloader.so customize // template/magisk_module/customize.sh // 文件解压 if [ \"$ARCH\" = \"x86\" ] || [ \"$ARCH\" = \"x64\" ]; then ui_print \"- Extracting x86 libraries\" extract \"$ZIPFILE\" 'lib/x86/libriru.so' \"$MODPATH/lib\" true extract \"$ZIPFILE\" 'lib/x86/libriruhide.so' \"$MODPATH/lib\" true extract \"$ZIPFILE\" 'lib/x86/libriruloader.so' \"$MODPATH/system/lib\" true if [ \"$IS64BIT\" = true ]; then ui_print \"- Extracting x64 libraries\" extract \"$ZIPFILE\" 'lib/x86_64/libriru.so' \"$MODPATH/lib64\" true extract \"$ZIPFILE\" 'lib/x86_64/libriruhide.so' \"$MODPATH/lib64\" true extract \"$ZIPFILE\" 'lib/x86_64/libriruloader.so' \"$MODPATH/system/lib64\" true fi else","date":"2023-07-25","objectID":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/:0:2","series":null,"tags":["riru原理"],"title":"Riru原理理解","uri":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/#2-riru启动过程"},{"categories":["riru"],"content":" 二、实现细节 1 riru结构先从riru的项目结构入手，riru是个Magisk模块，自然是以Magisk模块模板为基础，首先来看看Magisk模块模板都具备哪些 参考开发者文档，Magisk模块都会放在/data/adb/modules目录下，结构如 /data/adb/modules ├── . ├── . | ├── $MODID 模块名称 \u003c--- The folder is named with the ID of the module │ │ │ │ *** Module Identity *** │ │ │ ├── module.prop 模块的基础信息 \u003c--- This file stores the metadata of the module │ │ │ │ *** Main Contents *** │ │ │ ├── system 挂载到system目录 \u003c--- This folder will be mounted if skip_mount does not exist │ │ ├── ... │ │ ├── ... │ │ └── ... │ │ │ ├── zygisk \u003c--- This folder contains the module's Zygisk native libraries │ │ ├── arm64-v8a.so │ │ ├── armeabi-v7a.so │ │ ├── x86.so │ │ ├── x86_64.so │ │ └── unloaded \u003c--- If exists, the native libraries are incompatible │ │ │ │ *** Status Flags *** │ │ │ ├── skip_mount \u003c--- If exists, Magisk will NOT mount your system folder │ ├── disable \u003c--- If exists, the module will be disabled │ ├── remove \u003c--- If exists, the module will be removed next reboot │ │ │ │ *** Optional Files *** │ │ │ ├── post-fs-data.sh 定制脚本 \u003c--- This script will be executed in post-fs-data │ ├── service.sh \u003c--- This script will be executed in late_start service | ├── uninstall.sh \u003c--- This script will be executed when Magisk removes your module │ ├── system.prop 系统属性修改 \u003c--- Properties in this file will be loaded as system properties by resetprop │ ├── sepolicy.rule sepolicy规则修改 \u003c--- Additional custom sepolicy rules │ │ │ │ *** Auto Generated, DO NOT MANUALLY CREATE OR MODIFY *** │ │ │ ├── vendor \u003c--- A symlink to $MODID/system/vendor │ ├── product \u003c--- A symlink to $MODID/system/product │ ├── system_ext \u003c--- A symlink to $MODID/system/system_ext │ │ │ │ *** Any additional files / folders are allowed *** │ │ │ ├── ... │ └── ... | ├── another_module │ ├── . │ └── . ├── . ├── . 再看看模块的安装过程 module.zip │ ├── META-INF │ └── com │ └── google │ └── android │ ├── update-binary \u003c--- The module_installer.sh you downloaded │ └── updater-script \u003c--- Should only contain the string \"#MAGISK\" │ ├── customize.sh \u003c--- (Optional, more details later) │ This script will be sourced by update-binary ├── ... ├── ... /* The rest of module's files */ customize.sh和update-binary是互相配合来完成安装过程中定制的部分 具体看看riru修改了 module.prop id=${id} name=${name} version=${version} versionCode=${versionCode} author=${author} description=${description} riruApi=${riruApi} riruMinApi=${riruMinApi} 设置全局变量 post-fs-data #!/system/bin/sh MODDIR=${0%/*} TMPPROP=\"$(magisk --path)/riru.prop\" MIRRORPROP=\"$(magisk --path)/.magisk/modules/riru-core/module.prop\" sh -Cc \"cat '$MODDIR/module.prop' \u003e '$TMPPROP'\" if [ $? -ne 0 ]; then exit fi mount --bind \"$TMPPROP\" \"$MIRRORPROP\" if [ \"$ZYGISK_ENABLE\" = \"1\" ]; then sed -Ei 's/^description=(\\[.*][[:space:]]*)?/description=[ ⛔ Riru is not loaded because of Zygisk. ] /g' \"$MIRRORPROP\" exit fi sed -Ei 's/^description=(\\[.*][[:space:]]*)?/description=[ ⛔ app_process fails to run. ] /g' \"$MIRRORPROP\" cd \"$MODDIR\" || exit flock \"module.prop\" mount --bind \"$TMPPROP\" \"$MODDIR/module.prop\" unshare -m sh -c \"/system/bin/app_process -Djava.class.path=rirud.apk /system/bin --nice-name=rirud riru.Daemon $(magisk -V) $(magisk --path) $(getprop ro.dalvik.vm.native.bridge)\u0026\" umount \"$MODDIR/module.prop\" 主要在于使用unshare资源隔离的方式启动rirud的守护进程，和magiskd类似，都是在post-fs-data阶段启动的 system.prop ro.dalvik.vm.native.bridge=libriruloader.so 最关键的修改，修改了ro.dalvik.vm.native.bridge属性指向libriruloader.so customize // template/magisk_module/customize.sh // 文件解压 if [ \"$ARCH\" = \"x86\" ] || [ \"$ARCH\" = \"x64\" ]; then ui_print \"- Extracting x86 libraries\" extract \"$ZIPFILE\" 'lib/x86/libriru.so' \"$MODPATH/lib\" true extract \"$ZIPFILE\" 'lib/x86/libriruhide.so' \"$MODPATH/lib\" true extract \"$ZIPFILE\" 'lib/x86/libriruloader.so' \"$MODPATH/system/lib\" true if [ \"$IS64BIT\" = true ]; then ui_print \"- Extracting x64 libraries\" extract \"$ZIPFILE\" 'lib/x86_64/libriru.so' \"$MODPATH/lib64\" true extract \"$ZIPFILE\" 'lib/x86_64/libriruhide.so' \"$MODPATH/lib64\" true extract \"$ZIPFILE\" 'lib/x86_64/libriruloader.so' \"$MODPATH/system/lib64\" true fi else","date":"2023-07-25","objectID":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/:0:2","series":null,"tags":["riru原理"],"title":"Riru原理理解","uri":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/#21-hidepreparemapshidelibrary"},{"categories":["riru"],"content":" 二、实现细节 1 riru结构先从riru的项目结构入手，riru是个Magisk模块，自然是以Magisk模块模板为基础，首先来看看Magisk模块模板都具备哪些 参考开发者文档，Magisk模块都会放在/data/adb/modules目录下，结构如 /data/adb/modules ├── . ├── . | ├── $MODID 模块名称 \u003c--- The folder is named with the ID of the module │ │ │ │ *** Module Identity *** │ │ │ ├── module.prop 模块的基础信息 \u003c--- This file stores the metadata of the module │ │ │ │ *** Main Contents *** │ │ │ ├── system 挂载到system目录 \u003c--- This folder will be mounted if skip_mount does not exist │ │ ├── ... │ │ ├── ... │ │ └── ... │ │ │ ├── zygisk \u003c--- This folder contains the module's Zygisk native libraries │ │ ├── arm64-v8a.so │ │ ├── armeabi-v7a.so │ │ ├── x86.so │ │ ├── x86_64.so │ │ └── unloaded \u003c--- If exists, the native libraries are incompatible │ │ │ │ *** Status Flags *** │ │ │ ├── skip_mount \u003c--- If exists, Magisk will NOT mount your system folder │ ├── disable \u003c--- If exists, the module will be disabled │ ├── remove \u003c--- If exists, the module will be removed next reboot │ │ │ │ *** Optional Files *** │ │ │ ├── post-fs-data.sh 定制脚本 \u003c--- This script will be executed in post-fs-data │ ├── service.sh \u003c--- This script will be executed in late_start service | ├── uninstall.sh \u003c--- This script will be executed when Magisk removes your module │ ├── system.prop 系统属性修改 \u003c--- Properties in this file will be loaded as system properties by resetprop │ ├── sepolicy.rule sepolicy规则修改 \u003c--- Additional custom sepolicy rules │ │ │ │ *** Auto Generated, DO NOT MANUALLY CREATE OR MODIFY *** │ │ │ ├── vendor \u003c--- A symlink to $MODID/system/vendor │ ├── product \u003c--- A symlink to $MODID/system/product │ ├── system_ext \u003c--- A symlink to $MODID/system/system_ext │ │ │ │ *** Any additional files / folders are allowed *** │ │ │ ├── ... │ └── ... | ├── another_module │ ├── . │ └── . ├── . ├── . 再看看模块的安装过程 module.zip │ ├── META-INF │ └── com │ └── google │ └── android │ ├── update-binary \u003c--- The module_installer.sh you downloaded │ └── updater-script \u003c--- Should only contain the string \"#MAGISK\" │ ├── customize.sh \u003c--- (Optional, more details later) │ This script will be sourced by update-binary ├── ... ├── ... /* The rest of module's files */ customize.sh和update-binary是互相配合来完成安装过程中定制的部分 具体看看riru修改了 module.prop id=${id} name=${name} version=${version} versionCode=${versionCode} author=${author} description=${description} riruApi=${riruApi} riruMinApi=${riruMinApi} 设置全局变量 post-fs-data #!/system/bin/sh MODDIR=${0%/*} TMPPROP=\"$(magisk --path)/riru.prop\" MIRRORPROP=\"$(magisk --path)/.magisk/modules/riru-core/module.prop\" sh -Cc \"cat '$MODDIR/module.prop' \u003e '$TMPPROP'\" if [ $? -ne 0 ]; then exit fi mount --bind \"$TMPPROP\" \"$MIRRORPROP\" if [ \"$ZYGISK_ENABLE\" = \"1\" ]; then sed -Ei 's/^description=(\\[.*][[:space:]]*)?/description=[ ⛔ Riru is not loaded because of Zygisk. ] /g' \"$MIRRORPROP\" exit fi sed -Ei 's/^description=(\\[.*][[:space:]]*)?/description=[ ⛔ app_process fails to run. ] /g' \"$MIRRORPROP\" cd \"$MODDIR\" || exit flock \"module.prop\" mount --bind \"$TMPPROP\" \"$MODDIR/module.prop\" unshare -m sh -c \"/system/bin/app_process -Djava.class.path=rirud.apk /system/bin --nice-name=rirud riru.Daemon $(magisk -V) $(magisk --path) $(getprop ro.dalvik.vm.native.bridge)\u0026\" umount \"$MODDIR/module.prop\" 主要在于使用unshare资源隔离的方式启动rirud的守护进程，和magiskd类似，都是在post-fs-data阶段启动的 system.prop ro.dalvik.vm.native.bridge=libriruloader.so 最关键的修改，修改了ro.dalvik.vm.native.bridge属性指向libriruloader.so customize // template/magisk_module/customize.sh // 文件解压 if [ \"$ARCH\" = \"x86\" ] || [ \"$ARCH\" = \"x64\" ]; then ui_print \"- Extracting x86 libraries\" extract \"$ZIPFILE\" 'lib/x86/libriru.so' \"$MODPATH/lib\" true extract \"$ZIPFILE\" 'lib/x86/libriruhide.so' \"$MODPATH/lib\" true extract \"$ZIPFILE\" 'lib/x86/libriruloader.so' \"$MODPATH/system/lib\" true if [ \"$IS64BIT\" = true ]; then ui_print \"- Extracting x64 libraries\" extract \"$ZIPFILE\" 'lib/x86_64/libriru.so' \"$MODPATH/lib64\" true extract \"$ZIPFILE\" 'lib/x86_64/libriruhide.so' \"$MODPATH/lib64\" true extract \"$ZIPFILE\" 'lib/x86_64/libriruloader.so' \"$MODPATH/system/lib64\" true fi else","date":"2023-07-25","objectID":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/:0:2","series":null,"tags":["riru原理"],"title":"Riru原理理解","uri":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/#22-jniinstallhooks"},{"categories":["riru"],"content":" 二、实现细节 1 riru结构先从riru的项目结构入手，riru是个Magisk模块，自然是以Magisk模块模板为基础，首先来看看Magisk模块模板都具备哪些 参考开发者文档，Magisk模块都会放在/data/adb/modules目录下，结构如 /data/adb/modules ├── . ├── . | ├── $MODID 模块名称 \u003c--- The folder is named with the ID of the module │ │ │ │ *** Module Identity *** │ │ │ ├── module.prop 模块的基础信息 \u003c--- This file stores the metadata of the module │ │ │ │ *** Main Contents *** │ │ │ ├── system 挂载到system目录 \u003c--- This folder will be mounted if skip_mount does not exist │ │ ├── ... │ │ ├── ... │ │ └── ... │ │ │ ├── zygisk \u003c--- This folder contains the module's Zygisk native libraries │ │ ├── arm64-v8a.so │ │ ├── armeabi-v7a.so │ │ ├── x86.so │ │ ├── x86_64.so │ │ └── unloaded \u003c--- If exists, the native libraries are incompatible │ │ │ │ *** Status Flags *** │ │ │ ├── skip_mount \u003c--- If exists, Magisk will NOT mount your system folder │ ├── disable \u003c--- If exists, the module will be disabled │ ├── remove \u003c--- If exists, the module will be removed next reboot │ │ │ │ *** Optional Files *** │ │ │ ├── post-fs-data.sh 定制脚本 \u003c--- This script will be executed in post-fs-data │ ├── service.sh \u003c--- This script will be executed in late_start service | ├── uninstall.sh \u003c--- This script will be executed when Magisk removes your module │ ├── system.prop 系统属性修改 \u003c--- Properties in this file will be loaded as system properties by resetprop │ ├── sepolicy.rule sepolicy规则修改 \u003c--- Additional custom sepolicy rules │ │ │ │ *** Auto Generated, DO NOT MANUALLY CREATE OR MODIFY *** │ │ │ ├── vendor \u003c--- A symlink to $MODID/system/vendor │ ├── product \u003c--- A symlink to $MODID/system/product │ ├── system_ext \u003c--- A symlink to $MODID/system/system_ext │ │ │ │ *** Any additional files / folders are allowed *** │ │ │ ├── ... │ └── ... | ├── another_module │ ├── . │ └── . ├── . ├── . 再看看模块的安装过程 module.zip │ ├── META-INF │ └── com │ └── google │ └── android │ ├── update-binary \u003c--- The module_installer.sh you downloaded │ └── updater-script \u003c--- Should only contain the string \"#MAGISK\" │ ├── customize.sh \u003c--- (Optional, more details later) │ This script will be sourced by update-binary ├── ... ├── ... /* The rest of module's files */ customize.sh和update-binary是互相配合来完成安装过程中定制的部分 具体看看riru修改了 module.prop id=${id} name=${name} version=${version} versionCode=${versionCode} author=${author} description=${description} riruApi=${riruApi} riruMinApi=${riruMinApi} 设置全局变量 post-fs-data #!/system/bin/sh MODDIR=${0%/*} TMPPROP=\"$(magisk --path)/riru.prop\" MIRRORPROP=\"$(magisk --path)/.magisk/modules/riru-core/module.prop\" sh -Cc \"cat '$MODDIR/module.prop' \u003e '$TMPPROP'\" if [ $? -ne 0 ]; then exit fi mount --bind \"$TMPPROP\" \"$MIRRORPROP\" if [ \"$ZYGISK_ENABLE\" = \"1\" ]; then sed -Ei 's/^description=(\\[.*][[:space:]]*)?/description=[ ⛔ Riru is not loaded because of Zygisk. ] /g' \"$MIRRORPROP\" exit fi sed -Ei 's/^description=(\\[.*][[:space:]]*)?/description=[ ⛔ app_process fails to run. ] /g' \"$MIRRORPROP\" cd \"$MODDIR\" || exit flock \"module.prop\" mount --bind \"$TMPPROP\" \"$MODDIR/module.prop\" unshare -m sh -c \"/system/bin/app_process -Djava.class.path=rirud.apk /system/bin --nice-name=rirud riru.Daemon $(magisk -V) $(magisk --path) $(getprop ro.dalvik.vm.native.bridge)\u0026\" umount \"$MODDIR/module.prop\" 主要在于使用unshare资源隔离的方式启动rirud的守护进程，和magiskd类似，都是在post-fs-data阶段启动的 system.prop ro.dalvik.vm.native.bridge=libriruloader.so 最关键的修改，修改了ro.dalvik.vm.native.bridge属性指向libriruloader.so customize // template/magisk_module/customize.sh // 文件解压 if [ \"$ARCH\" = \"x86\" ] || [ \"$ARCH\" = \"x64\" ]; then ui_print \"- Extracting x86 libraries\" extract \"$ZIPFILE\" 'lib/x86/libriru.so' \"$MODPATH/lib\" true extract \"$ZIPFILE\" 'lib/x86/libriruhide.so' \"$MODPATH/lib\" true extract \"$ZIPFILE\" 'lib/x86/libriruloader.so' \"$MODPATH/system/lib\" true if [ \"$IS64BIT\" = true ]; then ui_print \"- Extracting x64 libraries\" extract \"$ZIPFILE\" 'lib/x86_64/libriru.so' \"$MODPATH/lib64\" true extract \"$ZIPFILE\" 'lib/x86_64/libriruhide.so' \"$MODPATH/lib64\" true extract \"$ZIPFILE\" 'lib/x86_64/libriruloader.so' \"$MODPATH/system/lib64\" true fi else","date":"2023-07-25","objectID":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/:0:2","series":null,"tags":["riru原理"],"title":"Riru原理理解","uri":"/riru%E5%8E%9F%E7%90%86%E7%90%86%E8%A7%A3/#23-modulesload"},{"categories":["Magisk生态"],"content":" 一、前言同样的，作为一个riru模块，从该项目的简介中，就可以发现它的主要作用了 Riru - MomoHider (aka IsolatedMagiskHider) 主要针对isolated进程所做的隐藏，MomoHider提供了几个配置选项来从多个角度隐藏MagiskHide，如下 配置项 说明 isolated 对每一个isolated processes卸载magisk相关的文件，但是无法控制卸载时机，可能会导致部分模块无法正常使用 setns 在isolated processes中能够更快隐藏Magisk app_zygote_magic 让momo无法检测到MagiskHide是运行状态 initrc 隐藏修改init.rc的堆栈 这些配置应该是作者最初的想法，现在某些配置已经无法正常使用了，所以还是从源码中看看现在这个模块具体做了哪些事 ","date":"2023-07-16","objectID":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:1","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru MomoHider源码分析","uri":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#一前言"},{"categories":["Magisk生态"],"content":" 二、源码分析从riru模块的入口main.cpp入手 // 配置了五个自定义方法 static auto module = RiruVersionedModuleInfo { .moduleApiVersion = RIRU_NEW_MODULE_API_VERSION, .moduleInfo = RiruModuleInfo { .supportHide = true, .version = RIRU_MODULE_VERSION_CODE, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = onModuleLoaded, .shouldSkipUid = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; // 变量定义 // module目录 const char* module_dir_ = nullptr; // 配置值，可以看到关于initrc的参数是没有设置了 constexpr const char* kSetNs = \"setns\"; constexpr const char* kMagicHandleAppZygote = \"app_zygote_magic\"; constexpr const char* kMagiskTmp = \"magisk_tmp\"; constexpr const char* kIsolated = \"isolated\"; const char* magisk_tmp_ = nullptr; bool magic_handle_app_zygote_ = false; bool hide_isolated_ = false; bool in_child_ = false; bool isolated_ = false; bool app_zygote_ = false; bool no_new_ns_ = false; jstring* nice_name_ = nullptr; bool use_nsholder_ = false; char* nsholder_mnt_ns_ = nullptr; pid_t nsholder_pid_ = -1; pid_t (*orig_fork)() = nullptr; int (*orig_unshare)(int) = nullptr; int* riru_allow_unload = nullptr; 1 onModuleLoaded void onModuleLoaded() { // magisk加载模块时会分配给模块特定目录 LOGI(\"Magisk module dir is %s\", module_dir_); // 分配给magisk tmp的目录，路径是module_dir_/config/magisk_tmp magisk_tmp_ = ReadMagiskTmp(); LOGI(\"Magisk temp path is %s\", magisk_tmp_); // 读取配置文件，也就是看config目录下是否存在这些配置文件，存在则表明开启这些配置 hide_isolated_ = Exists(kIsolated); magic_handle_app_zygote_ = Exists(kMagicHandleAppZygote); use_nsholder_ = Exists(kSetNs); RegisterHooks(); } void RegisterHooks() { if (!hide_isolated_ \u0026\u0026 !magic_handle_app_zygote_) return; // 使用xhook xhook_enable_debug(1); xhook_enable_sigsegv_protection(0); bool failed = false; // 定义hook函数 #define HOOK(NAME, REPLACE) \\ failed = failed || RegisterHook(#NAME, reinterpret_cast\u003cvoid*\u003e(REPLACE), reinterpret_cast\u003cvoid**\u003e(\u0026orig_##NAME)) // hook fork函数 HOOK(fork, ForkReplace); if (hide_isolated_) { // hook unshare函数 HOOK(unshare, UnshareReplace); } #undef HOOK if (failed || xhook_refresh(0)) { LOGE(\"Failed to register hooks!\"); return; } xhook_clear(); } bool RegisterHook(const char* name, void* replace, void** backup) { int ret = xhook_register(\".*\\\\libandroid_runtime.so$\", name, replace, backup); if (ret != 0) { LOGE(\"Failed to hook %s\", name); return true; } return false; } 在加载该模块时，主要做的事情是读取用户自定义的配置文件，并通过xhook hook了fork函数和unshare函数，具体hook操作如下 1.1 ForkReplace pid_t ForkReplace() { int read_fd = -1, write_fd = -1; #if !USE_NEW_APP_ZYGOTE_MAGIC // 创建管道，用于后续进程通信 if (app_zygote_ \u0026\u0026 magic_handle_app_zygote_) { int pipe_fd[2]; if (pipe(pipe_fd) == -1) { LOGE(\"Failed to create pipe for new app zygote: %s\", strerror(errno)); } else { read_fd = pipe_fd[0]; write_fd = pipe_fd[1]; } } #endif // 调用原始fork方法 pid_t pid = orig_fork(); // pid\u003c0，fork失败，清理管道 if (pid \u003c 0) { #if !USE_NEW_APP_ZYGOTE_MAGIC // fork() failed, clean up if (read_fd != -1) close(read_fd); if (write_fd != -1) close(write_fd); #endif } else if (pid == 0) { // 正常情况的两种情况，第一种事pid=0，也就是子进程中 // child process // Do not hide here because the namespace not separated in_child_ = true; #if !USE_NEW_APP_ZYGOTE_MAGIC if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(read_fd); // 获取新pid pid_t new_pid = MagicHandleAppZygote(); // 向管道中写入新pid值 WriteIntAndClose(write_fd, new_pid); } #endif } else { #if !USE_NEW_APP_ZYGOTE_MAGIC // parent process if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(write_fd); // 读取子进程写入的pid值 pid = ReadIntAndClose(read_fd); LOGI(\"Zygote received new substitute pid %d\", pid); } #endif } return pid; } #if !USE_NEW_APP_ZYGOTE_MAGIC pid_t MagicHandleAppZygote() { // 在子进程中进一步调用fork，返回子进程的子进程的pid LOGI(\"Magic handling app zygote\"); // App zygote, fork a new process to run it (after forking magiskhide detachs) // This makes some detection not working (but also can be easily detected) pi","date":"2023-07-16","objectID":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru MomoHider源码分析","uri":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#二源码分析"},{"categories":["Magisk生态"],"content":" 二、源码分析从riru模块的入口main.cpp入手 // 配置了五个自定义方法 static auto module = RiruVersionedModuleInfo { .moduleApiVersion = RIRU_NEW_MODULE_API_VERSION, .moduleInfo = RiruModuleInfo { .supportHide = true, .version = RIRU_MODULE_VERSION_CODE, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = onModuleLoaded, .shouldSkipUid = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; // 变量定义 // module目录 const char* module_dir_ = nullptr; // 配置值，可以看到关于initrc的参数是没有设置了 constexpr const char* kSetNs = \"setns\"; constexpr const char* kMagicHandleAppZygote = \"app_zygote_magic\"; constexpr const char* kMagiskTmp = \"magisk_tmp\"; constexpr const char* kIsolated = \"isolated\"; const char* magisk_tmp_ = nullptr; bool magic_handle_app_zygote_ = false; bool hide_isolated_ = false; bool in_child_ = false; bool isolated_ = false; bool app_zygote_ = false; bool no_new_ns_ = false; jstring* nice_name_ = nullptr; bool use_nsholder_ = false; char* nsholder_mnt_ns_ = nullptr; pid_t nsholder_pid_ = -1; pid_t (*orig_fork)() = nullptr; int (*orig_unshare)(int) = nullptr; int* riru_allow_unload = nullptr; 1 onModuleLoaded void onModuleLoaded() { // magisk加载模块时会分配给模块特定目录 LOGI(\"Magisk module dir is %s\", module_dir_); // 分配给magisk tmp的目录，路径是module_dir_/config/magisk_tmp magisk_tmp_ = ReadMagiskTmp(); LOGI(\"Magisk temp path is %s\", magisk_tmp_); // 读取配置文件，也就是看config目录下是否存在这些配置文件，存在则表明开启这些配置 hide_isolated_ = Exists(kIsolated); magic_handle_app_zygote_ = Exists(kMagicHandleAppZygote); use_nsholder_ = Exists(kSetNs); RegisterHooks(); } void RegisterHooks() { if (!hide_isolated_ \u0026\u0026 !magic_handle_app_zygote_) return; // 使用xhook xhook_enable_debug(1); xhook_enable_sigsegv_protection(0); bool failed = false; // 定义hook函数 #define HOOK(NAME, REPLACE) \\ failed = failed || RegisterHook(#NAME, reinterpret_cast(REPLACE), reinterpret_cast(\u0026orig_##NAME)) // hook fork函数 HOOK(fork, ForkReplace); if (hide_isolated_) { // hook unshare函数 HOOK(unshare, UnshareReplace); } #undef HOOK if (failed || xhook_refresh(0)) { LOGE(\"Failed to register hooks!\"); return; } xhook_clear(); } bool RegisterHook(const char* name, void* replace, void** backup) { int ret = xhook_register(\".*\\\\libandroid_runtime.so$\", name, replace, backup); if (ret != 0) { LOGE(\"Failed to hook %s\", name); return true; } return false; } 在加载该模块时，主要做的事情是读取用户自定义的配置文件，并通过xhook hook了fork函数和unshare函数，具体hook操作如下 1.1 ForkReplace pid_t ForkReplace() { int read_fd = -1, write_fd = -1; #if !USE_NEW_APP_ZYGOTE_MAGIC // 创建管道，用于后续进程通信 if (app_zygote_ \u0026\u0026 magic_handle_app_zygote_) { int pipe_fd[2]; if (pipe(pipe_fd) == -1) { LOGE(\"Failed to create pipe for new app zygote: %s\", strerror(errno)); } else { read_fd = pipe_fd[0]; write_fd = pipe_fd[1]; } } #endif // 调用原始fork方法 pid_t pid = orig_fork(); // pid\u003c0，fork失败，清理管道 if (pid \u003c 0) { #if !USE_NEW_APP_ZYGOTE_MAGIC // fork() failed, clean up if (read_fd != -1) close(read_fd); if (write_fd != -1) close(write_fd); #endif } else if (pid == 0) { // 正常情况的两种情况，第一种事pid=0，也就是子进程中 // child process // Do not hide here because the namespace not separated in_child_ = true; #if !USE_NEW_APP_ZYGOTE_MAGIC if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(read_fd); // 获取新pid pid_t new_pid = MagicHandleAppZygote(); // 向管道中写入新pid值 WriteIntAndClose(write_fd, new_pid); } #endif } else { #if !USE_NEW_APP_ZYGOTE_MAGIC // parent process if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(write_fd); // 读取子进程写入的pid值 pid = ReadIntAndClose(read_fd); LOGI(\"Zygote received new substitute pid %d\", pid); } #endif } return pid; } #if !USE_NEW_APP_ZYGOTE_MAGIC pid_t MagicHandleAppZygote() { // 在子进程中进一步调用fork，返回子进程的子进程的pid LOGI(\"Magic handling app zygote\"); // App zygote, fork a new process to run it (after forking magiskhide detachs) // This makes some detection not working (but also can be easily detected) pi","date":"2023-07-16","objectID":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru MomoHider源码分析","uri":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#1-onmoduleloaded"},{"categories":["Magisk生态"],"content":" 二、源码分析从riru模块的入口main.cpp入手 // 配置了五个自定义方法 static auto module = RiruVersionedModuleInfo { .moduleApiVersion = RIRU_NEW_MODULE_API_VERSION, .moduleInfo = RiruModuleInfo { .supportHide = true, .version = RIRU_MODULE_VERSION_CODE, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = onModuleLoaded, .shouldSkipUid = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; // 变量定义 // module目录 const char* module_dir_ = nullptr; // 配置值，可以看到关于initrc的参数是没有设置了 constexpr const char* kSetNs = \"setns\"; constexpr const char* kMagicHandleAppZygote = \"app_zygote_magic\"; constexpr const char* kMagiskTmp = \"magisk_tmp\"; constexpr const char* kIsolated = \"isolated\"; const char* magisk_tmp_ = nullptr; bool magic_handle_app_zygote_ = false; bool hide_isolated_ = false; bool in_child_ = false; bool isolated_ = false; bool app_zygote_ = false; bool no_new_ns_ = false; jstring* nice_name_ = nullptr; bool use_nsholder_ = false; char* nsholder_mnt_ns_ = nullptr; pid_t nsholder_pid_ = -1; pid_t (*orig_fork)() = nullptr; int (*orig_unshare)(int) = nullptr; int* riru_allow_unload = nullptr; 1 onModuleLoaded void onModuleLoaded() { // magisk加载模块时会分配给模块特定目录 LOGI(\"Magisk module dir is %s\", module_dir_); // 分配给magisk tmp的目录，路径是module_dir_/config/magisk_tmp magisk_tmp_ = ReadMagiskTmp(); LOGI(\"Magisk temp path is %s\", magisk_tmp_); // 读取配置文件，也就是看config目录下是否存在这些配置文件，存在则表明开启这些配置 hide_isolated_ = Exists(kIsolated); magic_handle_app_zygote_ = Exists(kMagicHandleAppZygote); use_nsholder_ = Exists(kSetNs); RegisterHooks(); } void RegisterHooks() { if (!hide_isolated_ \u0026\u0026 !magic_handle_app_zygote_) return; // 使用xhook xhook_enable_debug(1); xhook_enable_sigsegv_protection(0); bool failed = false; // 定义hook函数 #define HOOK(NAME, REPLACE) \\ failed = failed || RegisterHook(#NAME, reinterpret_cast(REPLACE), reinterpret_cast(\u0026orig_##NAME)) // hook fork函数 HOOK(fork, ForkReplace); if (hide_isolated_) { // hook unshare函数 HOOK(unshare, UnshareReplace); } #undef HOOK if (failed || xhook_refresh(0)) { LOGE(\"Failed to register hooks!\"); return; } xhook_clear(); } bool RegisterHook(const char* name, void* replace, void** backup) { int ret = xhook_register(\".*\\\\libandroid_runtime.so$\", name, replace, backup); if (ret != 0) { LOGE(\"Failed to hook %s\", name); return true; } return false; } 在加载该模块时，主要做的事情是读取用户自定义的配置文件，并通过xhook hook了fork函数和unshare函数，具体hook操作如下 1.1 ForkReplace pid_t ForkReplace() { int read_fd = -1, write_fd = -1; #if !USE_NEW_APP_ZYGOTE_MAGIC // 创建管道，用于后续进程通信 if (app_zygote_ \u0026\u0026 magic_handle_app_zygote_) { int pipe_fd[2]; if (pipe(pipe_fd) == -1) { LOGE(\"Failed to create pipe for new app zygote: %s\", strerror(errno)); } else { read_fd = pipe_fd[0]; write_fd = pipe_fd[1]; } } #endif // 调用原始fork方法 pid_t pid = orig_fork(); // pid\u003c0，fork失败，清理管道 if (pid \u003c 0) { #if !USE_NEW_APP_ZYGOTE_MAGIC // fork() failed, clean up if (read_fd != -1) close(read_fd); if (write_fd != -1) close(write_fd); #endif } else if (pid == 0) { // 正常情况的两种情况，第一种事pid=0，也就是子进程中 // child process // Do not hide here because the namespace not separated in_child_ = true; #if !USE_NEW_APP_ZYGOTE_MAGIC if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(read_fd); // 获取新pid pid_t new_pid = MagicHandleAppZygote(); // 向管道中写入新pid值 WriteIntAndClose(write_fd, new_pid); } #endif } else { #if !USE_NEW_APP_ZYGOTE_MAGIC // parent process if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(write_fd); // 读取子进程写入的pid值 pid = ReadIntAndClose(read_fd); LOGI(\"Zygote received new substitute pid %d\", pid); } #endif } return pid; } #if !USE_NEW_APP_ZYGOTE_MAGIC pid_t MagicHandleAppZygote() { // 在子进程中进一步调用fork，返回子进程的子进程的pid LOGI(\"Magic handling app zygote\"); // App zygote, fork a new process to run it (after forking magiskhide detachs) // This makes some detection not working (but also can be easily detected) pi","date":"2023-07-16","objectID":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru MomoHider源码分析","uri":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#11-forkreplace"},{"categories":["Magisk生态"],"content":" 二、源码分析从riru模块的入口main.cpp入手 // 配置了五个自定义方法 static auto module = RiruVersionedModuleInfo { .moduleApiVersion = RIRU_NEW_MODULE_API_VERSION, .moduleInfo = RiruModuleInfo { .supportHide = true, .version = RIRU_MODULE_VERSION_CODE, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = onModuleLoaded, .shouldSkipUid = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; // 变量定义 // module目录 const char* module_dir_ = nullptr; // 配置值，可以看到关于initrc的参数是没有设置了 constexpr const char* kSetNs = \"setns\"; constexpr const char* kMagicHandleAppZygote = \"app_zygote_magic\"; constexpr const char* kMagiskTmp = \"magisk_tmp\"; constexpr const char* kIsolated = \"isolated\"; const char* magisk_tmp_ = nullptr; bool magic_handle_app_zygote_ = false; bool hide_isolated_ = false; bool in_child_ = false; bool isolated_ = false; bool app_zygote_ = false; bool no_new_ns_ = false; jstring* nice_name_ = nullptr; bool use_nsholder_ = false; char* nsholder_mnt_ns_ = nullptr; pid_t nsholder_pid_ = -1; pid_t (*orig_fork)() = nullptr; int (*orig_unshare)(int) = nullptr; int* riru_allow_unload = nullptr; 1 onModuleLoaded void onModuleLoaded() { // magisk加载模块时会分配给模块特定目录 LOGI(\"Magisk module dir is %s\", module_dir_); // 分配给magisk tmp的目录，路径是module_dir_/config/magisk_tmp magisk_tmp_ = ReadMagiskTmp(); LOGI(\"Magisk temp path is %s\", magisk_tmp_); // 读取配置文件，也就是看config目录下是否存在这些配置文件，存在则表明开启这些配置 hide_isolated_ = Exists(kIsolated); magic_handle_app_zygote_ = Exists(kMagicHandleAppZygote); use_nsholder_ = Exists(kSetNs); RegisterHooks(); } void RegisterHooks() { if (!hide_isolated_ \u0026\u0026 !magic_handle_app_zygote_) return; // 使用xhook xhook_enable_debug(1); xhook_enable_sigsegv_protection(0); bool failed = false; // 定义hook函数 #define HOOK(NAME, REPLACE) \\ failed = failed || RegisterHook(#NAME, reinterpret_cast(REPLACE), reinterpret_cast(\u0026orig_##NAME)) // hook fork函数 HOOK(fork, ForkReplace); if (hide_isolated_) { // hook unshare函数 HOOK(unshare, UnshareReplace); } #undef HOOK if (failed || xhook_refresh(0)) { LOGE(\"Failed to register hooks!\"); return; } xhook_clear(); } bool RegisterHook(const char* name, void* replace, void** backup) { int ret = xhook_register(\".*\\\\libandroid_runtime.so$\", name, replace, backup); if (ret != 0) { LOGE(\"Failed to hook %s\", name); return true; } return false; } 在加载该模块时，主要做的事情是读取用户自定义的配置文件，并通过xhook hook了fork函数和unshare函数，具体hook操作如下 1.1 ForkReplace pid_t ForkReplace() { int read_fd = -1, write_fd = -1; #if !USE_NEW_APP_ZYGOTE_MAGIC // 创建管道，用于后续进程通信 if (app_zygote_ \u0026\u0026 magic_handle_app_zygote_) { int pipe_fd[2]; if (pipe(pipe_fd) == -1) { LOGE(\"Failed to create pipe for new app zygote: %s\", strerror(errno)); } else { read_fd = pipe_fd[0]; write_fd = pipe_fd[1]; } } #endif // 调用原始fork方法 pid_t pid = orig_fork(); // pid\u003c0，fork失败，清理管道 if (pid \u003c 0) { #if !USE_NEW_APP_ZYGOTE_MAGIC // fork() failed, clean up if (read_fd != -1) close(read_fd); if (write_fd != -1) close(write_fd); #endif } else if (pid == 0) { // 正常情况的两种情况，第一种事pid=0，也就是子进程中 // child process // Do not hide here because the namespace not separated in_child_ = true; #if !USE_NEW_APP_ZYGOTE_MAGIC if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(read_fd); // 获取新pid pid_t new_pid = MagicHandleAppZygote(); // 向管道中写入新pid值 WriteIntAndClose(write_fd, new_pid); } #endif } else { #if !USE_NEW_APP_ZYGOTE_MAGIC // parent process if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(write_fd); // 读取子进程写入的pid值 pid = ReadIntAndClose(read_fd); LOGI(\"Zygote received new substitute pid %d\", pid); } #endif } return pid; } #if !USE_NEW_APP_ZYGOTE_MAGIC pid_t MagicHandleAppZygote() { // 在子进程中进一步调用fork，返回子进程的子进程的pid LOGI(\"Magic handling app zygote\"); // App zygote, fork a new process to run it (after forking magiskhide detachs) // This makes some detection not working (but also can be easily detected) pi","date":"2023-07-16","objectID":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru MomoHider源码分析","uri":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#12-unsharereplace"},{"categories":["Magisk生态"],"content":" 二、源码分析从riru模块的入口main.cpp入手 // 配置了五个自定义方法 static auto module = RiruVersionedModuleInfo { .moduleApiVersion = RIRU_NEW_MODULE_API_VERSION, .moduleInfo = RiruModuleInfo { .supportHide = true, .version = RIRU_MODULE_VERSION_CODE, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = onModuleLoaded, .shouldSkipUid = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; // 变量定义 // module目录 const char* module_dir_ = nullptr; // 配置值，可以看到关于initrc的参数是没有设置了 constexpr const char* kSetNs = \"setns\"; constexpr const char* kMagicHandleAppZygote = \"app_zygote_magic\"; constexpr const char* kMagiskTmp = \"magisk_tmp\"; constexpr const char* kIsolated = \"isolated\"; const char* magisk_tmp_ = nullptr; bool magic_handle_app_zygote_ = false; bool hide_isolated_ = false; bool in_child_ = false; bool isolated_ = false; bool app_zygote_ = false; bool no_new_ns_ = false; jstring* nice_name_ = nullptr; bool use_nsholder_ = false; char* nsholder_mnt_ns_ = nullptr; pid_t nsholder_pid_ = -1; pid_t (*orig_fork)() = nullptr; int (*orig_unshare)(int) = nullptr; int* riru_allow_unload = nullptr; 1 onModuleLoaded void onModuleLoaded() { // magisk加载模块时会分配给模块特定目录 LOGI(\"Magisk module dir is %s\", module_dir_); // 分配给magisk tmp的目录，路径是module_dir_/config/magisk_tmp magisk_tmp_ = ReadMagiskTmp(); LOGI(\"Magisk temp path is %s\", magisk_tmp_); // 读取配置文件，也就是看config目录下是否存在这些配置文件，存在则表明开启这些配置 hide_isolated_ = Exists(kIsolated); magic_handle_app_zygote_ = Exists(kMagicHandleAppZygote); use_nsholder_ = Exists(kSetNs); RegisterHooks(); } void RegisterHooks() { if (!hide_isolated_ \u0026\u0026 !magic_handle_app_zygote_) return; // 使用xhook xhook_enable_debug(1); xhook_enable_sigsegv_protection(0); bool failed = false; // 定义hook函数 #define HOOK(NAME, REPLACE) \\ failed = failed || RegisterHook(#NAME, reinterpret_cast(REPLACE), reinterpret_cast(\u0026orig_##NAME)) // hook fork函数 HOOK(fork, ForkReplace); if (hide_isolated_) { // hook unshare函数 HOOK(unshare, UnshareReplace); } #undef HOOK if (failed || xhook_refresh(0)) { LOGE(\"Failed to register hooks!\"); return; } xhook_clear(); } bool RegisterHook(const char* name, void* replace, void** backup) { int ret = xhook_register(\".*\\\\libandroid_runtime.so$\", name, replace, backup); if (ret != 0) { LOGE(\"Failed to hook %s\", name); return true; } return false; } 在加载该模块时，主要做的事情是读取用户自定义的配置文件，并通过xhook hook了fork函数和unshare函数，具体hook操作如下 1.1 ForkReplace pid_t ForkReplace() { int read_fd = -1, write_fd = -1; #if !USE_NEW_APP_ZYGOTE_MAGIC // 创建管道，用于后续进程通信 if (app_zygote_ \u0026\u0026 magic_handle_app_zygote_) { int pipe_fd[2]; if (pipe(pipe_fd) == -1) { LOGE(\"Failed to create pipe for new app zygote: %s\", strerror(errno)); } else { read_fd = pipe_fd[0]; write_fd = pipe_fd[1]; } } #endif // 调用原始fork方法 pid_t pid = orig_fork(); // pid\u003c0，fork失败，清理管道 if (pid \u003c 0) { #if !USE_NEW_APP_ZYGOTE_MAGIC // fork() failed, clean up if (read_fd != -1) close(read_fd); if (write_fd != -1) close(write_fd); #endif } else if (pid == 0) { // 正常情况的两种情况，第一种事pid=0，也就是子进程中 // child process // Do not hide here because the namespace not separated in_child_ = true; #if !USE_NEW_APP_ZYGOTE_MAGIC if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(read_fd); // 获取新pid pid_t new_pid = MagicHandleAppZygote(); // 向管道中写入新pid值 WriteIntAndClose(write_fd, new_pid); } #endif } else { #if !USE_NEW_APP_ZYGOTE_MAGIC // parent process if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(write_fd); // 读取子进程写入的pid值 pid = ReadIntAndClose(read_fd); LOGI(\"Zygote received new substitute pid %d\", pid); } #endif } return pid; } #if !USE_NEW_APP_ZYGOTE_MAGIC pid_t MagicHandleAppZygote() { // 在子进程中进一步调用fork，返回子进程的子进程的pid LOGI(\"Magic handling app zygote\"); // App zygote, fork a new process to run it (after forking magiskhide detachs) // This makes some detection not working (but also can be easily detected) pi","date":"2023-07-16","objectID":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru MomoHider源码分析","uri":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#2-forkandspecializepre"},{"categories":["Magisk生态"],"content":" 二、源码分析从riru模块的入口main.cpp入手 // 配置了五个自定义方法 static auto module = RiruVersionedModuleInfo { .moduleApiVersion = RIRU_NEW_MODULE_API_VERSION, .moduleInfo = RiruModuleInfo { .supportHide = true, .version = RIRU_MODULE_VERSION_CODE, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = onModuleLoaded, .shouldSkipUid = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; // 变量定义 // module目录 const char* module_dir_ = nullptr; // 配置值，可以看到关于initrc的参数是没有设置了 constexpr const char* kSetNs = \"setns\"; constexpr const char* kMagicHandleAppZygote = \"app_zygote_magic\"; constexpr const char* kMagiskTmp = \"magisk_tmp\"; constexpr const char* kIsolated = \"isolated\"; const char* magisk_tmp_ = nullptr; bool magic_handle_app_zygote_ = false; bool hide_isolated_ = false; bool in_child_ = false; bool isolated_ = false; bool app_zygote_ = false; bool no_new_ns_ = false; jstring* nice_name_ = nullptr; bool use_nsholder_ = false; char* nsholder_mnt_ns_ = nullptr; pid_t nsholder_pid_ = -1; pid_t (*orig_fork)() = nullptr; int (*orig_unshare)(int) = nullptr; int* riru_allow_unload = nullptr; 1 onModuleLoaded void onModuleLoaded() { // magisk加载模块时会分配给模块特定目录 LOGI(\"Magisk module dir is %s\", module_dir_); // 分配给magisk tmp的目录，路径是module_dir_/config/magisk_tmp magisk_tmp_ = ReadMagiskTmp(); LOGI(\"Magisk temp path is %s\", magisk_tmp_); // 读取配置文件，也就是看config目录下是否存在这些配置文件，存在则表明开启这些配置 hide_isolated_ = Exists(kIsolated); magic_handle_app_zygote_ = Exists(kMagicHandleAppZygote); use_nsholder_ = Exists(kSetNs); RegisterHooks(); } void RegisterHooks() { if (!hide_isolated_ \u0026\u0026 !magic_handle_app_zygote_) return; // 使用xhook xhook_enable_debug(1); xhook_enable_sigsegv_protection(0); bool failed = false; // 定义hook函数 #define HOOK(NAME, REPLACE) \\ failed = failed || RegisterHook(#NAME, reinterpret_cast(REPLACE), reinterpret_cast(\u0026orig_##NAME)) // hook fork函数 HOOK(fork, ForkReplace); if (hide_isolated_) { // hook unshare函数 HOOK(unshare, UnshareReplace); } #undef HOOK if (failed || xhook_refresh(0)) { LOGE(\"Failed to register hooks!\"); return; } xhook_clear(); } bool RegisterHook(const char* name, void* replace, void** backup) { int ret = xhook_register(\".*\\\\libandroid_runtime.so$\", name, replace, backup); if (ret != 0) { LOGE(\"Failed to hook %s\", name); return true; } return false; } 在加载该模块时，主要做的事情是读取用户自定义的配置文件，并通过xhook hook了fork函数和unshare函数，具体hook操作如下 1.1 ForkReplace pid_t ForkReplace() { int read_fd = -1, write_fd = -1; #if !USE_NEW_APP_ZYGOTE_MAGIC // 创建管道，用于后续进程通信 if (app_zygote_ \u0026\u0026 magic_handle_app_zygote_) { int pipe_fd[2]; if (pipe(pipe_fd) == -1) { LOGE(\"Failed to create pipe for new app zygote: %s\", strerror(errno)); } else { read_fd = pipe_fd[0]; write_fd = pipe_fd[1]; } } #endif // 调用原始fork方法 pid_t pid = orig_fork(); // pid\u003c0，fork失败，清理管道 if (pid \u003c 0) { #if !USE_NEW_APP_ZYGOTE_MAGIC // fork() failed, clean up if (read_fd != -1) close(read_fd); if (write_fd != -1) close(write_fd); #endif } else if (pid == 0) { // 正常情况的两种情况，第一种事pid=0，也就是子进程中 // child process // Do not hide here because the namespace not separated in_child_ = true; #if !USE_NEW_APP_ZYGOTE_MAGIC if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(read_fd); // 获取新pid pid_t new_pid = MagicHandleAppZygote(); // 向管道中写入新pid值 WriteIntAndClose(write_fd, new_pid); } #endif } else { #if !USE_NEW_APP_ZYGOTE_MAGIC // parent process if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(write_fd); // 读取子进程写入的pid值 pid = ReadIntAndClose(read_fd); LOGI(\"Zygote received new substitute pid %d\", pid); } #endif } return pid; } #if !USE_NEW_APP_ZYGOTE_MAGIC pid_t MagicHandleAppZygote() { // 在子进程中进一步调用fork，返回子进程的子进程的pid LOGI(\"Magic handling app zygote\"); // App zygote, fork a new process to run it (after forking magiskhide detachs) // This makes some detection not working (but also can be easily detected) pi","date":"2023-07-16","objectID":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru MomoHider源码分析","uri":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#3-forkandspecializepost"},{"categories":["Magisk生态"],"content":" 二、源码分析从riru模块的入口main.cpp入手 // 配置了五个自定义方法 static auto module = RiruVersionedModuleInfo { .moduleApiVersion = RIRU_NEW_MODULE_API_VERSION, .moduleInfo = RiruModuleInfo { .supportHide = true, .version = RIRU_MODULE_VERSION_CODE, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = onModuleLoaded, .shouldSkipUid = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; // 变量定义 // module目录 const char* module_dir_ = nullptr; // 配置值，可以看到关于initrc的参数是没有设置了 constexpr const char* kSetNs = \"setns\"; constexpr const char* kMagicHandleAppZygote = \"app_zygote_magic\"; constexpr const char* kMagiskTmp = \"magisk_tmp\"; constexpr const char* kIsolated = \"isolated\"; const char* magisk_tmp_ = nullptr; bool magic_handle_app_zygote_ = false; bool hide_isolated_ = false; bool in_child_ = false; bool isolated_ = false; bool app_zygote_ = false; bool no_new_ns_ = false; jstring* nice_name_ = nullptr; bool use_nsholder_ = false; char* nsholder_mnt_ns_ = nullptr; pid_t nsholder_pid_ = -1; pid_t (*orig_fork)() = nullptr; int (*orig_unshare)(int) = nullptr; int* riru_allow_unload = nullptr; 1 onModuleLoaded void onModuleLoaded() { // magisk加载模块时会分配给模块特定目录 LOGI(\"Magisk module dir is %s\", module_dir_); // 分配给magisk tmp的目录，路径是module_dir_/config/magisk_tmp magisk_tmp_ = ReadMagiskTmp(); LOGI(\"Magisk temp path is %s\", magisk_tmp_); // 读取配置文件，也就是看config目录下是否存在这些配置文件，存在则表明开启这些配置 hide_isolated_ = Exists(kIsolated); magic_handle_app_zygote_ = Exists(kMagicHandleAppZygote); use_nsholder_ = Exists(kSetNs); RegisterHooks(); } void RegisterHooks() { if (!hide_isolated_ \u0026\u0026 !magic_handle_app_zygote_) return; // 使用xhook xhook_enable_debug(1); xhook_enable_sigsegv_protection(0); bool failed = false; // 定义hook函数 #define HOOK(NAME, REPLACE) \\ failed = failed || RegisterHook(#NAME, reinterpret_cast(REPLACE), reinterpret_cast(\u0026orig_##NAME)) // hook fork函数 HOOK(fork, ForkReplace); if (hide_isolated_) { // hook unshare函数 HOOK(unshare, UnshareReplace); } #undef HOOK if (failed || xhook_refresh(0)) { LOGE(\"Failed to register hooks!\"); return; } xhook_clear(); } bool RegisterHook(const char* name, void* replace, void** backup) { int ret = xhook_register(\".*\\\\libandroid_runtime.so$\", name, replace, backup); if (ret != 0) { LOGE(\"Failed to hook %s\", name); return true; } return false; } 在加载该模块时，主要做的事情是读取用户自定义的配置文件，并通过xhook hook了fork函数和unshare函数，具体hook操作如下 1.1 ForkReplace pid_t ForkReplace() { int read_fd = -1, write_fd = -1; #if !USE_NEW_APP_ZYGOTE_MAGIC // 创建管道，用于后续进程通信 if (app_zygote_ \u0026\u0026 magic_handle_app_zygote_) { int pipe_fd[2]; if (pipe(pipe_fd) == -1) { LOGE(\"Failed to create pipe for new app zygote: %s\", strerror(errno)); } else { read_fd = pipe_fd[0]; write_fd = pipe_fd[1]; } } #endif // 调用原始fork方法 pid_t pid = orig_fork(); // pid\u003c0，fork失败，清理管道 if (pid \u003c 0) { #if !USE_NEW_APP_ZYGOTE_MAGIC // fork() failed, clean up if (read_fd != -1) close(read_fd); if (write_fd != -1) close(write_fd); #endif } else if (pid == 0) { // 正常情况的两种情况，第一种事pid=0，也就是子进程中 // child process // Do not hide here because the namespace not separated in_child_ = true; #if !USE_NEW_APP_ZYGOTE_MAGIC if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(read_fd); // 获取新pid pid_t new_pid = MagicHandleAppZygote(); // 向管道中写入新pid值 WriteIntAndClose(write_fd, new_pid); } #endif } else { #if !USE_NEW_APP_ZYGOTE_MAGIC // parent process if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(write_fd); // 读取子进程写入的pid值 pid = ReadIntAndClose(read_fd); LOGI(\"Zygote received new substitute pid %d\", pid); } #endif } return pid; } #if !USE_NEW_APP_ZYGOTE_MAGIC pid_t MagicHandleAppZygote() { // 在子进程中进一步调用fork，返回子进程的子进程的pid LOGI(\"Magic handling app zygote\"); // App zygote, fork a new process to run it (after forking magiskhide detachs) // This makes some detection not working (but also can be easily detected) pi","date":"2023-07-16","objectID":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru MomoHider源码分析","uri":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#4-specializeappprocesspre"},{"categories":["Magisk生态"],"content":" 二、源码分析从riru模块的入口main.cpp入手 // 配置了五个自定义方法 static auto module = RiruVersionedModuleInfo { .moduleApiVersion = RIRU_NEW_MODULE_API_VERSION, .moduleInfo = RiruModuleInfo { .supportHide = true, .version = RIRU_MODULE_VERSION_CODE, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = onModuleLoaded, .shouldSkipUid = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; // 变量定义 // module目录 const char* module_dir_ = nullptr; // 配置值，可以看到关于initrc的参数是没有设置了 constexpr const char* kSetNs = \"setns\"; constexpr const char* kMagicHandleAppZygote = \"app_zygote_magic\"; constexpr const char* kMagiskTmp = \"magisk_tmp\"; constexpr const char* kIsolated = \"isolated\"; const char* magisk_tmp_ = nullptr; bool magic_handle_app_zygote_ = false; bool hide_isolated_ = false; bool in_child_ = false; bool isolated_ = false; bool app_zygote_ = false; bool no_new_ns_ = false; jstring* nice_name_ = nullptr; bool use_nsholder_ = false; char* nsholder_mnt_ns_ = nullptr; pid_t nsholder_pid_ = -1; pid_t (*orig_fork)() = nullptr; int (*orig_unshare)(int) = nullptr; int* riru_allow_unload = nullptr; 1 onModuleLoaded void onModuleLoaded() { // magisk加载模块时会分配给模块特定目录 LOGI(\"Magisk module dir is %s\", module_dir_); // 分配给magisk tmp的目录，路径是module_dir_/config/magisk_tmp magisk_tmp_ = ReadMagiskTmp(); LOGI(\"Magisk temp path is %s\", magisk_tmp_); // 读取配置文件，也就是看config目录下是否存在这些配置文件，存在则表明开启这些配置 hide_isolated_ = Exists(kIsolated); magic_handle_app_zygote_ = Exists(kMagicHandleAppZygote); use_nsholder_ = Exists(kSetNs); RegisterHooks(); } void RegisterHooks() { if (!hide_isolated_ \u0026\u0026 !magic_handle_app_zygote_) return; // 使用xhook xhook_enable_debug(1); xhook_enable_sigsegv_protection(0); bool failed = false; // 定义hook函数 #define HOOK(NAME, REPLACE) \\ failed = failed || RegisterHook(#NAME, reinterpret_cast(REPLACE), reinterpret_cast(\u0026orig_##NAME)) // hook fork函数 HOOK(fork, ForkReplace); if (hide_isolated_) { // hook unshare函数 HOOK(unshare, UnshareReplace); } #undef HOOK if (failed || xhook_refresh(0)) { LOGE(\"Failed to register hooks!\"); return; } xhook_clear(); } bool RegisterHook(const char* name, void* replace, void** backup) { int ret = xhook_register(\".*\\\\libandroid_runtime.so$\", name, replace, backup); if (ret != 0) { LOGE(\"Failed to hook %s\", name); return true; } return false; } 在加载该模块时，主要做的事情是读取用户自定义的配置文件，并通过xhook hook了fork函数和unshare函数，具体hook操作如下 1.1 ForkReplace pid_t ForkReplace() { int read_fd = -1, write_fd = -1; #if !USE_NEW_APP_ZYGOTE_MAGIC // 创建管道，用于后续进程通信 if (app_zygote_ \u0026\u0026 magic_handle_app_zygote_) { int pipe_fd[2]; if (pipe(pipe_fd) == -1) { LOGE(\"Failed to create pipe for new app zygote: %s\", strerror(errno)); } else { read_fd = pipe_fd[0]; write_fd = pipe_fd[1]; } } #endif // 调用原始fork方法 pid_t pid = orig_fork(); // pid\u003c0，fork失败，清理管道 if (pid \u003c 0) { #if !USE_NEW_APP_ZYGOTE_MAGIC // fork() failed, clean up if (read_fd != -1) close(read_fd); if (write_fd != -1) close(write_fd); #endif } else if (pid == 0) { // 正常情况的两种情况，第一种事pid=0，也就是子进程中 // child process // Do not hide here because the namespace not separated in_child_ = true; #if !USE_NEW_APP_ZYGOTE_MAGIC if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(read_fd); // 获取新pid pid_t new_pid = MagicHandleAppZygote(); // 向管道中写入新pid值 WriteIntAndClose(write_fd, new_pid); } #endif } else { #if !USE_NEW_APP_ZYGOTE_MAGIC // parent process if (read_fd != -1 \u0026\u0026 write_fd != -1) { close(write_fd); // 读取子进程写入的pid值 pid = ReadIntAndClose(read_fd); LOGI(\"Zygote received new substitute pid %d\", pid); } #endif } return pid; } #if !USE_NEW_APP_ZYGOTE_MAGIC pid_t MagicHandleAppZygote() { // 在子进程中进一步调用fork，返回子进程的子进程的pid LOGI(\"Magic handling app zygote\"); // App zygote, fork a new process to run it (after forking magiskhide detachs) // This makes some detection not working (but also can be easily detected) pi","date":"2023-07-16","objectID":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru MomoHider源码分析","uri":"/riru-momohider%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#5-specializeappprocesspost"},{"categories":["系统定制"],"content":"以红米Note11内核改机为例说明 sys.c：内核版本 statfs.c：文件信息 stat.c：文件信息 readdir.c：目录下的文件列表 open.c：文件重定向 ","date":"2023-07-10","objectID":"/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E6%94%B9%E6%9C%BA%E7%AD%96%E7%95%A5/:0:0","series":null,"tags":["内核改机"],"title":"基于内核的改机策略","uri":"/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E6%94%B9%E6%9C%BA%E7%AD%96%E7%95%A5/#"},{"categories":["Magisk生态"],"content":" 一、前言在之前的Magisk检测方式的文章中，提到过isolated process的概念，MagiskHide无法处理这种进程，因为它和zygote共同使用同一个namespace，如果对这类进程进行unmount的话，会导致所有app都无法正正常访问到su，对于这种情况，可以使用riru-unshare模块来处理使指定的独立进程不与zygote共享namespace ","date":"2023-07-04","objectID":"/riru-unshare%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:1","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru Unshare源码分析","uri":"/riru-unshare%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#一前言"},{"categories":["Magisk生态"],"content":" 二、源码分析riru-unshare是一个riru模块，看源码就从从main.cpp入手 #ifndef RIRU_MODULE_LEGACY_INIT RiruVersionedModuleInfo *init(Riru *riru) { auto core_max_api_version = riru-\u003eriruApiVersion; riru_api_version = core_max_api_version \u003c= RIRU_MODULE_API_VERSION ? core_max_api_version : RIRU_MODULE_API_VERSION; module.moduleApiVersion = riru_api_version; riru_magisk_module_path = strdup(riru-\u003emagiskModulePath); if (riru_api_version \u003e= 25) { riru_allow_unload = riru-\u003eallowUnload; } return \u0026module; } #else RiruVersionedModuleInfo *init(Riru *riru) { static int step = 0; step += 1; switch (step) { case 1: { auto core_max_api_version = riru-\u003eriruApiVersion; riru_api_version = core_max_api_version \u003c= RIRU_MODULE_API_VERSION ? core_max_api_version : RIRU_MODULE_API_VERSION; if (riru_api_version \u003c 25) { module.moduleInfo.unused = (void *) shouldSkipUid; } else { riru_allow_unload = riru-\u003eallowUnload; } if (riru_api_version \u003e= 24) { module.moduleApiVersion = riru_api_version; riru_magisk_module_path = strdup(riru-\u003emagiskModulePath); return \u0026module; } else { return (RiruVersionedModuleInfo *) \u0026riru_api_version; } } case 2: { return (RiruVersionedModuleInfo *) \u0026module.moduleInfo; } case 3: default: { return nullptr; } } } #endif } 配置需要替换的函数 static auto module = RiruVersionedModuleInfo{ .moduleApiVersion = RIRU_MODULE_API_VERSION, .moduleInfo= RiruModuleInfo{ .supportHide = true, .version = RIRU_MODULE_VERSION, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; 主要是四个函数forkAndSpecializePre、forkAndSpecializePost、specializeAppProcessPre和specializeAppProcessPost 在zygote fork产生新进程前后做处理 1 forkAndSpecializePre在forck出一个新的子进程前被调用，处理工作如设置UID、GID、环境变量等等，选择在forkAndSpecializePre阶段做doUnshare处理也是防止进程正常启动后无法再改变namespace static void forkAndSpecializePre( JNIEnv *env, jclass clazz, jint *uid, jint *gid, jintArray *gids, jint *runtimeFlags, jobjectArray *rlimits, jint *mountExternal, jstring *seInfo, jstring *niceName, jintArray *fdsToClose, jintArray *fdsToIgnore, jboolean *is_child_zygote, jstring *instructionSet, jstring *appDataDir, jboolean *isTopApp, jobjectArray *pkgDataInfoList, jobjectArray *whitelistedDataInfoList, jboolean *bindMountAppDataDirs, jboolean *bindMountAppStorageDirs) { //应用启动前调用 doUnshare(env, uid, mountExternal, niceName, *is_child_zygote); } static void doUnshare(JNIEnv *env, jint *uid, jint *mountExternal, jstring *niceName, bool is_child_zygote) { //uid判断 if (shouldSkipUid(*uid)) return; // 改变mount状态 if (*mountExternal == 0) { *mountExternal = 1; ScopedUtfChars name(env, *niceName); is_app_zygote = is_child_zygote \u0026\u0026 is_app(*uid); nice_name_ = niceName; LOGI(\"unshare uid=%d name=%s app_zygote=%s\", *uid, name.c_str(), is_app_zygote?\"true\":\"false\"); } } static int shouldSkipUid(int uid) { int appid = uid % AID_USER_OFFSET; if (appid \u003e= AID_APP_START \u0026\u0026 appid \u003c= AID_APP_END) return false; if (appid \u003e= AID_ISOLATED_START \u0026\u0026 appid \u003c= AID_ISOLATED_END) return false; return true; } static bool is_app(int uid) { return uid%100000 \u003e= 10000 \u0026\u0026 uid%100000 \u003c= 19999; } 关键在于mountExternal这个参数的修改，那这个参数的作用是什么呢？从zygote源码中看看 private Process.ProcessStartResult startViaZygote(@NonNull final String processClass, @Nullable final String niceName, final int uid, final int gid, @Nullable final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, @Nullable String seInfo, @NonNull String abi, @Nullable String instructionSet, @Nullable String appDataDir, @Nullable String invokeWith, boolean startChildZygote, @Nullable String packageName, int zygotePolicyFlags, boolean isTopApp, @Nullable long[] disabledCompatChanges, @Nullable Map\u003cString, Pair\u003cString, Long\u003e\u003e pkgDataInfoMap, @Nullable Map\u003cString, Pair\u003cString, Long\u003e\u003e allowlistedDataInfoList, boolean bindMountAppsData, boolean bindMoun","date":"2023-07-04","objectID":"/riru-unshare%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru Unshare源码分析","uri":"/riru-unshare%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#二源码分析"},{"categories":["Magisk生态"],"content":" 二、源码分析riru-unshare是一个riru模块，看源码就从从main.cpp入手 #ifndef RIRU_MODULE_LEGACY_INIT RiruVersionedModuleInfo *init(Riru *riru) { auto core_max_api_version = riru-\u003eriruApiVersion; riru_api_version = core_max_api_version \u003c= RIRU_MODULE_API_VERSION ? core_max_api_version : RIRU_MODULE_API_VERSION; module.moduleApiVersion = riru_api_version; riru_magisk_module_path = strdup(riru-\u003emagiskModulePath); if (riru_api_version \u003e= 25) { riru_allow_unload = riru-\u003eallowUnload; } return \u0026module; } #else RiruVersionedModuleInfo *init(Riru *riru) { static int step = 0; step += 1; switch (step) { case 1: { auto core_max_api_version = riru-\u003eriruApiVersion; riru_api_version = core_max_api_version \u003c= RIRU_MODULE_API_VERSION ? core_max_api_version : RIRU_MODULE_API_VERSION; if (riru_api_version \u003c 25) { module.moduleInfo.unused = (void *) shouldSkipUid; } else { riru_allow_unload = riru-\u003eallowUnload; } if (riru_api_version \u003e= 24) { module.moduleApiVersion = riru_api_version; riru_magisk_module_path = strdup(riru-\u003emagiskModulePath); return \u0026module; } else { return (RiruVersionedModuleInfo *) \u0026riru_api_version; } } case 2: { return (RiruVersionedModuleInfo *) \u0026module.moduleInfo; } case 3: default: { return nullptr; } } } #endif } 配置需要替换的函数 static auto module = RiruVersionedModuleInfo{ .moduleApiVersion = RIRU_MODULE_API_VERSION, .moduleInfo= RiruModuleInfo{ .supportHide = true, .version = RIRU_MODULE_VERSION, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; 主要是四个函数forkAndSpecializePre、forkAndSpecializePost、specializeAppProcessPre和specializeAppProcessPost 在zygote fork产生新进程前后做处理 1 forkAndSpecializePre在forck出一个新的子进程前被调用，处理工作如设置UID、GID、环境变量等等，选择在forkAndSpecializePre阶段做doUnshare处理也是防止进程正常启动后无法再改变namespace static void forkAndSpecializePre( JNIEnv *env, jclass clazz, jint *uid, jint *gid, jintArray *gids, jint *runtimeFlags, jobjectArray *rlimits, jint *mountExternal, jstring *seInfo, jstring *niceName, jintArray *fdsToClose, jintArray *fdsToIgnore, jboolean *is_child_zygote, jstring *instructionSet, jstring *appDataDir, jboolean *isTopApp, jobjectArray *pkgDataInfoList, jobjectArray *whitelistedDataInfoList, jboolean *bindMountAppDataDirs, jboolean *bindMountAppStorageDirs) { //应用启动前调用 doUnshare(env, uid, mountExternal, niceName, *is_child_zygote); } static void doUnshare(JNIEnv *env, jint *uid, jint *mountExternal, jstring *niceName, bool is_child_zygote) { //uid判断 if (shouldSkipUid(*uid)) return; // 改变mount状态 if (*mountExternal == 0) { *mountExternal = 1; ScopedUtfChars name(env, *niceName); is_app_zygote = is_child_zygote \u0026\u0026 is_app(*uid); nice_name_ = niceName; LOGI(\"unshare uid=%d name=%s app_zygote=%s\", *uid, name.c_str(), is_app_zygote?\"true\":\"false\"); } } static int shouldSkipUid(int uid) { int appid = uid % AID_USER_OFFSET; if (appid \u003e= AID_APP_START \u0026\u0026 appid \u003c= AID_APP_END) return false; if (appid \u003e= AID_ISOLATED_START \u0026\u0026 appid \u003c= AID_ISOLATED_END) return false; return true; } static bool is_app(int uid) { return uid%100000 \u003e= 10000 \u0026\u0026 uid%100000 \u003c= 19999; } 关键在于mountExternal这个参数的修改，那这个参数的作用是什么呢？从zygote源码中看看 private Process.ProcessStartResult startViaZygote(@NonNull final String processClass, @Nullable final String niceName, final int uid, final int gid, @Nullable final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, @Nullable String seInfo, @NonNull String abi, @Nullable String instructionSet, @Nullable String appDataDir, @Nullable String invokeWith, boolean startChildZygote, @Nullable String packageName, int zygotePolicyFlags, boolean isTopApp, @Nullable long[] disabledCompatChanges, @Nullable Map","date":"2023-07-04","objectID":"/riru-unshare%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru Unshare源码分析","uri":"/riru-unshare%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#1-forkandspecializepre"},{"categories":["Magisk生态"],"content":" 二、源码分析riru-unshare是一个riru模块，看源码就从从main.cpp入手 #ifndef RIRU_MODULE_LEGACY_INIT RiruVersionedModuleInfo *init(Riru *riru) { auto core_max_api_version = riru-\u003eriruApiVersion; riru_api_version = core_max_api_version \u003c= RIRU_MODULE_API_VERSION ? core_max_api_version : RIRU_MODULE_API_VERSION; module.moduleApiVersion = riru_api_version; riru_magisk_module_path = strdup(riru-\u003emagiskModulePath); if (riru_api_version \u003e= 25) { riru_allow_unload = riru-\u003eallowUnload; } return \u0026module; } #else RiruVersionedModuleInfo *init(Riru *riru) { static int step = 0; step += 1; switch (step) { case 1: { auto core_max_api_version = riru-\u003eriruApiVersion; riru_api_version = core_max_api_version \u003c= RIRU_MODULE_API_VERSION ? core_max_api_version : RIRU_MODULE_API_VERSION; if (riru_api_version \u003c 25) { module.moduleInfo.unused = (void *) shouldSkipUid; } else { riru_allow_unload = riru-\u003eallowUnload; } if (riru_api_version \u003e= 24) { module.moduleApiVersion = riru_api_version; riru_magisk_module_path = strdup(riru-\u003emagiskModulePath); return \u0026module; } else { return (RiruVersionedModuleInfo *) \u0026riru_api_version; } } case 2: { return (RiruVersionedModuleInfo *) \u0026module.moduleInfo; } case 3: default: { return nullptr; } } } #endif } 配置需要替换的函数 static auto module = RiruVersionedModuleInfo{ .moduleApiVersion = RIRU_MODULE_API_VERSION, .moduleInfo= RiruModuleInfo{ .supportHide = true, .version = RIRU_MODULE_VERSION, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; 主要是四个函数forkAndSpecializePre、forkAndSpecializePost、specializeAppProcessPre和specializeAppProcessPost 在zygote fork产生新进程前后做处理 1 forkAndSpecializePre在forck出一个新的子进程前被调用，处理工作如设置UID、GID、环境变量等等，选择在forkAndSpecializePre阶段做doUnshare处理也是防止进程正常启动后无法再改变namespace static void forkAndSpecializePre( JNIEnv *env, jclass clazz, jint *uid, jint *gid, jintArray *gids, jint *runtimeFlags, jobjectArray *rlimits, jint *mountExternal, jstring *seInfo, jstring *niceName, jintArray *fdsToClose, jintArray *fdsToIgnore, jboolean *is_child_zygote, jstring *instructionSet, jstring *appDataDir, jboolean *isTopApp, jobjectArray *pkgDataInfoList, jobjectArray *whitelistedDataInfoList, jboolean *bindMountAppDataDirs, jboolean *bindMountAppStorageDirs) { //应用启动前调用 doUnshare(env, uid, mountExternal, niceName, *is_child_zygote); } static void doUnshare(JNIEnv *env, jint *uid, jint *mountExternal, jstring *niceName, bool is_child_zygote) { //uid判断 if (shouldSkipUid(*uid)) return; // 改变mount状态 if (*mountExternal == 0) { *mountExternal = 1; ScopedUtfChars name(env, *niceName); is_app_zygote = is_child_zygote \u0026\u0026 is_app(*uid); nice_name_ = niceName; LOGI(\"unshare uid=%d name=%s app_zygote=%s\", *uid, name.c_str(), is_app_zygote?\"true\":\"false\"); } } static int shouldSkipUid(int uid) { int appid = uid % AID_USER_OFFSET; if (appid \u003e= AID_APP_START \u0026\u0026 appid \u003c= AID_APP_END) return false; if (appid \u003e= AID_ISOLATED_START \u0026\u0026 appid \u003c= AID_ISOLATED_END) return false; return true; } static bool is_app(int uid) { return uid%100000 \u003e= 10000 \u0026\u0026 uid%100000 \u003c= 19999; } 关键在于mountExternal这个参数的修改，那这个参数的作用是什么呢？从zygote源码中看看 private Process.ProcessStartResult startViaZygote(@NonNull final String processClass, @Nullable final String niceName, final int uid, final int gid, @Nullable final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, @Nullable String seInfo, @NonNull String abi, @Nullable String instructionSet, @Nullable String appDataDir, @Nullable String invokeWith, boolean startChildZygote, @Nullable String packageName, int zygotePolicyFlags, boolean isTopApp, @Nullable long[] disabledCompatChanges, @Nullable Map","date":"2023-07-04","objectID":"/riru-unshare%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru Unshare源码分析","uri":"/riru-unshare%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#2-forkandspecializepost"},{"categories":["Magisk生态"],"content":" 二、源码分析riru-unshare是一个riru模块，看源码就从从main.cpp入手 #ifndef RIRU_MODULE_LEGACY_INIT RiruVersionedModuleInfo *init(Riru *riru) { auto core_max_api_version = riru-\u003eriruApiVersion; riru_api_version = core_max_api_version \u003c= RIRU_MODULE_API_VERSION ? core_max_api_version : RIRU_MODULE_API_VERSION; module.moduleApiVersion = riru_api_version; riru_magisk_module_path = strdup(riru-\u003emagiskModulePath); if (riru_api_version \u003e= 25) { riru_allow_unload = riru-\u003eallowUnload; } return \u0026module; } #else RiruVersionedModuleInfo *init(Riru *riru) { static int step = 0; step += 1; switch (step) { case 1: { auto core_max_api_version = riru-\u003eriruApiVersion; riru_api_version = core_max_api_version \u003c= RIRU_MODULE_API_VERSION ? core_max_api_version : RIRU_MODULE_API_VERSION; if (riru_api_version \u003c 25) { module.moduleInfo.unused = (void *) shouldSkipUid; } else { riru_allow_unload = riru-\u003eallowUnload; } if (riru_api_version \u003e= 24) { module.moduleApiVersion = riru_api_version; riru_magisk_module_path = strdup(riru-\u003emagiskModulePath); return \u0026module; } else { return (RiruVersionedModuleInfo *) \u0026riru_api_version; } } case 2: { return (RiruVersionedModuleInfo *) \u0026module.moduleInfo; } case 3: default: { return nullptr; } } } #endif } 配置需要替换的函数 static auto module = RiruVersionedModuleInfo{ .moduleApiVersion = RIRU_MODULE_API_VERSION, .moduleInfo= RiruModuleInfo{ .supportHide = true, .version = RIRU_MODULE_VERSION, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; 主要是四个函数forkAndSpecializePre、forkAndSpecializePost、specializeAppProcessPre和specializeAppProcessPost 在zygote fork产生新进程前后做处理 1 forkAndSpecializePre在forck出一个新的子进程前被调用，处理工作如设置UID、GID、环境变量等等，选择在forkAndSpecializePre阶段做doUnshare处理也是防止进程正常启动后无法再改变namespace static void forkAndSpecializePre( JNIEnv *env, jclass clazz, jint *uid, jint *gid, jintArray *gids, jint *runtimeFlags, jobjectArray *rlimits, jint *mountExternal, jstring *seInfo, jstring *niceName, jintArray *fdsToClose, jintArray *fdsToIgnore, jboolean *is_child_zygote, jstring *instructionSet, jstring *appDataDir, jboolean *isTopApp, jobjectArray *pkgDataInfoList, jobjectArray *whitelistedDataInfoList, jboolean *bindMountAppDataDirs, jboolean *bindMountAppStorageDirs) { //应用启动前调用 doUnshare(env, uid, mountExternal, niceName, *is_child_zygote); } static void doUnshare(JNIEnv *env, jint *uid, jint *mountExternal, jstring *niceName, bool is_child_zygote) { //uid判断 if (shouldSkipUid(*uid)) return; // 改变mount状态 if (*mountExternal == 0) { *mountExternal = 1; ScopedUtfChars name(env, *niceName); is_app_zygote = is_child_zygote \u0026\u0026 is_app(*uid); nice_name_ = niceName; LOGI(\"unshare uid=%d name=%s app_zygote=%s\", *uid, name.c_str(), is_app_zygote?\"true\":\"false\"); } } static int shouldSkipUid(int uid) { int appid = uid % AID_USER_OFFSET; if (appid \u003e= AID_APP_START \u0026\u0026 appid \u003c= AID_APP_END) return false; if (appid \u003e= AID_ISOLATED_START \u0026\u0026 appid \u003c= AID_ISOLATED_END) return false; return true; } static bool is_app(int uid) { return uid%100000 \u003e= 10000 \u0026\u0026 uid%100000 \u003c= 19999; } 关键在于mountExternal这个参数的修改，那这个参数的作用是什么呢？从zygote源码中看看 private Process.ProcessStartResult startViaZygote(@NonNull final String processClass, @Nullable final String niceName, final int uid, final int gid, @Nullable final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, @Nullable String seInfo, @NonNull String abi, @Nullable String instructionSet, @Nullable String appDataDir, @Nullable String invokeWith, boolean startChildZygote, @Nullable String packageName, int zygotePolicyFlags, boolean isTopApp, @Nullable long[] disabledCompatChanges, @Nullable Map","date":"2023-07-04","objectID":"/riru-unshare%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru Unshare源码分析","uri":"/riru-unshare%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#3-specializeappprocesspre"},{"categories":["Magisk生态"],"content":" 二、源码分析riru-unshare是一个riru模块，看源码就从从main.cpp入手 #ifndef RIRU_MODULE_LEGACY_INIT RiruVersionedModuleInfo *init(Riru *riru) { auto core_max_api_version = riru-\u003eriruApiVersion; riru_api_version = core_max_api_version \u003c= RIRU_MODULE_API_VERSION ? core_max_api_version : RIRU_MODULE_API_VERSION; module.moduleApiVersion = riru_api_version; riru_magisk_module_path = strdup(riru-\u003emagiskModulePath); if (riru_api_version \u003e= 25) { riru_allow_unload = riru-\u003eallowUnload; } return \u0026module; } #else RiruVersionedModuleInfo *init(Riru *riru) { static int step = 0; step += 1; switch (step) { case 1: { auto core_max_api_version = riru-\u003eriruApiVersion; riru_api_version = core_max_api_version \u003c= RIRU_MODULE_API_VERSION ? core_max_api_version : RIRU_MODULE_API_VERSION; if (riru_api_version \u003c 25) { module.moduleInfo.unused = (void *) shouldSkipUid; } else { riru_allow_unload = riru-\u003eallowUnload; } if (riru_api_version \u003e= 24) { module.moduleApiVersion = riru_api_version; riru_magisk_module_path = strdup(riru-\u003emagiskModulePath); return \u0026module; } else { return (RiruVersionedModuleInfo *) \u0026riru_api_version; } } case 2: { return (RiruVersionedModuleInfo *) \u0026module.moduleInfo; } case 3: default: { return nullptr; } } } #endif } 配置需要替换的函数 static auto module = RiruVersionedModuleInfo{ .moduleApiVersion = RIRU_MODULE_API_VERSION, .moduleInfo= RiruModuleInfo{ .supportHide = true, .version = RIRU_MODULE_VERSION, .versionName = RIRU_MODULE_VERSION_NAME, .onModuleLoaded = nullptr, .forkAndSpecializePre = forkAndSpecializePre, .forkAndSpecializePost = forkAndSpecializePost, .forkSystemServerPre = nullptr, .forkSystemServerPost = nullptr, .specializeAppProcessPre = specializeAppProcessPre, .specializeAppProcessPost = specializeAppProcessPost } }; 主要是四个函数forkAndSpecializePre、forkAndSpecializePost、specializeAppProcessPre和specializeAppProcessPost 在zygote fork产生新进程前后做处理 1 forkAndSpecializePre在forck出一个新的子进程前被调用，处理工作如设置UID、GID、环境变量等等，选择在forkAndSpecializePre阶段做doUnshare处理也是防止进程正常启动后无法再改变namespace static void forkAndSpecializePre( JNIEnv *env, jclass clazz, jint *uid, jint *gid, jintArray *gids, jint *runtimeFlags, jobjectArray *rlimits, jint *mountExternal, jstring *seInfo, jstring *niceName, jintArray *fdsToClose, jintArray *fdsToIgnore, jboolean *is_child_zygote, jstring *instructionSet, jstring *appDataDir, jboolean *isTopApp, jobjectArray *pkgDataInfoList, jobjectArray *whitelistedDataInfoList, jboolean *bindMountAppDataDirs, jboolean *bindMountAppStorageDirs) { //应用启动前调用 doUnshare(env, uid, mountExternal, niceName, *is_child_zygote); } static void doUnshare(JNIEnv *env, jint *uid, jint *mountExternal, jstring *niceName, bool is_child_zygote) { //uid判断 if (shouldSkipUid(*uid)) return; // 改变mount状态 if (*mountExternal == 0) { *mountExternal = 1; ScopedUtfChars name(env, *niceName); is_app_zygote = is_child_zygote \u0026\u0026 is_app(*uid); nice_name_ = niceName; LOGI(\"unshare uid=%d name=%s app_zygote=%s\", *uid, name.c_str(), is_app_zygote?\"true\":\"false\"); } } static int shouldSkipUid(int uid) { int appid = uid % AID_USER_OFFSET; if (appid \u003e= AID_APP_START \u0026\u0026 appid \u003c= AID_APP_END) return false; if (appid \u003e= AID_ISOLATED_START \u0026\u0026 appid \u003c= AID_ISOLATED_END) return false; return true; } static bool is_app(int uid) { return uid%100000 \u003e= 10000 \u0026\u0026 uid%100000 \u003c= 19999; } 关键在于mountExternal这个参数的修改，那这个参数的作用是什么呢？从zygote源码中看看 private Process.ProcessStartResult startViaZygote(@NonNull final String processClass, @Nullable final String niceName, final int uid, final int gid, @Nullable final int[] gids, int runtimeFlags, int mountExternal, int targetSdkVersion, @Nullable String seInfo, @NonNull String abi, @Nullable String instructionSet, @Nullable String appDataDir, @Nullable String invokeWith, boolean startChildZygote, @Nullable String packageName, int zygotePolicyFlags, boolean isTopApp, @Nullable long[] disabledCompatChanges, @Nullable Map","date":"2023-07-04","objectID":"/riru-unshare%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/:0:2","series":null,"tags":["Magisk Hide隐藏"],"title":"Riru Unshare源码分析","uri":"/riru-unshare%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#4-specializeappprocesspost"},{"categories":["系统定制"],"content":" 前言涉及到需要隐藏设备特征，所以需要编译内核来抹除暴露出的特征。小米内核有现成的源码，可以根据自身设备的型号来选择，下面简单描述下编译流程 ","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:1","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#前言"},{"categories":["系统定制"],"content":" 一、编译环境搭建 1 物料准备 设备：红米note11（MIUI12 Android11） 源码：selene版本内核源码 需要注意的是note11(selenes)是国内的叫法，而国际版对应的是红米10(selene) 原生boot.img镜像文件，参考下载网站 2 工具准备 编译支撑系统：ubuntu18 参照官方文档的版本来的，不过经过测试，使用ubuntu14的话会导致某些三方库安装失败 三方库预装 sudo apt-get install git ccache automake flex lzop bison \\ gperf build-essential zip curl zlib1g-dev zlib1g-dev:i386 \\ g++-multilib python-networkx libxml2-utils bzip2 libbz2-dev \\ libbz2-1.0 libghc-bzlib-dev squashfs-tools pngcrush \\ schedtool dpkg-dev liblz4-tool make optipng maven libssl-dev \\ pwgen libswitch-perl policycoreutils minicom libxml-sax-base-perl \\ libxml-simple-perl bc libc6-dev-i386 lib32ncurses5-dev \\ x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev xsltproc unzip 编译工具链准备 clang：c/c++编译工具 lineage：交叉编译工具 一键编译脚本 CLANG_BIN=\"clang-r383902/bin\" //需要需要路径 GCC_BIN=\"android_prebuilts_gcc_linux-x86_aarch64_aarch64-linux-android-4.9-lineage-19.1/bin\" //需要需要路径 export PATH=\"$CLANG_BIN:$GCC_BIN:$PATH\" export PLATFORM_VERSION=11.0 ARCH=arm64 make CC=clang HOSTCC=gcc AR=llvm-ar NM=llvm-nm OBJCOPY=llvm-objcopy OBJDUMP=llvm-objdump STRIP=llvm-strip O=out CLANG_TRIPLE=aarch64-linux-gnu- CROSS_COMPILE=aarch64-linux-androidkernel- LD=ld.lld selene_defconfig ARCH=arm64 make CC=clang HOSTCC=gcc AR=llvm-ar NM=llvm-nm OBJCOPY=llvm-objcopy OBJDUMP=llvm-objdump STRIP=llvm-strip O=out CLANG_TRIPLE=aarch64-linux-gnu- CROSS_COMPILE=aarch64-linux-androidkernel- LD=ld.lld -j 6 boot.img解包打开工具 Android_boot_image_editor ","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:2","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#一编译环境搭建"},{"categories":["系统定制"],"content":" 一、编译环境搭建 1 物料准备 设备：红米note11（MIUI12 Android11） 源码：selene版本内核源码 需要注意的是note11(selenes)是国内的叫法，而国际版对应的是红米10(selene) 原生boot.img镜像文件，参考下载网站 2 工具准备 编译支撑系统：ubuntu18 参照官方文档的版本来的，不过经过测试，使用ubuntu14的话会导致某些三方库安装失败 三方库预装 sudo apt-get install git ccache automake flex lzop bison \\ gperf build-essential zip curl zlib1g-dev zlib1g-dev:i386 \\ g++-multilib python-networkx libxml2-utils bzip2 libbz2-dev \\ libbz2-1.0 libghc-bzlib-dev squashfs-tools pngcrush \\ schedtool dpkg-dev liblz4-tool make optipng maven libssl-dev \\ pwgen libswitch-perl policycoreutils minicom libxml-sax-base-perl \\ libxml-simple-perl bc libc6-dev-i386 lib32ncurses5-dev \\ x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev xsltproc unzip 编译工具链准备 clang：c/c++编译工具 lineage：交叉编译工具 一键编译脚本 CLANG_BIN=\"clang-r383902/bin\" //需要需要路径 GCC_BIN=\"android_prebuilts_gcc_linux-x86_aarch64_aarch64-linux-android-4.9-lineage-19.1/bin\" //需要需要路径 export PATH=\"$CLANG_BIN:$GCC_BIN:$PATH\" export PLATFORM_VERSION=11.0 ARCH=arm64 make CC=clang HOSTCC=gcc AR=llvm-ar NM=llvm-nm OBJCOPY=llvm-objcopy OBJDUMP=llvm-objdump STRIP=llvm-strip O=out CLANG_TRIPLE=aarch64-linux-gnu- CROSS_COMPILE=aarch64-linux-androidkernel- LD=ld.lld selene_defconfig ARCH=arm64 make CC=clang HOSTCC=gcc AR=llvm-ar NM=llvm-nm OBJCOPY=llvm-objcopy OBJDUMP=llvm-objdump STRIP=llvm-strip O=out CLANG_TRIPLE=aarch64-linux-gnu- CROSS_COMPILE=aarch64-linux-androidkernel- LD=ld.lld -j 6 boot.img解包打开工具 Android_boot_image_editor ","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:2","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#1-物料准备"},{"categories":["系统定制"],"content":" 一、编译环境搭建 1 物料准备 设备：红米note11（MIUI12 Android11） 源码：selene版本内核源码 需要注意的是note11(selenes)是国内的叫法，而国际版对应的是红米10(selene) 原生boot.img镜像文件，参考下载网站 2 工具准备 编译支撑系统：ubuntu18 参照官方文档的版本来的，不过经过测试，使用ubuntu14的话会导致某些三方库安装失败 三方库预装 sudo apt-get install git ccache automake flex lzop bison \\ gperf build-essential zip curl zlib1g-dev zlib1g-dev:i386 \\ g++-multilib python-networkx libxml2-utils bzip2 libbz2-dev \\ libbz2-1.0 libghc-bzlib-dev squashfs-tools pngcrush \\ schedtool dpkg-dev liblz4-tool make optipng maven libssl-dev \\ pwgen libswitch-perl policycoreutils minicom libxml-sax-base-perl \\ libxml-simple-perl bc libc6-dev-i386 lib32ncurses5-dev \\ x11proto-core-dev libx11-dev lib32z-dev libgl1-mesa-dev xsltproc unzip 编译工具链准备 clang：c/c++编译工具 lineage：交叉编译工具 一键编译脚本 CLANG_BIN=\"clang-r383902/bin\" //需要需要路径 GCC_BIN=\"android_prebuilts_gcc_linux-x86_aarch64_aarch64-linux-android-4.9-lineage-19.1/bin\" //需要需要路径 export PATH=\"$CLANG_BIN:$GCC_BIN:$PATH\" export PLATFORM_VERSION=11.0 ARCH=arm64 make CC=clang HOSTCC=gcc AR=llvm-ar NM=llvm-nm OBJCOPY=llvm-objcopy OBJDUMP=llvm-objdump STRIP=llvm-strip O=out CLANG_TRIPLE=aarch64-linux-gnu- CROSS_COMPILE=aarch64-linux-androidkernel- LD=ld.lld selene_defconfig ARCH=arm64 make CC=clang HOSTCC=gcc AR=llvm-ar NM=llvm-nm OBJCOPY=llvm-objcopy OBJDUMP=llvm-objdump STRIP=llvm-strip O=out CLANG_TRIPLE=aarch64-linux-gnu- CROSS_COMPILE=aarch64-linux-androidkernel- LD=ld.lld -j 6 boot.img解包打开工具 Android_boot_image_editor ","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:2","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#2-工具准备"},{"categories":["系统定制"],"content":" 二、编译错误修复 1 文件缺失错误提示如下 ../drivers/input/touchscreen/mediatek/FT8719P/focaltech_flash.c:60:10: fatal error: 'include/firmware/fw_sample.i' file not found 在drivers/input/touchscreen/mediatek/focaltech_touch/include/firmware目录下添加fw_sample.i文件 fw_sample.i文件内容从fw_sample.i中复制 2 方法重复定义错误提示如下 ld.lld: error: duplicate symbol: mtk_vcu_mem_init \u003e\u003e\u003e defined at mtk_vcodec_mem.c:29 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:29) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_mem_init) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:29 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:29) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x0) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_mem_release \u003e\u003e\u003e defined at mtk_vcodec_mem.c:53 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:53) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_mem_release) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:53 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:53) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0xBC) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_set_buffer \u003e\u003e\u003e defined at mtk_vcodec_mem.c:100 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:100) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_set_buffer) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:100 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:100) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x24C) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_get_buffer \u003e\u003e\u003e defined at mtk_vcodec_mem.c:184 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:184) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_get_buffer) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:184 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:184) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x5D0) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_get_page \u003e\u003e\u003e defined at slab.h:522 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../include/linux/slab.h:522) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_get_page) in archive built-in.o \u003e\u003e\u003e defined at slab.h:522 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../include/linux/slab.h:522) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x748) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_free_buffer \u003e\u003e\u003e defined at mtk_vcodec_mem.c:251 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:251) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_free_buffer) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:251 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:251) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x850) in archive built-in.o 修改参考：重复定义异常 3 驱动文件缺失原因是未加载wlan相关的驱动，官方代码只是内核相关的，需要将wlan驱动内嵌到内核源码中 修改参考：驱动异常 复制到Xiaomi_Kernel_OpenSource/drivers/misc/mediatek/connectivity这个目录下面，并且修改connectivity里面的Kconfig文件，增加启用模块编译 config WLAN_DRV_BUILD_IN bool \"Build Wlan module in kernel\" default y //默认启用 help This will build the wlan driver and the corresponding componenets into the kernel. If unsure say n ","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:3","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#二编译错误修复"},{"categories":["系统定制"],"content":" 二、编译错误修复 1 文件缺失错误提示如下 ../drivers/input/touchscreen/mediatek/FT8719P/focaltech_flash.c:60:10: fatal error: 'include/firmware/fw_sample.i' file not found 在drivers/input/touchscreen/mediatek/focaltech_touch/include/firmware目录下添加fw_sample.i文件 fw_sample.i文件内容从fw_sample.i中复制 2 方法重复定义错误提示如下 ld.lld: error: duplicate symbol: mtk_vcu_mem_init \u003e\u003e\u003e defined at mtk_vcodec_mem.c:29 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:29) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_mem_init) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:29 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:29) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x0) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_mem_release \u003e\u003e\u003e defined at mtk_vcodec_mem.c:53 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:53) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_mem_release) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:53 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:53) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0xBC) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_set_buffer \u003e\u003e\u003e defined at mtk_vcodec_mem.c:100 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:100) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_set_buffer) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:100 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:100) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x24C) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_get_buffer \u003e\u003e\u003e defined at mtk_vcodec_mem.c:184 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:184) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_get_buffer) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:184 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:184) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x5D0) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_get_page \u003e\u003e\u003e defined at slab.h:522 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../include/linux/slab.h:522) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_get_page) in archive built-in.o \u003e\u003e\u003e defined at slab.h:522 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../include/linux/slab.h:522) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x748) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_free_buffer \u003e\u003e\u003e defined at mtk_vcodec_mem.c:251 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:251) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_free_buffer) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:251 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:251) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x850) in archive built-in.o 修改参考：重复定义异常 3 驱动文件缺失原因是未加载wlan相关的驱动，官方代码只是内核相关的，需要将wlan驱动内嵌到内核源码中 修改参考：驱动异常 复制到Xiaomi_Kernel_OpenSource/drivers/misc/mediatek/connectivity这个目录下面，并且修改connectivity里面的Kconfig文件，增加启用模块编译 config WLAN_DRV_BUILD_IN bool \"Build Wlan module in kernel\" default y //默认启用 help This will build the wlan driver and the corresponding componenets into the kernel. If unsure say n ","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:3","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#1-文件缺失"},{"categories":["系统定制"],"content":" 二、编译错误修复 1 文件缺失错误提示如下 ../drivers/input/touchscreen/mediatek/FT8719P/focaltech_flash.c:60:10: fatal error: 'include/firmware/fw_sample.i' file not found 在drivers/input/touchscreen/mediatek/focaltech_touch/include/firmware目录下添加fw_sample.i文件 fw_sample.i文件内容从fw_sample.i中复制 2 方法重复定义错误提示如下 ld.lld: error: duplicate symbol: mtk_vcu_mem_init \u003e\u003e\u003e defined at mtk_vcodec_mem.c:29 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:29) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_mem_init) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:29 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:29) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x0) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_mem_release \u003e\u003e\u003e defined at mtk_vcodec_mem.c:53 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:53) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_mem_release) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:53 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:53) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0xBC) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_set_buffer \u003e\u003e\u003e defined at mtk_vcodec_mem.c:100 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:100) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_set_buffer) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:100 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:100) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x24C) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_get_buffer \u003e\u003e\u003e defined at mtk_vcodec_mem.c:184 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:184) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_get_buffer) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:184 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:184) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x5D0) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_get_page \u003e\u003e\u003e defined at slab.h:522 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../include/linux/slab.h:522) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_get_page) in archive built-in.o \u003e\u003e\u003e defined at slab.h:522 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../include/linux/slab.h:522) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x748) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_free_buffer \u003e\u003e\u003e defined at mtk_vcodec_mem.c:251 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:251) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_free_buffer) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:251 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:251) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x850) in archive built-in.o 修改参考：重复定义异常 3 驱动文件缺失原因是未加载wlan相关的驱动，官方代码只是内核相关的，需要将wlan驱动内嵌到内核源码中 修改参考：驱动异常 复制到Xiaomi_Kernel_OpenSource/drivers/misc/mediatek/connectivity这个目录下面，并且修改connectivity里面的Kconfig文件，增加启用模块编译 config WLAN_DRV_BUILD_IN bool \"Build Wlan module in kernel\" default y //默认启用 help This will build the wlan driver and the corresponding componenets into the kernel. If unsure say n ","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:3","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#2-方法重复定义"},{"categories":["系统定制"],"content":" 二、编译错误修复 1 文件缺失错误提示如下 ../drivers/input/touchscreen/mediatek/FT8719P/focaltech_flash.c:60:10: fatal error: 'include/firmware/fw_sample.i' file not found 在drivers/input/touchscreen/mediatek/focaltech_touch/include/firmware目录下添加fw_sample.i文件 fw_sample.i文件内容从fw_sample.i中复制 2 方法重复定义错误提示如下 ld.lld: error: duplicate symbol: mtk_vcu_mem_init \u003e\u003e\u003e defined at mtk_vcodec_mem.c:29 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:29) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_mem_init) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:29 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:29) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x0) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_mem_release \u003e\u003e\u003e defined at mtk_vcodec_mem.c:53 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:53) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_mem_release) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:53 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:53) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0xBC) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_set_buffer \u003e\u003e\u003e defined at mtk_vcodec_mem.c:100 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:100) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_set_buffer) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:100 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:100) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x24C) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_get_buffer \u003e\u003e\u003e defined at mtk_vcodec_mem.c:184 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:184) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_get_buffer) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:184 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:184) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x5D0) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_get_page \u003e\u003e\u003e defined at slab.h:522 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../include/linux/slab.h:522) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_get_page) in archive built-in.o \u003e\u003e\u003e defined at slab.h:522 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../include/linux/slab.h:522) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x748) in archive built-in.o ld.lld: error: duplicate symbol: mtk_vcu_free_buffer \u003e\u003e\u003e defined at mtk_vcodec_mem.c:251 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:251) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(mtk_vcu_free_buffer) in archive built-in.o \u003e\u003e\u003e defined at mtk_vcodec_mem.c:251 (/home/linhanqiu/proj/Xiaomi_Kernel_OpenSource/out/../drivers/media/platform/mtk-vcu/mtk_vcodec_mem.c:251) \u003e\u003e\u003e drivers/media/platform/mtk-vcu/mtk_vcodec_mem.o:(.text+0x850) in archive built-in.o 修改参考：重复定义异常 3 驱动文件缺失原因是未加载wlan相关的驱动，官方代码只是内核相关的，需要将wlan驱动内嵌到内核源码中 修改参考：驱动异常 复制到Xiaomi_Kernel_OpenSource/drivers/misc/mediatek/connectivity这个目录下面，并且修改connectivity里面的Kconfig文件，增加启用模块编译 config WLAN_DRV_BUILD_IN bool \"Build Wlan module in kernel\" default y //默认启用 help This will build the wlan driver and the corresponding componenets into the kernel. If unsure say n ","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:3","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#3-驱动文件缺失"},{"categories":["系统定制"],"content":" 三、正式编译与boot重打包将上面的环境、工具以及修复后的源码准备好就可以正式开始编译了，编译的产物是内核，而最终刷入系统的boot.img，因此整个流程大致可以看成如下： boot.img解包-\u003e内核编译-\u003e内核替换-\u003eboot.img重打包 1 boot.img解包使用Android_boot_image_editor来处理解包打包，先把boot.img放在在Android_boot_image_editor目录下后执行./gradlew unpack命令，下面是输出结果 Starting a Gradle Daemon (subsequent builds will be faster) \u003e Task :unpack 20:00:53.716 [main] WARN cfig.packable.PackableLauncher - [boot.img] will be handled by [BootImgParser] 20:00:53.817 [main] WARN cfig.packable.PackableLauncher - 'unpack' sequence initialized 20:00:53.820 [main] INFO cfig.packable.IPackable - deleting build/unzip_boot/ ... 20:00:54.190 [main] INFO Helper - deleting uiderrors 20:00:54.198 [main] INFO cfig.packable.BootImgParser - header version 2 20:00:54.397 [main] WARN cfig.bootimg.v2.BootHeaderV2 - BootImgHeader constructor 20:00:54.417 [main] INFO cfig.Avb - python aosp/avb/avbtool.v1.2.py verify_image --image boot.img Verifying image boot.img using embedded public key vbmeta: Successfully verified footer and SHA256_RSA2048 vbmeta struct in boot.img boot: Successfully verified sha256 hash of boot.img for image of 30773248 bytes 20:00:55.460 [main] INFO KernelExtractor - [aosp/make/tools/extract_kernel.py, --input, build/unzip_boot/kernel, --output-configs, build/unzip_boot/kernel_configs.txt, --output-version, build/unzip_boot/kernel_version.txt] 20:00:55.464 [main] INFO KernelExtractor - kernel version: [4.14.186] 20:00:55.464 [main] INFO KernelExtractor - kernel config dumped to : build/unzip_boot/kernel_configs.txt 20:00:56.329 [main] INFO ZipHelper - decompress(gz) done: build/unzip_boot/ramdisk.img.gz -\u003e build/unzip_boot/ramdisk.img 20:00:56.332 [main] INFO cfig.bootimg.cpio.AndroidCpio - Cleaning /Users/linhanqiu/Projects/Android_boot_image_editor/build/unzip_boot/root ... 20:00:56.358 [main] WARN cfig.bootimg.cpio.AndroidCpio - root/config has improper file mode 555, fix it 20:00:57.293 [main] WARN cfig.bootimg.cpio.AndroidCpio - root/system/bin/logd has improper file mode 550, fix it 20:00:57.629 [main] INFO cfig.bootimg.cpio.AndroidCpio - cpio trailer found, mode=000001ed 20:00:57.631 [main] INFO cfig.bootimg.Common - ramdisk extracted : build/unzip_boot/ramdisk.img -\u003e build/unzip_boot/root 20:00:57.647 [main] INFO cfig.utils.DTC - parsing DTB: build/unzip_boot/dtb FATAL ERROR: Blob has incorrect magic number 20:00:57.683 [main] ERROR cfig.utils.DTC - can not parse DTB: build/unzip_boot/dtb 20:00:57.687 [main] INFO avb.AVBInfo - parseFrom(FILE:boot.img) ... 20:00:57.723 [main] INFO avb.AVBInfo - FILE:boot.img: Glance(footer=Footer(versionMajor=1, versionMinor=0, originalImageSize=30773248, vbMetaOffset=30773248, vbMetaSize=1600), vbMetaOffset=30773248).footer 20:00:57.837 [main] INFO avb.AVBInfo - VBMeta: boot.img -\u003e build/unzip_boot/boot.avb.json 20:00:58.013 [main] INFO cfig.Avb - signed with release key: 'Xiaomi Phone' by Mi 20:00:58.028 [main] WARN cfig.Avb - Found key: PublicKey(device='Xiaomi Phone' by 'Mi', algorithm='SHA256_RSA2048', sha1='b2a02f1e56e366d727a1a8e089762fe0b91bbc84') 20:00:58.079 [main] INFO cfig.bootimg.v2.BootV2 - Unpack Summary of boot.img ┌───────────────────────────────────────┬──────────────────────────────────────┐ │What │Where │ └───────────────────────────────────────┴──────────────────────────────────────┘ ┌───────────────────────────────────────┬──────────────────────────────────────┐ │image info │build/unzip_boot/boot.json │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │AVB info [verified] │build/unzip_boot/boot.avb.json │ │\\-- signing key │Xiaomi Phone by Mi │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │kernel │build/unzip_boot/kernel │ │\\-- version [4.14.186] │build/unzip_boot/kernel_version.txt │ │\\-- config │build/unzip_boot/kernel_configs.txt │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │ramdisk │build/unzip_boot/ramdisk.img.gz │ │\\-- extracted ramdisk rootfs │build/unzip_boot/root │ ├────────────────────","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:4","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#三正式编译与boot重打包"},{"categories":["系统定制"],"content":" 三、正式编译与boot重打包将上面的环境、工具以及修复后的源码准备好就可以正式开始编译了，编译的产物是内核，而最终刷入系统的boot.img，因此整个流程大致可以看成如下： boot.img解包-\u003e内核编译-\u003e内核替换-\u003eboot.img重打包 1 boot.img解包使用Android_boot_image_editor来处理解包打包，先把boot.img放在在Android_boot_image_editor目录下后执行./gradlew unpack命令，下面是输出结果 Starting a Gradle Daemon (subsequent builds will be faster) \u003e Task :unpack 20:00:53.716 [main] WARN cfig.packable.PackableLauncher - [boot.img] will be handled by [BootImgParser] 20:00:53.817 [main] WARN cfig.packable.PackableLauncher - 'unpack' sequence initialized 20:00:53.820 [main] INFO cfig.packable.IPackable - deleting build/unzip_boot/ ... 20:00:54.190 [main] INFO Helper - deleting uiderrors 20:00:54.198 [main] INFO cfig.packable.BootImgParser - header version 2 20:00:54.397 [main] WARN cfig.bootimg.v2.BootHeaderV2 - BootImgHeader constructor 20:00:54.417 [main] INFO cfig.Avb - python aosp/avb/avbtool.v1.2.py verify_image --image boot.img Verifying image boot.img using embedded public key vbmeta: Successfully verified footer and SHA256_RSA2048 vbmeta struct in boot.img boot: Successfully verified sha256 hash of boot.img for image of 30773248 bytes 20:00:55.460 [main] INFO KernelExtractor - [aosp/make/tools/extract_kernel.py, --input, build/unzip_boot/kernel, --output-configs, build/unzip_boot/kernel_configs.txt, --output-version, build/unzip_boot/kernel_version.txt] 20:00:55.464 [main] INFO KernelExtractor - kernel version: [4.14.186] 20:00:55.464 [main] INFO KernelExtractor - kernel config dumped to : build/unzip_boot/kernel_configs.txt 20:00:56.329 [main] INFO ZipHelper - decompress(gz) done: build/unzip_boot/ramdisk.img.gz -\u003e build/unzip_boot/ramdisk.img 20:00:56.332 [main] INFO cfig.bootimg.cpio.AndroidCpio - Cleaning /Users/linhanqiu/Projects/Android_boot_image_editor/build/unzip_boot/root ... 20:00:56.358 [main] WARN cfig.bootimg.cpio.AndroidCpio - root/config has improper file mode 555, fix it 20:00:57.293 [main] WARN cfig.bootimg.cpio.AndroidCpio - root/system/bin/logd has improper file mode 550, fix it 20:00:57.629 [main] INFO cfig.bootimg.cpio.AndroidCpio - cpio trailer found, mode=000001ed 20:00:57.631 [main] INFO cfig.bootimg.Common - ramdisk extracted : build/unzip_boot/ramdisk.img -\u003e build/unzip_boot/root 20:00:57.647 [main] INFO cfig.utils.DTC - parsing DTB: build/unzip_boot/dtb FATAL ERROR: Blob has incorrect magic number 20:00:57.683 [main] ERROR cfig.utils.DTC - can not parse DTB: build/unzip_boot/dtb 20:00:57.687 [main] INFO avb.AVBInfo - parseFrom(FILE:boot.img) ... 20:00:57.723 [main] INFO avb.AVBInfo - FILE:boot.img: Glance(footer=Footer(versionMajor=1, versionMinor=0, originalImageSize=30773248, vbMetaOffset=30773248, vbMetaSize=1600), vbMetaOffset=30773248).footer 20:00:57.837 [main] INFO avb.AVBInfo - VBMeta: boot.img -\u003e build/unzip_boot/boot.avb.json 20:00:58.013 [main] INFO cfig.Avb - signed with release key: 'Xiaomi Phone' by Mi 20:00:58.028 [main] WARN cfig.Avb - Found key: PublicKey(device='Xiaomi Phone' by 'Mi', algorithm='SHA256_RSA2048', sha1='b2a02f1e56e366d727a1a8e089762fe0b91bbc84') 20:00:58.079 [main] INFO cfig.bootimg.v2.BootV2 - Unpack Summary of boot.img ┌───────────────────────────────────────┬──────────────────────────────────────┐ │What │Where │ └───────────────────────────────────────┴──────────────────────────────────────┘ ┌───────────────────────────────────────┬──────────────────────────────────────┐ │image info │build/unzip_boot/boot.json │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │AVB info [verified] │build/unzip_boot/boot.avb.json │ │\\-- signing key │Xiaomi Phone by Mi │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │kernel │build/unzip_boot/kernel │ │\\-- version [4.14.186] │build/unzip_boot/kernel_version.txt │ │\\-- config │build/unzip_boot/kernel_configs.txt │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │ramdisk │build/unzip_boot/ramdisk.img.gz │ │\\-- extracted ramdisk rootfs │build/unzip_boot/root │ ├────────────────────","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:4","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#1-bootimg解包"},{"categories":["系统定制"],"content":" 三、正式编译与boot重打包将上面的环境、工具以及修复后的源码准备好就可以正式开始编译了，编译的产物是内核，而最终刷入系统的boot.img，因此整个流程大致可以看成如下： boot.img解包-\u003e内核编译-\u003e内核替换-\u003eboot.img重打包 1 boot.img解包使用Android_boot_image_editor来处理解包打包，先把boot.img放在在Android_boot_image_editor目录下后执行./gradlew unpack命令，下面是输出结果 Starting a Gradle Daemon (subsequent builds will be faster) \u003e Task :unpack 20:00:53.716 [main] WARN cfig.packable.PackableLauncher - [boot.img] will be handled by [BootImgParser] 20:00:53.817 [main] WARN cfig.packable.PackableLauncher - 'unpack' sequence initialized 20:00:53.820 [main] INFO cfig.packable.IPackable - deleting build/unzip_boot/ ... 20:00:54.190 [main] INFO Helper - deleting uiderrors 20:00:54.198 [main] INFO cfig.packable.BootImgParser - header version 2 20:00:54.397 [main] WARN cfig.bootimg.v2.BootHeaderV2 - BootImgHeader constructor 20:00:54.417 [main] INFO cfig.Avb - python aosp/avb/avbtool.v1.2.py verify_image --image boot.img Verifying image boot.img using embedded public key vbmeta: Successfully verified footer and SHA256_RSA2048 vbmeta struct in boot.img boot: Successfully verified sha256 hash of boot.img for image of 30773248 bytes 20:00:55.460 [main] INFO KernelExtractor - [aosp/make/tools/extract_kernel.py, --input, build/unzip_boot/kernel, --output-configs, build/unzip_boot/kernel_configs.txt, --output-version, build/unzip_boot/kernel_version.txt] 20:00:55.464 [main] INFO KernelExtractor - kernel version: [4.14.186] 20:00:55.464 [main] INFO KernelExtractor - kernel config dumped to : build/unzip_boot/kernel_configs.txt 20:00:56.329 [main] INFO ZipHelper - decompress(gz) done: build/unzip_boot/ramdisk.img.gz -\u003e build/unzip_boot/ramdisk.img 20:00:56.332 [main] INFO cfig.bootimg.cpio.AndroidCpio - Cleaning /Users/linhanqiu/Projects/Android_boot_image_editor/build/unzip_boot/root ... 20:00:56.358 [main] WARN cfig.bootimg.cpio.AndroidCpio - root/config has improper file mode 555, fix it 20:00:57.293 [main] WARN cfig.bootimg.cpio.AndroidCpio - root/system/bin/logd has improper file mode 550, fix it 20:00:57.629 [main] INFO cfig.bootimg.cpio.AndroidCpio - cpio trailer found, mode=000001ed 20:00:57.631 [main] INFO cfig.bootimg.Common - ramdisk extracted : build/unzip_boot/ramdisk.img -\u003e build/unzip_boot/root 20:00:57.647 [main] INFO cfig.utils.DTC - parsing DTB: build/unzip_boot/dtb FATAL ERROR: Blob has incorrect magic number 20:00:57.683 [main] ERROR cfig.utils.DTC - can not parse DTB: build/unzip_boot/dtb 20:00:57.687 [main] INFO avb.AVBInfo - parseFrom(FILE:boot.img) ... 20:00:57.723 [main] INFO avb.AVBInfo - FILE:boot.img: Glance(footer=Footer(versionMajor=1, versionMinor=0, originalImageSize=30773248, vbMetaOffset=30773248, vbMetaSize=1600), vbMetaOffset=30773248).footer 20:00:57.837 [main] INFO avb.AVBInfo - VBMeta: boot.img -\u003e build/unzip_boot/boot.avb.json 20:00:58.013 [main] INFO cfig.Avb - signed with release key: 'Xiaomi Phone' by Mi 20:00:58.028 [main] WARN cfig.Avb - Found key: PublicKey(device='Xiaomi Phone' by 'Mi', algorithm='SHA256_RSA2048', sha1='b2a02f1e56e366d727a1a8e089762fe0b91bbc84') 20:00:58.079 [main] INFO cfig.bootimg.v2.BootV2 - Unpack Summary of boot.img ┌───────────────────────────────────────┬──────────────────────────────────────┐ │What │Where │ └───────────────────────────────────────┴──────────────────────────────────────┘ ┌───────────────────────────────────────┬──────────────────────────────────────┐ │image info │build/unzip_boot/boot.json │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │AVB info [verified] │build/unzip_boot/boot.avb.json │ │\\-- signing key │Xiaomi Phone by Mi │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │kernel │build/unzip_boot/kernel │ │\\-- version [4.14.186] │build/unzip_boot/kernel_version.txt │ │\\-- config │build/unzip_boot/kernel_configs.txt │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │ramdisk │build/unzip_boot/ramdisk.img.gz │ │\\-- extracted ramdisk rootfs │build/unzip_boot/root │ ├────────────────────","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:4","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#2-内核编译"},{"categories":["系统定制"],"content":" 三、正式编译与boot重打包将上面的环境、工具以及修复后的源码准备好就可以正式开始编译了，编译的产物是内核，而最终刷入系统的boot.img，因此整个流程大致可以看成如下： boot.img解包-\u003e内核编译-\u003e内核替换-\u003eboot.img重打包 1 boot.img解包使用Android_boot_image_editor来处理解包打包，先把boot.img放在在Android_boot_image_editor目录下后执行./gradlew unpack命令，下面是输出结果 Starting a Gradle Daemon (subsequent builds will be faster) \u003e Task :unpack 20:00:53.716 [main] WARN cfig.packable.PackableLauncher - [boot.img] will be handled by [BootImgParser] 20:00:53.817 [main] WARN cfig.packable.PackableLauncher - 'unpack' sequence initialized 20:00:53.820 [main] INFO cfig.packable.IPackable - deleting build/unzip_boot/ ... 20:00:54.190 [main] INFO Helper - deleting uiderrors 20:00:54.198 [main] INFO cfig.packable.BootImgParser - header version 2 20:00:54.397 [main] WARN cfig.bootimg.v2.BootHeaderV2 - BootImgHeader constructor 20:00:54.417 [main] INFO cfig.Avb - python aosp/avb/avbtool.v1.2.py verify_image --image boot.img Verifying image boot.img using embedded public key vbmeta: Successfully verified footer and SHA256_RSA2048 vbmeta struct in boot.img boot: Successfully verified sha256 hash of boot.img for image of 30773248 bytes 20:00:55.460 [main] INFO KernelExtractor - [aosp/make/tools/extract_kernel.py, --input, build/unzip_boot/kernel, --output-configs, build/unzip_boot/kernel_configs.txt, --output-version, build/unzip_boot/kernel_version.txt] 20:00:55.464 [main] INFO KernelExtractor - kernel version: [4.14.186] 20:00:55.464 [main] INFO KernelExtractor - kernel config dumped to : build/unzip_boot/kernel_configs.txt 20:00:56.329 [main] INFO ZipHelper - decompress(gz) done: build/unzip_boot/ramdisk.img.gz -\u003e build/unzip_boot/ramdisk.img 20:00:56.332 [main] INFO cfig.bootimg.cpio.AndroidCpio - Cleaning /Users/linhanqiu/Projects/Android_boot_image_editor/build/unzip_boot/root ... 20:00:56.358 [main] WARN cfig.bootimg.cpio.AndroidCpio - root/config has improper file mode 555, fix it 20:00:57.293 [main] WARN cfig.bootimg.cpio.AndroidCpio - root/system/bin/logd has improper file mode 550, fix it 20:00:57.629 [main] INFO cfig.bootimg.cpio.AndroidCpio - cpio trailer found, mode=000001ed 20:00:57.631 [main] INFO cfig.bootimg.Common - ramdisk extracted : build/unzip_boot/ramdisk.img -\u003e build/unzip_boot/root 20:00:57.647 [main] INFO cfig.utils.DTC - parsing DTB: build/unzip_boot/dtb FATAL ERROR: Blob has incorrect magic number 20:00:57.683 [main] ERROR cfig.utils.DTC - can not parse DTB: build/unzip_boot/dtb 20:00:57.687 [main] INFO avb.AVBInfo - parseFrom(FILE:boot.img) ... 20:00:57.723 [main] INFO avb.AVBInfo - FILE:boot.img: Glance(footer=Footer(versionMajor=1, versionMinor=0, originalImageSize=30773248, vbMetaOffset=30773248, vbMetaSize=1600), vbMetaOffset=30773248).footer 20:00:57.837 [main] INFO avb.AVBInfo - VBMeta: boot.img -\u003e build/unzip_boot/boot.avb.json 20:00:58.013 [main] INFO cfig.Avb - signed with release key: 'Xiaomi Phone' by Mi 20:00:58.028 [main] WARN cfig.Avb - Found key: PublicKey(device='Xiaomi Phone' by 'Mi', algorithm='SHA256_RSA2048', sha1='b2a02f1e56e366d727a1a8e089762fe0b91bbc84') 20:00:58.079 [main] INFO cfig.bootimg.v2.BootV2 - Unpack Summary of boot.img ┌───────────────────────────────────────┬──────────────────────────────────────┐ │What │Where │ └───────────────────────────────────────┴──────────────────────────────────────┘ ┌───────────────────────────────────────┬──────────────────────────────────────┐ │image info │build/unzip_boot/boot.json │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │AVB info [verified] │build/unzip_boot/boot.avb.json │ │\\-- signing key │Xiaomi Phone by Mi │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │kernel │build/unzip_boot/kernel │ │\\-- version [4.14.186] │build/unzip_boot/kernel_version.txt │ │\\-- config │build/unzip_boot/kernel_configs.txt │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │ramdisk │build/unzip_boot/ramdisk.img.gz │ │\\-- extracted ramdisk rootfs │build/unzip_boot/root │ ├────────────────────","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:4","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#3-内核替换"},{"categories":["系统定制"],"content":" 三、正式编译与boot重打包将上面的环境、工具以及修复后的源码准备好就可以正式开始编译了，编译的产物是内核，而最终刷入系统的boot.img，因此整个流程大致可以看成如下： boot.img解包-\u003e内核编译-\u003e内核替换-\u003eboot.img重打包 1 boot.img解包使用Android_boot_image_editor来处理解包打包，先把boot.img放在在Android_boot_image_editor目录下后执行./gradlew unpack命令，下面是输出结果 Starting a Gradle Daemon (subsequent builds will be faster) \u003e Task :unpack 20:00:53.716 [main] WARN cfig.packable.PackableLauncher - [boot.img] will be handled by [BootImgParser] 20:00:53.817 [main] WARN cfig.packable.PackableLauncher - 'unpack' sequence initialized 20:00:53.820 [main] INFO cfig.packable.IPackable - deleting build/unzip_boot/ ... 20:00:54.190 [main] INFO Helper - deleting uiderrors 20:00:54.198 [main] INFO cfig.packable.BootImgParser - header version 2 20:00:54.397 [main] WARN cfig.bootimg.v2.BootHeaderV2 - BootImgHeader constructor 20:00:54.417 [main] INFO cfig.Avb - python aosp/avb/avbtool.v1.2.py verify_image --image boot.img Verifying image boot.img using embedded public key vbmeta: Successfully verified footer and SHA256_RSA2048 vbmeta struct in boot.img boot: Successfully verified sha256 hash of boot.img for image of 30773248 bytes 20:00:55.460 [main] INFO KernelExtractor - [aosp/make/tools/extract_kernel.py, --input, build/unzip_boot/kernel, --output-configs, build/unzip_boot/kernel_configs.txt, --output-version, build/unzip_boot/kernel_version.txt] 20:00:55.464 [main] INFO KernelExtractor - kernel version: [4.14.186] 20:00:55.464 [main] INFO KernelExtractor - kernel config dumped to : build/unzip_boot/kernel_configs.txt 20:00:56.329 [main] INFO ZipHelper - decompress(gz) done: build/unzip_boot/ramdisk.img.gz -\u003e build/unzip_boot/ramdisk.img 20:00:56.332 [main] INFO cfig.bootimg.cpio.AndroidCpio - Cleaning /Users/linhanqiu/Projects/Android_boot_image_editor/build/unzip_boot/root ... 20:00:56.358 [main] WARN cfig.bootimg.cpio.AndroidCpio - root/config has improper file mode 555, fix it 20:00:57.293 [main] WARN cfig.bootimg.cpio.AndroidCpio - root/system/bin/logd has improper file mode 550, fix it 20:00:57.629 [main] INFO cfig.bootimg.cpio.AndroidCpio - cpio trailer found, mode=000001ed 20:00:57.631 [main] INFO cfig.bootimg.Common - ramdisk extracted : build/unzip_boot/ramdisk.img -\u003e build/unzip_boot/root 20:00:57.647 [main] INFO cfig.utils.DTC - parsing DTB: build/unzip_boot/dtb FATAL ERROR: Blob has incorrect magic number 20:00:57.683 [main] ERROR cfig.utils.DTC - can not parse DTB: build/unzip_boot/dtb 20:00:57.687 [main] INFO avb.AVBInfo - parseFrom(FILE:boot.img) ... 20:00:57.723 [main] INFO avb.AVBInfo - FILE:boot.img: Glance(footer=Footer(versionMajor=1, versionMinor=0, originalImageSize=30773248, vbMetaOffset=30773248, vbMetaSize=1600), vbMetaOffset=30773248).footer 20:00:57.837 [main] INFO avb.AVBInfo - VBMeta: boot.img -\u003e build/unzip_boot/boot.avb.json 20:00:58.013 [main] INFO cfig.Avb - signed with release key: 'Xiaomi Phone' by Mi 20:00:58.028 [main] WARN cfig.Avb - Found key: PublicKey(device='Xiaomi Phone' by 'Mi', algorithm='SHA256_RSA2048', sha1='b2a02f1e56e366d727a1a8e089762fe0b91bbc84') 20:00:58.079 [main] INFO cfig.bootimg.v2.BootV2 - Unpack Summary of boot.img ┌───────────────────────────────────────┬──────────────────────────────────────┐ │What │Where │ └───────────────────────────────────────┴──────────────────────────────────────┘ ┌───────────────────────────────────────┬──────────────────────────────────────┐ │image info │build/unzip_boot/boot.json │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │AVB info [verified] │build/unzip_boot/boot.avb.json │ │\\-- signing key │Xiaomi Phone by Mi │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │kernel │build/unzip_boot/kernel │ │\\-- version [4.14.186] │build/unzip_boot/kernel_version.txt │ │\\-- config │build/unzip_boot/kernel_configs.txt │ ├───────────────────────────────────────┼──────────────────────────────────────┤ │ramdisk │build/unzip_boot/ramdisk.img.gz │ │\\-- extracted ramdisk rootfs │build/unzip_boot/root │ ├────────────────────","date":"2023-06-30","objectID":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/:0:4","series":null,"tags":["内核编译"],"title":"红米Note11内核编译流程","uri":"/%E7%BA%A2%E7%B1%B3note11%E5%86%85%E6%A0%B8%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B/#4-bootimg重打包"},{"categories":["Magisk生态"],"content":" 前言Magisk内部实现细节的第四篇，在前两篇着重讲了Magisk的三个重要功能的两个—su以及hide，这篇就来分析下最后一个重要功能—resetprop，这三个功能Magisk也分别导出了三个可执行文件 // native/jni/core/applets.cpp static main_fun applet_main[] = { su_client_main, resetprop_main, magiskhide_main, nullptr }; static int call_applet(int argc, char *argv[]) { // Applets string_view base = basename(argv[0]); for (int i = 0; applet_names[i]; ++i) { if (base == applet_names[i]) { // 根据可执行文件的名称执行具体的类方法 return (*applet_main[i])(argc, argv); } } #if ENABLE_INJECT if (str_starts(base, \"app_process\")) { return app_process_main(argc, argv); } #endif fprintf(stderr, \"%s: applet not found\\n\", base.data()); return 1; } ","date":"2023-06-27","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%824/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节4","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%824/#前言"},{"categories":["Magisk生态"],"content":" 一、Magisk Resetprop入口 // native/jni/resetprop/resetprop.cpp int resetprop_main(int argc, char *argv[]) { log_cb.d = [](auto fmt, auto ap) -\u003e int { return verbose ? vfprintf(stderr, fmt, ap) : 0; }; bool prop_svc = true; bool persist = false; char *argv0 = argv[0]; --argc; ++argv; // Parse flags and -- options while (argc \u0026\u0026 argv[0][0] == '-') { for (int idx = 1; true; ++idx) { switch (argv[0][idx]) { case '-': if (strcmp(argv[0], \"--file\") == 0 \u0026\u0026 argc == 2) { load_prop_file(argv[1], prop_svc); return 0; } else if (strcmp(argv[0], \"--delete\") == 0 \u0026\u0026 argc == 2) { return delprop(argv[1], persist); } else if (strcmp(argv[0], \"--help\") == 0) { usage(argv0); } case 'v': verbose = true; continue; case 'p': persist = true; continue; case 'n': prop_svc = false; continue; case '\\0': break; case 'h': default: usage(argv0); } break; } --argc; ++argv; } switch (argc) { case 0: print_props(persist); return 0; case 1: { string prop = getprop(argv[0], persist); if (prop.empty()) return 1; printf(\"%s\\n\", prop.data()); return 0; } case 2: return setprop(argv[0], argv[1], prop_svc); default: usage(argv0); } } 功能不多，除了开始对命令行参数的解析，再就是print_props、getprop、setprop，从字面上很容易了解它们的含义，先从print_props类看 1 impl初始化print_props也就是批量获取getprop // native/jni/resetprop/resetprop.cpp static void print_props(bool persist) { getprops([](const char *name, const char *value, auto) { printf(\"[%s]: [%s]\\n\", name, value); }, nullptr, persist); } void getprops(void (*callback)(const char *, const char *, void *), void *cookie, bool persist) { get_impl()-\u003egetprops(callback, cookie, persist); } 首先先初始化impl // native/jni/resetprop/resetprop.cpp static sysprop_stub *get_impl() { static sysprop_stub *impl = nullptr; if (impl == nullptr) { // 判断/data/property/persistent_properties是否可读 use_pb = access(PERSISTENT_PROPERTY_DIR \"/persistent_properties\", R_OK) == 0; #ifdef APPLET_STUB_MAIN if (__system_properties_init()) { LOGE(\"resetprop: __system_properties_init error\\n\"); exit(1); } impl = new resetprop(); #else // Load platform implementations // dlsym查找相关system_property方法 load_functions(); if (__system_properties_init()) { LOGW(\"resetprop: __system_properties_init error\\n\"); impl = new sysprop(); } else { impl = new resetprop(); } #endif } return impl; } // native/jni/external/systemproperties/system_property_api.cpp int __system_properties_init() { // 传入/dev/__properties__ return system_properties.Init(PROP_FILENAME) ? 0 : -1; } // native/jni/external/systemproperties/system_properties.cpp bool SystemProperties::Init(const char* filename) { // This is called from __libc_init_common, and should leave errno at 0 (http://b/37248982). ErrnoRestorer errno_restorer; if (initialized_) { /* resetprop remove */ // contexts_-\u003eResetAccess(); return true; } if (strlen(filename) \u003e= PROP_FILENAME_MAX) { return false; } strcpy(property_filename_, filename); if (is_dir(property_filename_)) { if (access(\"/dev/__properties__/property_info\", R_OK) == 0) { contexts_ = new (contexts_data_) ContextsSerialized(); if (!contexts_-\u003eInitialize(false, property_filename_, nullptr)) { return false; } } else { contexts_ = new (contexts_data_) ContextsSplit(); if (!contexts_-\u003eInitialize(false, property_filename_, nullptr)) { return false; } } } else { contexts_ = new (contexts_data_) ContextsPreSplit(); if (!contexts_-\u003eInitialize(false, property_filename_, nullptr)) { return false; } } initialized_ = true; return true; } 2 getprop 3 setprop","date":"2023-06-27","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%824/:0:2","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节4","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%824/#一magisk-resetprop入口"},{"categories":["Magisk生态"],"content":" 一、Magisk Resetprop入口 // native/jni/resetprop/resetprop.cpp int resetprop_main(int argc, char *argv[]) { log_cb.d = [](auto fmt, auto ap) -\u003e int { return verbose ? vfprintf(stderr, fmt, ap) : 0; }; bool prop_svc = true; bool persist = false; char *argv0 = argv[0]; --argc; ++argv; // Parse flags and -- options while (argc \u0026\u0026 argv[0][0] == '-') { for (int idx = 1; true; ++idx) { switch (argv[0][idx]) { case '-': if (strcmp(argv[0], \"--file\") == 0 \u0026\u0026 argc == 2) { load_prop_file(argv[1], prop_svc); return 0; } else if (strcmp(argv[0], \"--delete\") == 0 \u0026\u0026 argc == 2) { return delprop(argv[1], persist); } else if (strcmp(argv[0], \"--help\") == 0) { usage(argv0); } case 'v': verbose = true; continue; case 'p': persist = true; continue; case 'n': prop_svc = false; continue; case '\\0': break; case 'h': default: usage(argv0); } break; } --argc; ++argv; } switch (argc) { case 0: print_props(persist); return 0; case 1: { string prop = getprop(argv[0], persist); if (prop.empty()) return 1; printf(\"%s\\n\", prop.data()); return 0; } case 2: return setprop(argv[0], argv[1], prop_svc); default: usage(argv0); } } 功能不多，除了开始对命令行参数的解析，再就是print_props、getprop、setprop，从字面上很容易了解它们的含义，先从print_props类看 1 impl初始化print_props也就是批量获取getprop // native/jni/resetprop/resetprop.cpp static void print_props(bool persist) { getprops([](const char *name, const char *value, auto) { printf(\"[%s]: [%s]\\n\", name, value); }, nullptr, persist); } void getprops(void (*callback)(const char *, const char *, void *), void *cookie, bool persist) { get_impl()-\u003egetprops(callback, cookie, persist); } 首先先初始化impl // native/jni/resetprop/resetprop.cpp static sysprop_stub *get_impl() { static sysprop_stub *impl = nullptr; if (impl == nullptr) { // 判断/data/property/persistent_properties是否可读 use_pb = access(PERSISTENT_PROPERTY_DIR \"/persistent_properties\", R_OK) == 0; #ifdef APPLET_STUB_MAIN if (__system_properties_init()) { LOGE(\"resetprop: __system_properties_init error\\n\"); exit(1); } impl = new resetprop(); #else // Load platform implementations // dlsym查找相关system_property方法 load_functions(); if (__system_properties_init()) { LOGW(\"resetprop: __system_properties_init error\\n\"); impl = new sysprop(); } else { impl = new resetprop(); } #endif } return impl; } // native/jni/external/systemproperties/system_property_api.cpp int __system_properties_init() { // 传入/dev/__properties__ return system_properties.Init(PROP_FILENAME) ? 0 : -1; } // native/jni/external/systemproperties/system_properties.cpp bool SystemProperties::Init(const char* filename) { // This is called from __libc_init_common, and should leave errno at 0 (http://b/37248982). ErrnoRestorer errno_restorer; if (initialized_) { /* resetprop remove */ // contexts_-\u003eResetAccess(); return true; } if (strlen(filename) \u003e= PROP_FILENAME_MAX) { return false; } strcpy(property_filename_, filename); if (is_dir(property_filename_)) { if (access(\"/dev/__properties__/property_info\", R_OK) == 0) { contexts_ = new (contexts_data_) ContextsSerialized(); if (!contexts_-\u003eInitialize(false, property_filename_, nullptr)) { return false; } } else { contexts_ = new (contexts_data_) ContextsSplit(); if (!contexts_-\u003eInitialize(false, property_filename_, nullptr)) { return false; } } } else { contexts_ = new (contexts_data_) ContextsPreSplit(); if (!contexts_-\u003eInitialize(false, property_filename_, nullptr)) { return false; } } initialized_ = true; return true; } 2 getprop 3 setprop","date":"2023-06-27","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%824/:0:2","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节4","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%824/#1-impl初始化"},{"categories":["Magisk生态"],"content":" 一、Magisk Resetprop入口 // native/jni/resetprop/resetprop.cpp int resetprop_main(int argc, char *argv[]) { log_cb.d = [](auto fmt, auto ap) -\u003e int { return verbose ? vfprintf(stderr, fmt, ap) : 0; }; bool prop_svc = true; bool persist = false; char *argv0 = argv[0]; --argc; ++argv; // Parse flags and -- options while (argc \u0026\u0026 argv[0][0] == '-') { for (int idx = 1; true; ++idx) { switch (argv[0][idx]) { case '-': if (strcmp(argv[0], \"--file\") == 0 \u0026\u0026 argc == 2) { load_prop_file(argv[1], prop_svc); return 0; } else if (strcmp(argv[0], \"--delete\") == 0 \u0026\u0026 argc == 2) { return delprop(argv[1], persist); } else if (strcmp(argv[0], \"--help\") == 0) { usage(argv0); } case 'v': verbose = true; continue; case 'p': persist = true; continue; case 'n': prop_svc = false; continue; case '\\0': break; case 'h': default: usage(argv0); } break; } --argc; ++argv; } switch (argc) { case 0: print_props(persist); return 0; case 1: { string prop = getprop(argv[0], persist); if (prop.empty()) return 1; printf(\"%s\\n\", prop.data()); return 0; } case 2: return setprop(argv[0], argv[1], prop_svc); default: usage(argv0); } } 功能不多，除了开始对命令行参数的解析，再就是print_props、getprop、setprop，从字面上很容易了解它们的含义，先从print_props类看 1 impl初始化print_props也就是批量获取getprop // native/jni/resetprop/resetprop.cpp static void print_props(bool persist) { getprops([](const char *name, const char *value, auto) { printf(\"[%s]: [%s]\\n\", name, value); }, nullptr, persist); } void getprops(void (*callback)(const char *, const char *, void *), void *cookie, bool persist) { get_impl()-\u003egetprops(callback, cookie, persist); } 首先先初始化impl // native/jni/resetprop/resetprop.cpp static sysprop_stub *get_impl() { static sysprop_stub *impl = nullptr; if (impl == nullptr) { // 判断/data/property/persistent_properties是否可读 use_pb = access(PERSISTENT_PROPERTY_DIR \"/persistent_properties\", R_OK) == 0; #ifdef APPLET_STUB_MAIN if (__system_properties_init()) { LOGE(\"resetprop: __system_properties_init error\\n\"); exit(1); } impl = new resetprop(); #else // Load platform implementations // dlsym查找相关system_property方法 load_functions(); if (__system_properties_init()) { LOGW(\"resetprop: __system_properties_init error\\n\"); impl = new sysprop(); } else { impl = new resetprop(); } #endif } return impl; } // native/jni/external/systemproperties/system_property_api.cpp int __system_properties_init() { // 传入/dev/__properties__ return system_properties.Init(PROP_FILENAME) ? 0 : -1; } // native/jni/external/systemproperties/system_properties.cpp bool SystemProperties::Init(const char* filename) { // This is called from __libc_init_common, and should leave errno at 0 (http://b/37248982). ErrnoRestorer errno_restorer; if (initialized_) { /* resetprop remove */ // contexts_-\u003eResetAccess(); return true; } if (strlen(filename) \u003e= PROP_FILENAME_MAX) { return false; } strcpy(property_filename_, filename); if (is_dir(property_filename_)) { if (access(\"/dev/__properties__/property_info\", R_OK) == 0) { contexts_ = new (contexts_data_) ContextsSerialized(); if (!contexts_-\u003eInitialize(false, property_filename_, nullptr)) { return false; } } else { contexts_ = new (contexts_data_) ContextsSplit(); if (!contexts_-\u003eInitialize(false, property_filename_, nullptr)) { return false; } } } else { contexts_ = new (contexts_data_) ContextsPreSplit(); if (!contexts_-\u003eInitialize(false, property_filename_, nullptr)) { return false; } } initialized_ = true; return true; } 2 getprop 3 setprop","date":"2023-06-27","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%824/:0:2","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节4","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%824/#2-getprop"},{"categories":["Magisk生态"],"content":" 一、Magisk Resetprop入口 // native/jni/resetprop/resetprop.cpp int resetprop_main(int argc, char *argv[]) { log_cb.d = [](auto fmt, auto ap) -\u003e int { return verbose ? vfprintf(stderr, fmt, ap) : 0; }; bool prop_svc = true; bool persist = false; char *argv0 = argv[0]; --argc; ++argv; // Parse flags and -- options while (argc \u0026\u0026 argv[0][0] == '-') { for (int idx = 1; true; ++idx) { switch (argv[0][idx]) { case '-': if (strcmp(argv[0], \"--file\") == 0 \u0026\u0026 argc == 2) { load_prop_file(argv[1], prop_svc); return 0; } else if (strcmp(argv[0], \"--delete\") == 0 \u0026\u0026 argc == 2) { return delprop(argv[1], persist); } else if (strcmp(argv[0], \"--help\") == 0) { usage(argv0); } case 'v': verbose = true; continue; case 'p': persist = true; continue; case 'n': prop_svc = false; continue; case '\\0': break; case 'h': default: usage(argv0); } break; } --argc; ++argv; } switch (argc) { case 0: print_props(persist); return 0; case 1: { string prop = getprop(argv[0], persist); if (prop.empty()) return 1; printf(\"%s\\n\", prop.data()); return 0; } case 2: return setprop(argv[0], argv[1], prop_svc); default: usage(argv0); } } 功能不多，除了开始对命令行参数的解析，再就是print_props、getprop、setprop，从字面上很容易了解它们的含义，先从print_props类看 1 impl初始化print_props也就是批量获取getprop // native/jni/resetprop/resetprop.cpp static void print_props(bool persist) { getprops([](const char *name, const char *value, auto) { printf(\"[%s]: [%s]\\n\", name, value); }, nullptr, persist); } void getprops(void (*callback)(const char *, const char *, void *), void *cookie, bool persist) { get_impl()-\u003egetprops(callback, cookie, persist); } 首先先初始化impl // native/jni/resetprop/resetprop.cpp static sysprop_stub *get_impl() { static sysprop_stub *impl = nullptr; if (impl == nullptr) { // 判断/data/property/persistent_properties是否可读 use_pb = access(PERSISTENT_PROPERTY_DIR \"/persistent_properties\", R_OK) == 0; #ifdef APPLET_STUB_MAIN if (__system_properties_init()) { LOGE(\"resetprop: __system_properties_init error\\n\"); exit(1); } impl = new resetprop(); #else // Load platform implementations // dlsym查找相关system_property方法 load_functions(); if (__system_properties_init()) { LOGW(\"resetprop: __system_properties_init error\\n\"); impl = new sysprop(); } else { impl = new resetprop(); } #endif } return impl; } // native/jni/external/systemproperties/system_property_api.cpp int __system_properties_init() { // 传入/dev/__properties__ return system_properties.Init(PROP_FILENAME) ? 0 : -1; } // native/jni/external/systemproperties/system_properties.cpp bool SystemProperties::Init(const char* filename) { // This is called from __libc_init_common, and should leave errno at 0 (http://b/37248982). ErrnoRestorer errno_restorer; if (initialized_) { /* resetprop remove */ // contexts_-\u003eResetAccess(); return true; } if (strlen(filename) \u003e= PROP_FILENAME_MAX) { return false; } strcpy(property_filename_, filename); if (is_dir(property_filename_)) { if (access(\"/dev/__properties__/property_info\", R_OK) == 0) { contexts_ = new (contexts_data_) ContextsSerialized(); if (!contexts_-\u003eInitialize(false, property_filename_, nullptr)) { return false; } } else { contexts_ = new (contexts_data_) ContextsSplit(); if (!contexts_-\u003eInitialize(false, property_filename_, nullptr)) { return false; } } } else { contexts_ = new (contexts_data_) ContextsPreSplit(); if (!contexts_-\u003eInitialize(false, property_filename_, nullptr)) { return false; } } initialized_ = true; return true; } 2 getprop 3 setprop","date":"2023-06-27","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%824/:0:2","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节4","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%824/#3-setprop"},{"categories":["Magisk生态"],"content":" 前言Magisk内部实现细节的第三篇，主要通过源码来了解下Magisk Hide的原理，这部分代码在native/jni/magiskhide当中 ","date":"2023-06-18","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节3","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/#前言"},{"categories":["Magisk生态"],"content":" 一、Magisk Hide入口不管是在Magisk Manager中管理Magisk Hide object MagiskHide : BaseSettingsItem.Toggle() { override val title = R.string.magiskhide.asText() override val description = R.string.settings_magiskhide_summary.asText() override var value = Config.magiskHide set(value) = setV(value, field, { field = it }) { val cmd = if (it) \"enable\" else \"disable\" Shell.su(\"magiskhide $cmd\").submit { cb -\u003e if (cb.isSuccess) Config.magiskHide = it else field = !it } } } 还是通过adb shell来管理Magisk Hide (base) 大慈大悲观世音菩萨  ~  adb shell selene:/ $ su selene:/ # magiskhide status MagiskHide is not enabled 1|selene:/ # magiskhide enable selene:/ # magiskhide status MagiskHide is enabled selene:/ # 其底层都是通过magiskhide这个二进制文件来触发的，而magiskhide的入口是 // native/jni/magiskhide/magiskhide.cpp // 入口函数 int magiskhide_main(int argc, char *argv[]) { if (argc \u003c 2) usage(argv[0]); // CLI backwards compatibility const char *opt = argv[1]; if (opt[0] == '-' \u0026\u0026 opt[1] == '-') opt += 2; int req; // 选择触发的指令 if (opt == \"enable\"sv) req = LAUNCH_MAGISKHIDE; else if (opt == \"disable\"sv) req = STOP_MAGISKHIDE; else if (opt == \"add\"sv) req = ADD_HIDELIST; else if (opt == \"rm\"sv) req = RM_HIDELIST; else if (opt == \"ls\"sv) req = LS_HIDELIST; else if (opt == \"status\"sv) req = HIDE_STATUS; else if (opt == \"exec\"sv \u0026\u0026 argc \u003e 2) { xunshare(CLONE_NEWNS); xmount(nullptr, \"/\", nullptr, MS_PRIVATE | MS_REC, nullptr); hide_unmount(); execvp(argv[2], argv + 2); exit(1); } #if 0 \u0026\u0026 !ENABLE_INJECT else if (opt == \"test\"sv) test_proc_monitor(); #endif else usage(argv[0]); // 同样需要和daemon进行交互 // Send request int fd = connect_daemon(); write_int(fd, MAGISKHIDE); write_int(fd, req); if (req == ADD_HIDELIST || req == RM_HIDELIST) { write_string(fd, argv[2]); write_string(fd, argv[3] ? argv[3] : \"\"); } // Get response int code = read_int(fd); switch (code) { case DAEMON_SUCCESS: break; case HIDE_NOT_ENABLED: fprintf(stderr, \"MagiskHide is not enabled\\n\"); goto return_code; case HIDE_IS_ENABLED: fprintf(stderr, \"MagiskHide is enabled\\n\"); goto return_code; case HIDE_ITEM_EXIST: fprintf(stderr, \"Target already exists in hide list\\n\"); goto return_code; case HIDE_ITEM_NOT_EXIST: fprintf(stderr, \"Target does not exist in hide list\\n\"); goto return_code; case HIDE_NO_NS: fprintf(stderr, \"Your kernel doesn't support mount namespace\\n\"); goto return_code; case HIDE_INVALID_PKG: fprintf(stderr, \"Invalid package / process name\\n\"); goto return_code; case ROOT_REQUIRED: fprintf(stderr, \"Root is required for this operation\\n\"); goto return_code; case DAEMON_ERROR: default: fprintf(stderr, \"Daemon error\\n\"); return DAEMON_ERROR; } if (req == LS_HIDELIST) { string res; for (;;) { read_string(fd, res); if (res.empty()) break; printf(\"%s\\n\", res.data()); } } return_code: return req == HIDE_STATUS ? (code == HIDE_IS_ENABLED ? 0 : 1) : code != DAEMON_SUCCESS; 而对于daemon进程来说，处理magiskhide传来的指令，具体的处理逻辑还是在magiskhide.cpp中 // native/jni/core/daemon.cpp static void request_handler(int client, int req_code, ucred cred) { switch (req_code) { case MAGISKHIDE: magiskhide_handler(client, \u0026cred); break; ...... // native/jni/magiskhide/magiskhide.cpp void magiskhide_handler(int client, ucred *cred) { int req = read_int(client); int res = DAEMON_ERROR; ...... switch (req) { // magiskhide启动 case LAUNCH_MAGISKHIDE: res = launch_magiskhide(true); break; // magiskhide关闭 case STOP_MAGISKHIDE: res = stop_magiskhide(); break; // 新增需要隐藏的app case ADD_HIDELIST: res = add_list(client); break; // 移除 case RM_HIDELIST: res = rm_list(client); break; case LS_HIDELIST: ls_list(client); return; case HIDE_STATUS: res = hide_enabled() ? HIDE_IS_ENABLED : HIDE_NOT_ENABLED; break; #if ENABLE_INJECT case REMOTE_CHECK_HIDE: res = check_uid_map(client); break; case REMOTE_DO_HIDE: kill(cred-\u003epid, SIGSTOP); write_int(client, 0); hide_daemon(cred-\u003epid); close(client); return; #endif } write_int(client, res); close(client); } ","date":"2023-06-18","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/:0:2","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节3","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/#一magisk-hide入口"},{"categories":["Magisk生态"],"content":" 二、Magisk Hide指令分析 1 LAUNCH_MAGISKHIDE // native/jni/magiskhide/hide_utils.cpp // 开启magiskhide int launch_magiskhide(bool late_props) { // 锁申请 mutex_guard lock(hide_state_lock); // 判断全局变量hide_state的值，如果已经启动直接返回 if (hide_state) return HIDE_IS_ENABLED; // 检测是否有访问namespace的权限 if (access(\"/proc/self/ns/mnt\", F_OK) != 0) return HIDE_NO_NS; // 复制procfp if (procfp == nullptr \u0026\u0026 (procfp = opendir(\"/proc\")) == nullptr) return DAEMON_ERROR; LOGI(\"* Enable MagiskHide\\n\"); // 初始化hide_set并杀死相关进程 // Initialize the hide list if (!init_list()) return DAEMON_ERROR; // 替换prop属性 hide_sensitive_props(); if (late_props) // 针对vendor.boot.verifiedbootstate进行替换 hide_late_sensitive_props(); #if !ENABLE_INJECT // Start monitoring // 创建监控线程monitor_thread if (new_daemon_thread(\u0026proc_monitor)) return DAEMON_ERROR; #endif // 更新当前magiskhide状态 hide_state = true; // 更新settings里的magiskhide配置 update_hide_config(); // 释放锁 // Unlock here or else we'll be stuck in deadlock lock.unlock(); // 更新uid_proc_map，需要隐藏的app的uid对应进程名 update_uid_map(); return DAEMON_SUCCESS; } 2 STOP_MAGISKHIDE // native/jni/magiskhide/hide_utils.cpp int stop_magiskhide() { mutex_guard g(hide_state_lock); if (hide_state) { LOGI(\"* Disable MagiskHide\\n\"); // 清理工作 uid_proc_map.clear(); hide_set.clear(); #if !ENABLE_INJECT // 向monitor_thread发送自定义信号SIGTERMTHRD pthread_kill(monitor_thread, SIGTERMTHRD); #endif } // 更新当前magiskhide状态 hide_state = false; // 更新settings里的magiskhide配置 update_hide_config(); return DAEMON_SUCCESS; } 3 ADD_HIDELIST // native/jni/magiskhide/hide_utils.cpp int add_list(int client) { string pkg = read_string(client); string proc = read_string(client); int ret = add_list(pkg.data(), proc.data()); if (ret == DAEMON_SUCCESS) // 更新uid_proc_map update_uid_map(); return ret; } static int add_list(const char *pkg, const char *proc) { if (proc[0] == '\\0') proc = pkg; if (!validate(pkg, proc)) return HIDE_INVALID_PKG; for (auto \u0026hide : hide_set) if (hide.first == pkg \u0026\u0026 hide.second == proc) return HIDE_ITEM_EXIST; // Add to database char sql[4096]; // 写入hidelist数据表 snprintf(sql, sizeof(sql), \"INSERT INTO hidelist (package_name, process) VALUES('%s', '%s')\", pkg, proc); char *err = db_exec(sql); db_err_cmd(err, return DAEMON_ERROR); { // Critical region mutex_guard lock(hide_state_lock); // 更新hide_set add_hide_set(pkg, proc); } return DAEMON_SUCCESS; } 可以看出，首先在Magisk Hide中有三个存储结构用来做Magisk Hide的管理工作 hide_set: 存储需要隐藏功能的包名-进程名 uid_proc_map: 根据hide_set集合来存储对应App的uid以及进程名映射 hidelist: 数据表，供展示时使用 其次，可以看到在Magisk Hide启动时会额外启动monitor_thread这个线程，而这个就是Magisk Hide隐藏功能的核心 ","date":"2023-06-18","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/:0:3","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节3","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/#二magisk-hide指令分析"},{"categories":["Magisk生态"],"content":" 二、Magisk Hide指令分析 1 LAUNCH_MAGISKHIDE // native/jni/magiskhide/hide_utils.cpp // 开启magiskhide int launch_magiskhide(bool late_props) { // 锁申请 mutex_guard lock(hide_state_lock); // 判断全局变量hide_state的值，如果已经启动直接返回 if (hide_state) return HIDE_IS_ENABLED; // 检测是否有访问namespace的权限 if (access(\"/proc/self/ns/mnt\", F_OK) != 0) return HIDE_NO_NS; // 复制procfp if (procfp == nullptr \u0026\u0026 (procfp = opendir(\"/proc\")) == nullptr) return DAEMON_ERROR; LOGI(\"* Enable MagiskHide\\n\"); // 初始化hide_set并杀死相关进程 // Initialize the hide list if (!init_list()) return DAEMON_ERROR; // 替换prop属性 hide_sensitive_props(); if (late_props) // 针对vendor.boot.verifiedbootstate进行替换 hide_late_sensitive_props(); #if !ENABLE_INJECT // Start monitoring // 创建监控线程monitor_thread if (new_daemon_thread(\u0026proc_monitor)) return DAEMON_ERROR; #endif // 更新当前magiskhide状态 hide_state = true; // 更新settings里的magiskhide配置 update_hide_config(); // 释放锁 // Unlock here or else we'll be stuck in deadlock lock.unlock(); // 更新uid_proc_map，需要隐藏的app的uid对应进程名 update_uid_map(); return DAEMON_SUCCESS; } 2 STOP_MAGISKHIDE // native/jni/magiskhide/hide_utils.cpp int stop_magiskhide() { mutex_guard g(hide_state_lock); if (hide_state) { LOGI(\"* Disable MagiskHide\\n\"); // 清理工作 uid_proc_map.clear(); hide_set.clear(); #if !ENABLE_INJECT // 向monitor_thread发送自定义信号SIGTERMTHRD pthread_kill(monitor_thread, SIGTERMTHRD); #endif } // 更新当前magiskhide状态 hide_state = false; // 更新settings里的magiskhide配置 update_hide_config(); return DAEMON_SUCCESS; } 3 ADD_HIDELIST // native/jni/magiskhide/hide_utils.cpp int add_list(int client) { string pkg = read_string(client); string proc = read_string(client); int ret = add_list(pkg.data(), proc.data()); if (ret == DAEMON_SUCCESS) // 更新uid_proc_map update_uid_map(); return ret; } static int add_list(const char *pkg, const char *proc) { if (proc[0] == '\\0') proc = pkg; if (!validate(pkg, proc)) return HIDE_INVALID_PKG; for (auto \u0026hide : hide_set) if (hide.first == pkg \u0026\u0026 hide.second == proc) return HIDE_ITEM_EXIST; // Add to database char sql[4096]; // 写入hidelist数据表 snprintf(sql, sizeof(sql), \"INSERT INTO hidelist (package_name, process) VALUES('%s', '%s')\", pkg, proc); char *err = db_exec(sql); db_err_cmd(err, return DAEMON_ERROR); { // Critical region mutex_guard lock(hide_state_lock); // 更新hide_set add_hide_set(pkg, proc); } return DAEMON_SUCCESS; } 可以看出，首先在Magisk Hide中有三个存储结构用来做Magisk Hide的管理工作 hide_set: 存储需要隐藏功能的包名-进程名 uid_proc_map: 根据hide_set集合来存储对应App的uid以及进程名映射 hidelist: 数据表，供展示时使用 其次，可以看到在Magisk Hide启动时会额外启动monitor_thread这个线程，而这个就是Magisk Hide隐藏功能的核心 ","date":"2023-06-18","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/:0:3","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节3","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/#1-launch_magiskhide"},{"categories":["Magisk生态"],"content":" 二、Magisk Hide指令分析 1 LAUNCH_MAGISKHIDE // native/jni/magiskhide/hide_utils.cpp // 开启magiskhide int launch_magiskhide(bool late_props) { // 锁申请 mutex_guard lock(hide_state_lock); // 判断全局变量hide_state的值，如果已经启动直接返回 if (hide_state) return HIDE_IS_ENABLED; // 检测是否有访问namespace的权限 if (access(\"/proc/self/ns/mnt\", F_OK) != 0) return HIDE_NO_NS; // 复制procfp if (procfp == nullptr \u0026\u0026 (procfp = opendir(\"/proc\")) == nullptr) return DAEMON_ERROR; LOGI(\"* Enable MagiskHide\\n\"); // 初始化hide_set并杀死相关进程 // Initialize the hide list if (!init_list()) return DAEMON_ERROR; // 替换prop属性 hide_sensitive_props(); if (late_props) // 针对vendor.boot.verifiedbootstate进行替换 hide_late_sensitive_props(); #if !ENABLE_INJECT // Start monitoring // 创建监控线程monitor_thread if (new_daemon_thread(\u0026proc_monitor)) return DAEMON_ERROR; #endif // 更新当前magiskhide状态 hide_state = true; // 更新settings里的magiskhide配置 update_hide_config(); // 释放锁 // Unlock here or else we'll be stuck in deadlock lock.unlock(); // 更新uid_proc_map，需要隐藏的app的uid对应进程名 update_uid_map(); return DAEMON_SUCCESS; } 2 STOP_MAGISKHIDE // native/jni/magiskhide/hide_utils.cpp int stop_magiskhide() { mutex_guard g(hide_state_lock); if (hide_state) { LOGI(\"* Disable MagiskHide\\n\"); // 清理工作 uid_proc_map.clear(); hide_set.clear(); #if !ENABLE_INJECT // 向monitor_thread发送自定义信号SIGTERMTHRD pthread_kill(monitor_thread, SIGTERMTHRD); #endif } // 更新当前magiskhide状态 hide_state = false; // 更新settings里的magiskhide配置 update_hide_config(); return DAEMON_SUCCESS; } 3 ADD_HIDELIST // native/jni/magiskhide/hide_utils.cpp int add_list(int client) { string pkg = read_string(client); string proc = read_string(client); int ret = add_list(pkg.data(), proc.data()); if (ret == DAEMON_SUCCESS) // 更新uid_proc_map update_uid_map(); return ret; } static int add_list(const char *pkg, const char *proc) { if (proc[0] == '\\0') proc = pkg; if (!validate(pkg, proc)) return HIDE_INVALID_PKG; for (auto \u0026hide : hide_set) if (hide.first == pkg \u0026\u0026 hide.second == proc) return HIDE_ITEM_EXIST; // Add to database char sql[4096]; // 写入hidelist数据表 snprintf(sql, sizeof(sql), \"INSERT INTO hidelist (package_name, process) VALUES('%s', '%s')\", pkg, proc); char *err = db_exec(sql); db_err_cmd(err, return DAEMON_ERROR); { // Critical region mutex_guard lock(hide_state_lock); // 更新hide_set add_hide_set(pkg, proc); } return DAEMON_SUCCESS; } 可以看出，首先在Magisk Hide中有三个存储结构用来做Magisk Hide的管理工作 hide_set: 存储需要隐藏功能的包名-进程名 uid_proc_map: 根据hide_set集合来存储对应App的uid以及进程名映射 hidelist: 数据表，供展示时使用 其次，可以看到在Magisk Hide启动时会额外启动monitor_thread这个线程，而这个就是Magisk Hide隐藏功能的核心 ","date":"2023-06-18","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/:0:3","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节3","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/#2-stop_magiskhide"},{"categories":["Magisk生态"],"content":" 二、Magisk Hide指令分析 1 LAUNCH_MAGISKHIDE // native/jni/magiskhide/hide_utils.cpp // 开启magiskhide int launch_magiskhide(bool late_props) { // 锁申请 mutex_guard lock(hide_state_lock); // 判断全局变量hide_state的值，如果已经启动直接返回 if (hide_state) return HIDE_IS_ENABLED; // 检测是否有访问namespace的权限 if (access(\"/proc/self/ns/mnt\", F_OK) != 0) return HIDE_NO_NS; // 复制procfp if (procfp == nullptr \u0026\u0026 (procfp = opendir(\"/proc\")) == nullptr) return DAEMON_ERROR; LOGI(\"* Enable MagiskHide\\n\"); // 初始化hide_set并杀死相关进程 // Initialize the hide list if (!init_list()) return DAEMON_ERROR; // 替换prop属性 hide_sensitive_props(); if (late_props) // 针对vendor.boot.verifiedbootstate进行替换 hide_late_sensitive_props(); #if !ENABLE_INJECT // Start monitoring // 创建监控线程monitor_thread if (new_daemon_thread(\u0026proc_monitor)) return DAEMON_ERROR; #endif // 更新当前magiskhide状态 hide_state = true; // 更新settings里的magiskhide配置 update_hide_config(); // 释放锁 // Unlock here or else we'll be stuck in deadlock lock.unlock(); // 更新uid_proc_map，需要隐藏的app的uid对应进程名 update_uid_map(); return DAEMON_SUCCESS; } 2 STOP_MAGISKHIDE // native/jni/magiskhide/hide_utils.cpp int stop_magiskhide() { mutex_guard g(hide_state_lock); if (hide_state) { LOGI(\"* Disable MagiskHide\\n\"); // 清理工作 uid_proc_map.clear(); hide_set.clear(); #if !ENABLE_INJECT // 向monitor_thread发送自定义信号SIGTERMTHRD pthread_kill(monitor_thread, SIGTERMTHRD); #endif } // 更新当前magiskhide状态 hide_state = false; // 更新settings里的magiskhide配置 update_hide_config(); return DAEMON_SUCCESS; } 3 ADD_HIDELIST // native/jni/magiskhide/hide_utils.cpp int add_list(int client) { string pkg = read_string(client); string proc = read_string(client); int ret = add_list(pkg.data(), proc.data()); if (ret == DAEMON_SUCCESS) // 更新uid_proc_map update_uid_map(); return ret; } static int add_list(const char *pkg, const char *proc) { if (proc[0] == '\\0') proc = pkg; if (!validate(pkg, proc)) return HIDE_INVALID_PKG; for (auto \u0026hide : hide_set) if (hide.first == pkg \u0026\u0026 hide.second == proc) return HIDE_ITEM_EXIST; // Add to database char sql[4096]; // 写入hidelist数据表 snprintf(sql, sizeof(sql), \"INSERT INTO hidelist (package_name, process) VALUES('%s', '%s')\", pkg, proc); char *err = db_exec(sql); db_err_cmd(err, return DAEMON_ERROR); { // Critical region mutex_guard lock(hide_state_lock); // 更新hide_set add_hide_set(pkg, proc); } return DAEMON_SUCCESS; } 可以看出，首先在Magisk Hide中有三个存储结构用来做Magisk Hide的管理工作 hide_set: 存储需要隐藏功能的包名-进程名 uid_proc_map: 根据hide_set集合来存储对应App的uid以及进程名映射 hidelist: 数据表，供展示时使用 其次，可以看到在Magisk Hide启动时会额外启动monitor_thread这个线程，而这个就是Magisk Hide隐藏功能的核心 ","date":"2023-06-18","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/:0:3","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节3","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/#3-add_hidelist"},{"categories":["Magisk生态"],"content":" 三、Magisk Hide原理跟进monitor_thread 1 信号处理 // native/jni/magiskhide/proc_monitor.cpp // 设置该线程为monitor_thread，并于后续清理 monitor_thread = pthread_self(); // Backup original mask // 获取当前线程的信号掩码保存在orin_mask sigset_t orig_mask; pthread_sigmask(SIG_SETMASK, nullptr, \u0026orig_mask); // 清空信号集并初始化 sigset_t unblock_set; sigemptyset(\u0026unblock_set); sigaddset(\u0026unblock_set, SIGTERMTHRD); sigaddset(\u0026unblock_set, SIGIO); sigaddset(\u0026unblock_set, SIGALRM); // 设置信号处理函数集合 struct sigaction act{}; sigfillset(\u0026act.sa_mask); act.sa_handler = SIG_IGN; sigaction(SIGTERMTHRD, \u0026act, nullptr); sigaction(SIGIO, \u0026act, nullptr); sigaction(SIGALRM, \u0026act, nullptr); // 防止信号积压处理 // Temporary unblock to clear pending signals pthread_sigmask(SIG_UNBLOCK, \u0026unblock_set, nullptr); pthread_sigmask(SIG_SETMASK, \u0026orig_mask, nullptr); // 使用term_thread来处理SIGTERMTHRD信号 act.sa_handler = term_thread; sigaction(SIGTERMTHRD, \u0026act, nullptr); // 使用inotify_event处理SIGIO信号 act.sa_handler = inotify_event; sigaction(SIGIO, \u0026act, nullptr); // 使用check_zygote处理SIGALRM信号 act.sa_handler = [](int){ check_zygote(); }; sigaction(SIGALRM, \u0026act, nullptr); setup_inotify(); static void setup_inotify() { // 创建inotify实例时指定了IN_CLOEXEC标志位，表示将inotify实例设置为 close-on-exec 模式。 // 在close-on-exec模式下，当进程调用exec函数时，inotify实例会自动关闭 inotify_fd = xinotify_init1(IN_CLOEXEC); if (inotify_fd \u003c 0) return; // Setup inotify asynchronous I/O // 设置inotify文件描述符的异步通知和所有权 fcntl(inotify_fd, F_SETFL, O_ASYNC); struct f_owner_ex ex = { .type = F_OWNER_TID, .pid = gettid() }; fcntl(inotify_fd, F_SETOWN_EX, \u0026ex); // 监控/data/system的写入并关闭事件 // Monitor packages.xml inotify_add_watch(inotify_fd, \"/data/system\", IN_CLOSE_WRITE); // 监控app_process的被访问的事件，也就是监控App // Monitor app_process if (access(APP_PROC \"32\", F_OK) == 0) { inotify_add_watch(inotify_fd, APP_PROC \"32\", IN_ACCESS); if (access(APP_PROC \"64\", F_OK) == 0) inotify_add_watch(inotify_fd, APP_PROC \"64\", IN_ACCESS); } else { inotify_add_watch(inotify_fd, APP_PROC, IN_ACCESS); } } 这个部分主要做的事是 设置信号处理函数，信号分别是SIGTERMTHRD、SIGIO、SIGALRM 启动inotify，fd写入inotify_fd，监控/system/bin/app_process的access事件，重点在于packages.xml文件的写入 2 ptrace Zygote check_zygote(); if (!is_zygote_done()) { // 如果获取到zygote，则每250ms发送SIGALRM信号触发check_zygote // Periodic scan every 250ms timeval val { .tv_sec = 0, .tv_usec = 250000 }; itimerval interval { .it_interval = val, .it_value = val }; setitimer(ITIMER_REAL, \u0026interval, nullptr); } static void check_zygote() { crawl_procfs([](int pid) -\u003e bool { char buf[512]; snprintf(buf, sizeof(buf), \"/proc/%d/cmdline\", pid); if (FILE *f = fopen(buf, \"re\")) { fgets(buf, sizeof(buf), f); if (strncmp(buf, \"zygote\", 6) == 0 \u0026\u0026 parse_ppid(pid) == 1) new_zygote(pid); fclose(f); } return true; }); if (is_zygote_done()) { // Stop periodic scanning timeval val { .tv_sec = 0, .tv_usec = 0 }; itimerval interval { .it_interval = val, .it_value = val }; setitimer(ITIMER_REAL, \u0026interval, nullptr); } } static DIR *procfp; // procfp在之前已经被赋值成/proc目录 void crawl_procfs(const function\u003cbool(int)\u003e \u0026fn) { // 指针重置到目录起始位置 rewinddir(procfp); crawl_procfs(procfp, fn); } // 遍历proc目录，获取zygote的pid void crawl_procfs(DIR *dir, const function\u003cbool(int)\u003e \u0026fn) { struct dirent *dp; int pid; while ((dp = readdir(dir))) { pid = parse_int(dp-\u003ed_name); if (pid \u003e 0 \u0026\u0026 !fn(pid)) break; } } static void new_zygote(int pid) { struct stat st; // 读取zygote挂载的namespace信息 if (read_ns(pid, \u0026st)) return; // 更新或者存储st到zygote_map auto it = zygote_map.find(pid); if (it != zygote_map.end()) { // Update namespace info it-\u003esecond = st; return; } LOGD(\"proc_monitor: ptrace zygote PID=[%d]\\n\", pid); zygote_map[pid] = st; // ptrace attach到zygote进程 xptrace(PTRACE_ATTACH, pid); // 等待zygote进程状态变化 waitpid(pid, nullptr, __WALL | __WNOTHREAD); 监控zygote fork/vfork/exit事件 xptrace(PTRACE_SETOPTIONS, pid, nullptr, PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACEEXIT); // 恢复zygote进程执行 xptrace(PTRACE_CONT, pid); } 这一部分的作用是轮询判断zygote进程是否启动以及ptrace attach到zygote以便于监控到zygote的fork操作（引导启动App进程） 3 子进程信号处理 for (int status;;) { // 解除信号阻塞，获取信号 pthread_sigmask(SI","date":"2023-06-18","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/:0:4","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节3","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/#三magisk-hide原理"},{"categories":["Magisk生态"],"content":" 三、Magisk Hide原理跟进monitor_thread 1 信号处理 // native/jni/magiskhide/proc_monitor.cpp // 设置该线程为monitor_thread，并于后续清理 monitor_thread = pthread_self(); // Backup original mask // 获取当前线程的信号掩码保存在orin_mask sigset_t orig_mask; pthread_sigmask(SIG_SETMASK, nullptr, \u0026orig_mask); // 清空信号集并初始化 sigset_t unblock_set; sigemptyset(\u0026unblock_set); sigaddset(\u0026unblock_set, SIGTERMTHRD); sigaddset(\u0026unblock_set, SIGIO); sigaddset(\u0026unblock_set, SIGALRM); // 设置信号处理函数集合 struct sigaction act{}; sigfillset(\u0026act.sa_mask); act.sa_handler = SIG_IGN; sigaction(SIGTERMTHRD, \u0026act, nullptr); sigaction(SIGIO, \u0026act, nullptr); sigaction(SIGALRM, \u0026act, nullptr); // 防止信号积压处理 // Temporary unblock to clear pending signals pthread_sigmask(SIG_UNBLOCK, \u0026unblock_set, nullptr); pthread_sigmask(SIG_SETMASK, \u0026orig_mask, nullptr); // 使用term_thread来处理SIGTERMTHRD信号 act.sa_handler = term_thread; sigaction(SIGTERMTHRD, \u0026act, nullptr); // 使用inotify_event处理SIGIO信号 act.sa_handler = inotify_event; sigaction(SIGIO, \u0026act, nullptr); // 使用check_zygote处理SIGALRM信号 act.sa_handler = [](int){ check_zygote(); }; sigaction(SIGALRM, \u0026act, nullptr); setup_inotify(); static void setup_inotify() { // 创建inotify实例时指定了IN_CLOEXEC标志位，表示将inotify实例设置为 close-on-exec 模式。 // 在close-on-exec模式下，当进程调用exec函数时，inotify实例会自动关闭 inotify_fd = xinotify_init1(IN_CLOEXEC); if (inotify_fd \u003c 0) return; // Setup inotify asynchronous I/O // 设置inotify文件描述符的异步通知和所有权 fcntl(inotify_fd, F_SETFL, O_ASYNC); struct f_owner_ex ex = { .type = F_OWNER_TID, .pid = gettid() }; fcntl(inotify_fd, F_SETOWN_EX, \u0026ex); // 监控/data/system的写入并关闭事件 // Monitor packages.xml inotify_add_watch(inotify_fd, \"/data/system\", IN_CLOSE_WRITE); // 监控app_process的被访问的事件，也就是监控App // Monitor app_process if (access(APP_PROC \"32\", F_OK) == 0) { inotify_add_watch(inotify_fd, APP_PROC \"32\", IN_ACCESS); if (access(APP_PROC \"64\", F_OK) == 0) inotify_add_watch(inotify_fd, APP_PROC \"64\", IN_ACCESS); } else { inotify_add_watch(inotify_fd, APP_PROC, IN_ACCESS); } } 这个部分主要做的事是 设置信号处理函数，信号分别是SIGTERMTHRD、SIGIO、SIGALRM 启动inotify，fd写入inotify_fd，监控/system/bin/app_process的access事件，重点在于packages.xml文件的写入 2 ptrace Zygote check_zygote(); if (!is_zygote_done()) { // 如果获取到zygote，则每250ms发送SIGALRM信号触发check_zygote // Periodic scan every 250ms timeval val { .tv_sec = 0, .tv_usec = 250000 }; itimerval interval { .it_interval = val, .it_value = val }; setitimer(ITIMER_REAL, \u0026interval, nullptr); } static void check_zygote() { crawl_procfs([](int pid) -\u003e bool { char buf[512]; snprintf(buf, sizeof(buf), \"/proc/%d/cmdline\", pid); if (FILE *f = fopen(buf, \"re\")) { fgets(buf, sizeof(buf), f); if (strncmp(buf, \"zygote\", 6) == 0 \u0026\u0026 parse_ppid(pid) == 1) new_zygote(pid); fclose(f); } return true; }); if (is_zygote_done()) { // Stop periodic scanning timeval val { .tv_sec = 0, .tv_usec = 0 }; itimerval interval { .it_interval = val, .it_value = val }; setitimer(ITIMER_REAL, \u0026interval, nullptr); } } static DIR *procfp; // procfp在之前已经被赋值成/proc目录 void crawl_procfs(const function \u0026fn) { // 指针重置到目录起始位置 rewinddir(procfp); crawl_procfs(procfp, fn); } // 遍历proc目录，获取zygote的pid void crawl_procfs(DIR *dir, const function \u0026fn) { struct dirent *dp; int pid; while ((dp = readdir(dir))) { pid = parse_int(dp-\u003ed_name); if (pid \u003e 0 \u0026\u0026 !fn(pid)) break; } } static void new_zygote(int pid) { struct stat st; // 读取zygote挂载的namespace信息 if (read_ns(pid, \u0026st)) return; // 更新或者存储st到zygote_map auto it = zygote_map.find(pid); if (it != zygote_map.end()) { // Update namespace info it-\u003esecond = st; return; } LOGD(\"proc_monitor: ptrace zygote PID=[%d]\\n\", pid); zygote_map[pid] = st; // ptrace attach到zygote进程 xptrace(PTRACE_ATTACH, pid); // 等待zygote进程状态变化 waitpid(pid, nullptr, __WALL | __WNOTHREAD); 监控zygote fork/vfork/exit事件 xptrace(PTRACE_SETOPTIONS, pid, nullptr, PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACEEXIT); // 恢复zygote进程执行 xptrace(PTRACE_CONT, pid); } 这一部分的作用是轮询判断zygote进程是否启动以及ptrace attach到zygote以便于监控到zygote的fork操作（引导启动App进程） 3 子进程信号处理 for (int status;;) { // 解除信号阻塞，获取信号 pthread_sigmask(SI","date":"2023-06-18","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/:0:4","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节3","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/#1-信号处理"},{"categories":["Magisk生态"],"content":" 三、Magisk Hide原理跟进monitor_thread 1 信号处理 // native/jni/magiskhide/proc_monitor.cpp // 设置该线程为monitor_thread，并于后续清理 monitor_thread = pthread_self(); // Backup original mask // 获取当前线程的信号掩码保存在orin_mask sigset_t orig_mask; pthread_sigmask(SIG_SETMASK, nullptr, \u0026orig_mask); // 清空信号集并初始化 sigset_t unblock_set; sigemptyset(\u0026unblock_set); sigaddset(\u0026unblock_set, SIGTERMTHRD); sigaddset(\u0026unblock_set, SIGIO); sigaddset(\u0026unblock_set, SIGALRM); // 设置信号处理函数集合 struct sigaction act{}; sigfillset(\u0026act.sa_mask); act.sa_handler = SIG_IGN; sigaction(SIGTERMTHRD, \u0026act, nullptr); sigaction(SIGIO, \u0026act, nullptr); sigaction(SIGALRM, \u0026act, nullptr); // 防止信号积压处理 // Temporary unblock to clear pending signals pthread_sigmask(SIG_UNBLOCK, \u0026unblock_set, nullptr); pthread_sigmask(SIG_SETMASK, \u0026orig_mask, nullptr); // 使用term_thread来处理SIGTERMTHRD信号 act.sa_handler = term_thread; sigaction(SIGTERMTHRD, \u0026act, nullptr); // 使用inotify_event处理SIGIO信号 act.sa_handler = inotify_event; sigaction(SIGIO, \u0026act, nullptr); // 使用check_zygote处理SIGALRM信号 act.sa_handler = [](int){ check_zygote(); }; sigaction(SIGALRM, \u0026act, nullptr); setup_inotify(); static void setup_inotify() { // 创建inotify实例时指定了IN_CLOEXEC标志位，表示将inotify实例设置为 close-on-exec 模式。 // 在close-on-exec模式下，当进程调用exec函数时，inotify实例会自动关闭 inotify_fd = xinotify_init1(IN_CLOEXEC); if (inotify_fd \u003c 0) return; // Setup inotify asynchronous I/O // 设置inotify文件描述符的异步通知和所有权 fcntl(inotify_fd, F_SETFL, O_ASYNC); struct f_owner_ex ex = { .type = F_OWNER_TID, .pid = gettid() }; fcntl(inotify_fd, F_SETOWN_EX, \u0026ex); // 监控/data/system的写入并关闭事件 // Monitor packages.xml inotify_add_watch(inotify_fd, \"/data/system\", IN_CLOSE_WRITE); // 监控app_process的被访问的事件，也就是监控App // Monitor app_process if (access(APP_PROC \"32\", F_OK) == 0) { inotify_add_watch(inotify_fd, APP_PROC \"32\", IN_ACCESS); if (access(APP_PROC \"64\", F_OK) == 0) inotify_add_watch(inotify_fd, APP_PROC \"64\", IN_ACCESS); } else { inotify_add_watch(inotify_fd, APP_PROC, IN_ACCESS); } } 这个部分主要做的事是 设置信号处理函数，信号分别是SIGTERMTHRD、SIGIO、SIGALRM 启动inotify，fd写入inotify_fd，监控/system/bin/app_process的access事件，重点在于packages.xml文件的写入 2 ptrace Zygote check_zygote(); if (!is_zygote_done()) { // 如果获取到zygote，则每250ms发送SIGALRM信号触发check_zygote // Periodic scan every 250ms timeval val { .tv_sec = 0, .tv_usec = 250000 }; itimerval interval { .it_interval = val, .it_value = val }; setitimer(ITIMER_REAL, \u0026interval, nullptr); } static void check_zygote() { crawl_procfs([](int pid) -\u003e bool { char buf[512]; snprintf(buf, sizeof(buf), \"/proc/%d/cmdline\", pid); if (FILE *f = fopen(buf, \"re\")) { fgets(buf, sizeof(buf), f); if (strncmp(buf, \"zygote\", 6) == 0 \u0026\u0026 parse_ppid(pid) == 1) new_zygote(pid); fclose(f); } return true; }); if (is_zygote_done()) { // Stop periodic scanning timeval val { .tv_sec = 0, .tv_usec = 0 }; itimerval interval { .it_interval = val, .it_value = val }; setitimer(ITIMER_REAL, \u0026interval, nullptr); } } static DIR *procfp; // procfp在之前已经被赋值成/proc目录 void crawl_procfs(const function \u0026fn) { // 指针重置到目录起始位置 rewinddir(procfp); crawl_procfs(procfp, fn); } // 遍历proc目录，获取zygote的pid void crawl_procfs(DIR *dir, const function \u0026fn) { struct dirent *dp; int pid; while ((dp = readdir(dir))) { pid = parse_int(dp-\u003ed_name); if (pid \u003e 0 \u0026\u0026 !fn(pid)) break; } } static void new_zygote(int pid) { struct stat st; // 读取zygote挂载的namespace信息 if (read_ns(pid, \u0026st)) return; // 更新或者存储st到zygote_map auto it = zygote_map.find(pid); if (it != zygote_map.end()) { // Update namespace info it-\u003esecond = st; return; } LOGD(\"proc_monitor: ptrace zygote PID=[%d]\\n\", pid); zygote_map[pid] = st; // ptrace attach到zygote进程 xptrace(PTRACE_ATTACH, pid); // 等待zygote进程状态变化 waitpid(pid, nullptr, __WALL | __WNOTHREAD); 监控zygote fork/vfork/exit事件 xptrace(PTRACE_SETOPTIONS, pid, nullptr, PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACEEXIT); // 恢复zygote进程执行 xptrace(PTRACE_CONT, pid); } 这一部分的作用是轮询判断zygote进程是否启动以及ptrace attach到zygote以便于监控到zygote的fork操作（引导启动App进程） 3 子进程信号处理 for (int status;;) { // 解除信号阻塞，获取信号 pthread_sigmask(SI","date":"2023-06-18","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/:0:4","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节3","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/#2-ptrace-zygote"},{"categories":["Magisk生态"],"content":" 三、Magisk Hide原理跟进monitor_thread 1 信号处理 // native/jni/magiskhide/proc_monitor.cpp // 设置该线程为monitor_thread，并于后续清理 monitor_thread = pthread_self(); // Backup original mask // 获取当前线程的信号掩码保存在orin_mask sigset_t orig_mask; pthread_sigmask(SIG_SETMASK, nullptr, \u0026orig_mask); // 清空信号集并初始化 sigset_t unblock_set; sigemptyset(\u0026unblock_set); sigaddset(\u0026unblock_set, SIGTERMTHRD); sigaddset(\u0026unblock_set, SIGIO); sigaddset(\u0026unblock_set, SIGALRM); // 设置信号处理函数集合 struct sigaction act{}; sigfillset(\u0026act.sa_mask); act.sa_handler = SIG_IGN; sigaction(SIGTERMTHRD, \u0026act, nullptr); sigaction(SIGIO, \u0026act, nullptr); sigaction(SIGALRM, \u0026act, nullptr); // 防止信号积压处理 // Temporary unblock to clear pending signals pthread_sigmask(SIG_UNBLOCK, \u0026unblock_set, nullptr); pthread_sigmask(SIG_SETMASK, \u0026orig_mask, nullptr); // 使用term_thread来处理SIGTERMTHRD信号 act.sa_handler = term_thread; sigaction(SIGTERMTHRD, \u0026act, nullptr); // 使用inotify_event处理SIGIO信号 act.sa_handler = inotify_event; sigaction(SIGIO, \u0026act, nullptr); // 使用check_zygote处理SIGALRM信号 act.sa_handler = [](int){ check_zygote(); }; sigaction(SIGALRM, \u0026act, nullptr); setup_inotify(); static void setup_inotify() { // 创建inotify实例时指定了IN_CLOEXEC标志位，表示将inotify实例设置为 close-on-exec 模式。 // 在close-on-exec模式下，当进程调用exec函数时，inotify实例会自动关闭 inotify_fd = xinotify_init1(IN_CLOEXEC); if (inotify_fd \u003c 0) return; // Setup inotify asynchronous I/O // 设置inotify文件描述符的异步通知和所有权 fcntl(inotify_fd, F_SETFL, O_ASYNC); struct f_owner_ex ex = { .type = F_OWNER_TID, .pid = gettid() }; fcntl(inotify_fd, F_SETOWN_EX, \u0026ex); // 监控/data/system的写入并关闭事件 // Monitor packages.xml inotify_add_watch(inotify_fd, \"/data/system\", IN_CLOSE_WRITE); // 监控app_process的被访问的事件，也就是监控App // Monitor app_process if (access(APP_PROC \"32\", F_OK) == 0) { inotify_add_watch(inotify_fd, APP_PROC \"32\", IN_ACCESS); if (access(APP_PROC \"64\", F_OK) == 0) inotify_add_watch(inotify_fd, APP_PROC \"64\", IN_ACCESS); } else { inotify_add_watch(inotify_fd, APP_PROC, IN_ACCESS); } } 这个部分主要做的事是 设置信号处理函数，信号分别是SIGTERMTHRD、SIGIO、SIGALRM 启动inotify，fd写入inotify_fd，监控/system/bin/app_process的access事件，重点在于packages.xml文件的写入 2 ptrace Zygote check_zygote(); if (!is_zygote_done()) { // 如果获取到zygote，则每250ms发送SIGALRM信号触发check_zygote // Periodic scan every 250ms timeval val { .tv_sec = 0, .tv_usec = 250000 }; itimerval interval { .it_interval = val, .it_value = val }; setitimer(ITIMER_REAL, \u0026interval, nullptr); } static void check_zygote() { crawl_procfs([](int pid) -\u003e bool { char buf[512]; snprintf(buf, sizeof(buf), \"/proc/%d/cmdline\", pid); if (FILE *f = fopen(buf, \"re\")) { fgets(buf, sizeof(buf), f); if (strncmp(buf, \"zygote\", 6) == 0 \u0026\u0026 parse_ppid(pid) == 1) new_zygote(pid); fclose(f); } return true; }); if (is_zygote_done()) { // Stop periodic scanning timeval val { .tv_sec = 0, .tv_usec = 0 }; itimerval interval { .it_interval = val, .it_value = val }; setitimer(ITIMER_REAL, \u0026interval, nullptr); } } static DIR *procfp; // procfp在之前已经被赋值成/proc目录 void crawl_procfs(const function \u0026fn) { // 指针重置到目录起始位置 rewinddir(procfp); crawl_procfs(procfp, fn); } // 遍历proc目录，获取zygote的pid void crawl_procfs(DIR *dir, const function \u0026fn) { struct dirent *dp; int pid; while ((dp = readdir(dir))) { pid = parse_int(dp-\u003ed_name); if (pid \u003e 0 \u0026\u0026 !fn(pid)) break; } } static void new_zygote(int pid) { struct stat st; // 读取zygote挂载的namespace信息 if (read_ns(pid, \u0026st)) return; // 更新或者存储st到zygote_map auto it = zygote_map.find(pid); if (it != zygote_map.end()) { // Update namespace info it-\u003esecond = st; return; } LOGD(\"proc_monitor: ptrace zygote PID=[%d]\\n\", pid); zygote_map[pid] = st; // ptrace attach到zygote进程 xptrace(PTRACE_ATTACH, pid); // 等待zygote进程状态变化 waitpid(pid, nullptr, __WALL | __WNOTHREAD); 监控zygote fork/vfork/exit事件 xptrace(PTRACE_SETOPTIONS, pid, nullptr, PTRACE_O_TRACEFORK | PTRACE_O_TRACEVFORK | PTRACE_O_TRACEEXIT); // 恢复zygote进程执行 xptrace(PTRACE_CONT, pid); } 这一部分的作用是轮询判断zygote进程是否启动以及ptrace attach到zygote以便于监控到zygote的fork操作（引导启动App进程） 3 子进程信号处理 for (int status;;) { // 解除信号阻塞，获取信号 pthread_sigmask(SI","date":"2023-06-18","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/:0:4","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节3","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%823/#3-子进程信号处理"},{"categories":["Magisk生态"],"content":" 一、市面现存的检测方式 1 Magisk Detector来源于Magisk Detector（现已停止维护），我们可以从官方的细节文档看出它之前的设计思路 ，目前从最新的代码上看，仅仅存在三种检测方式 JNINativeMethod methods[] = { {\"haveSu\", \"()I\", haveSu}, {\"haveMagiskHide\", \"()I\", haveMagiskHide}, {\"haveMagicMount\", \"()I\", haveMagicMount}, }; 1.1 su文件检测 检测方式 static int scan_path() { char *path = getenv(\"PATH\"); char *p = strtok(path, \":\"); char supath[PATH_MAX]; do { sprintf(supath, \"%s/su\", p); if (access(supath, F_OK) == 0) { LOGW(\"Found su at %s\", supath); return 1; } } while ((p = strtok(NULL, \":\")) != NULL); return 0; } 代码比较少，很容易理解，通过获取系统环境变量path的值来确定当前有哪些可执行文件的目录，再依次遍历这些目录检测是否存在su文件，系统环境变量path内的路径通常是 selene:/ $ echo $PATH /product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin selene:/ $ 思路 之所以要检测这些可执行文件的目录是否存在su文件是因为正常情况下，root过的手机都会依照传统方式通过执行su命令来提权切换到root用户下，那这就依靠在这些可执行文件的目录下放置su文件。对于Magisk来说，同样也是在每次启动后去动态修改bin目录，先是将magisk、magiskinit放入自身文件下的bin目录，再将例如su、magiskhide等做magisk的软链，最后通过bind mount同步到真实的bin目录下达到修改bin的效果 // native/jni/core/module.cpp static void inject_magisk_bins(root_node *system) { auto bin = system-\u003echild\u003cinter_node\u003e(\"bin\"); if (!bin) { bin = new inter_node(\"bin\", \"\"); system-\u003einsert(bin); } // Insert binaries bin-\u003einsert(new magisk_node(\"magisk\")); bin-\u003einsert(new magisk_node(\"magiskinit\")); // Also delete all applets to make sure no modules can override it for (int i = 0; applet_names[i]; ++i) delete bin-\u003eextract(applet_names[i]); for (int i = 0; init_applet[i]; ++i) delete bin-\u003eextract(init_applet[i]); } class magisk_node : public node_entry { public: explicit magisk_node(const char *name) : node_entry(name, DT_REG, this) {} void mount() override { const string \u0026dir_name = parent()-\u003enode_path(); if (name() == \"magisk\") { for (int i = 0; applet_names[i]; ++i) { string dest = dir_name + \"/\" + applet_names[i]; VLOGD(\"create\", \"./magisk\", dest.data()); xsymlink(\"./magisk\", dest.data()); } } else { for (int i = 0; init_applet[i]; ++i) { string dest = dir_name + \"/\" + init_applet[i]; VLOGD(\"create\", \"./magiskinit\", dest.data()); xsymlink(\"./magiskinit\", dest.data()); } } create_and_mount(MAGISKTMP + \"/\" + name()); } }; 所以，可以在/system/bin目录下看到magisk所做的变动，通过这个方面来检测magisk selene:/ $ ls -al /system/bin |grep magisk -rwxr-xr-x 1 root root 170224 2023-06-16 17:00 magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 magiskhide -\u003e ./magisk -rwxr-xr-x 1 root root 3987848 2023-06-16 17:00 magiskinit lrwxrwxrwx 1 root root 12 2023-06-16 17:00 magiskpolicy -\u003e ./magiskinit lrwxrwxrwx 1 root root 8 2023-06-16 17:00 resetprop -\u003e ./magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 su -\u003e ./magisk lrwxrwxrwx 1 root root 12 2023-06-16 17:00 supolicy -\u003e ./magiskinit 1.2 Magisk模块篡改系统文件检测 检测方式 static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) { dev_t data_dev = scan_mountinfo(); if (data_dev == 0) return -1; return scan_maps(data_dev); } static dev_t scan_mountinfo() { int major = 0; int minor = 0; char line[PATH_MAX]; char mountinfo[] = \"/proc/self/mountinfo\"; int fd = sys_open(mountinfo, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", mountinfo); return 0; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", mountinfo); close(fd); return 0; } // 遍历mountinfo文件，判断存在/ /data的行时拿它的设备号 while (fgets(line, PATH_MAX - 1, fp) != NULL) { if (strstr(line, \"/ /data \") != NULL) { sscanf(line, \"%*d %*d %d:%d\", \u0026major, \u0026minor); } } fclose(fp); // 根据major和minor创建设备号 return makedev(major, minor); } static int scan_maps(dev_t data_dev) { int module = 0; char line[PATH_MAX]; char maps[] = \"/proc/self/maps\"; int fd = sys_open(maps, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", maps); return -1; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", maps); close(fd); return -1; } while (fgets(line, PATH_MAX - 1, fp) != NULL) { // 在maps的内容里判断都否存在/data目录下的设备号 if (strchr(line, '/') == NULL) continue; if (strstr(line, \" /system/\") != NULL || strstr(line, \" /vendor/\") != NULL || strstr(line, \" /product/\") !=","date":"2023-06-17","objectID":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"Magisk检测方式","uri":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/#一市面现存的检测方式"},{"categories":["Magisk生态"],"content":" 一、市面现存的检测方式 1 Magisk Detector来源于Magisk Detector（现已停止维护），我们可以从官方的细节文档看出它之前的设计思路 ，目前从最新的代码上看，仅仅存在三种检测方式 JNINativeMethod methods[] = { {\"haveSu\", \"()I\", haveSu}, {\"haveMagiskHide\", \"()I\", haveMagiskHide}, {\"haveMagicMount\", \"()I\", haveMagicMount}, }; 1.1 su文件检测 检测方式 static int scan_path() { char *path = getenv(\"PATH\"); char *p = strtok(path, \":\"); char supath[PATH_MAX]; do { sprintf(supath, \"%s/su\", p); if (access(supath, F_OK) == 0) { LOGW(\"Found su at %s\", supath); return 1; } } while ((p = strtok(NULL, \":\")) != NULL); return 0; } 代码比较少，很容易理解，通过获取系统环境变量path的值来确定当前有哪些可执行文件的目录，再依次遍历这些目录检测是否存在su文件，系统环境变量path内的路径通常是 selene:/ $ echo $PATH /product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin selene:/ $ 思路 之所以要检测这些可执行文件的目录是否存在su文件是因为正常情况下，root过的手机都会依照传统方式通过执行su命令来提权切换到root用户下，那这就依靠在这些可执行文件的目录下放置su文件。对于Magisk来说，同样也是在每次启动后去动态修改bin目录，先是将magisk、magiskinit放入自身文件下的bin目录，再将例如su、magiskhide等做magisk的软链，最后通过bind mount同步到真实的bin目录下达到修改bin的效果 // native/jni/core/module.cpp static void inject_magisk_bins(root_node *system) { auto bin = system-\u003echild(\"bin\"); if (!bin) { bin = new inter_node(\"bin\", \"\"); system-\u003einsert(bin); } // Insert binaries bin-\u003einsert(new magisk_node(\"magisk\")); bin-\u003einsert(new magisk_node(\"magiskinit\")); // Also delete all applets to make sure no modules can override it for (int i = 0; applet_names[i]; ++i) delete bin-\u003eextract(applet_names[i]); for (int i = 0; init_applet[i]; ++i) delete bin-\u003eextract(init_applet[i]); } class magisk_node : public node_entry { public: explicit magisk_node(const char *name) : node_entry(name, DT_REG, this) {} void mount() override { const string \u0026dir_name = parent()-\u003enode_path(); if (name() == \"magisk\") { for (int i = 0; applet_names[i]; ++i) { string dest = dir_name + \"/\" + applet_names[i]; VLOGD(\"create\", \"./magisk\", dest.data()); xsymlink(\"./magisk\", dest.data()); } } else { for (int i = 0; init_applet[i]; ++i) { string dest = dir_name + \"/\" + init_applet[i]; VLOGD(\"create\", \"./magiskinit\", dest.data()); xsymlink(\"./magiskinit\", dest.data()); } } create_and_mount(MAGISKTMP + \"/\" + name()); } }; 所以，可以在/system/bin目录下看到magisk所做的变动，通过这个方面来检测magisk selene:/ $ ls -al /system/bin |grep magisk -rwxr-xr-x 1 root root 170224 2023-06-16 17:00 magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 magiskhide -\u003e ./magisk -rwxr-xr-x 1 root root 3987848 2023-06-16 17:00 magiskinit lrwxrwxrwx 1 root root 12 2023-06-16 17:00 magiskpolicy -\u003e ./magiskinit lrwxrwxrwx 1 root root 8 2023-06-16 17:00 resetprop -\u003e ./magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 su -\u003e ./magisk lrwxrwxrwx 1 root root 12 2023-06-16 17:00 supolicy -\u003e ./magiskinit 1.2 Magisk模块篡改系统文件检测 检测方式 static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) { dev_t data_dev = scan_mountinfo(); if (data_dev == 0) return -1; return scan_maps(data_dev); } static dev_t scan_mountinfo() { int major = 0; int minor = 0; char line[PATH_MAX]; char mountinfo[] = \"/proc/self/mountinfo\"; int fd = sys_open(mountinfo, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", mountinfo); return 0; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", mountinfo); close(fd); return 0; } // 遍历mountinfo文件，判断存在/ /data的行时拿它的设备号 while (fgets(line, PATH_MAX - 1, fp) != NULL) { if (strstr(line, \"/ /data \") != NULL) { sscanf(line, \"%*d %*d %d:%d\", \u0026major, \u0026minor); } } fclose(fp); // 根据major和minor创建设备号 return makedev(major, minor); } static int scan_maps(dev_t data_dev) { int module = 0; char line[PATH_MAX]; char maps[] = \"/proc/self/maps\"; int fd = sys_open(maps, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", maps); return -1; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", maps); close(fd); return -1; } while (fgets(line, PATH_MAX - 1, fp) != NULL) { // 在maps的内容里判断都否存在/data目录下的设备号 if (strchr(line, '/') == NULL) continue; if (strstr(line, \" /system/\") != NULL || strstr(line, \" /vendor/\") != NULL || strstr(line, \" /product/\") !=","date":"2023-06-17","objectID":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"Magisk检测方式","uri":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/#1-magisk-detector"},{"categories":["Magisk生态"],"content":" 一、市面现存的检测方式 1 Magisk Detector来源于Magisk Detector（现已停止维护），我们可以从官方的细节文档看出它之前的设计思路 ，目前从最新的代码上看，仅仅存在三种检测方式 JNINativeMethod methods[] = { {\"haveSu\", \"()I\", haveSu}, {\"haveMagiskHide\", \"()I\", haveMagiskHide}, {\"haveMagicMount\", \"()I\", haveMagicMount}, }; 1.1 su文件检测 检测方式 static int scan_path() { char *path = getenv(\"PATH\"); char *p = strtok(path, \":\"); char supath[PATH_MAX]; do { sprintf(supath, \"%s/su\", p); if (access(supath, F_OK) == 0) { LOGW(\"Found su at %s\", supath); return 1; } } while ((p = strtok(NULL, \":\")) != NULL); return 0; } 代码比较少，很容易理解，通过获取系统环境变量path的值来确定当前有哪些可执行文件的目录，再依次遍历这些目录检测是否存在su文件，系统环境变量path内的路径通常是 selene:/ $ echo $PATH /product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin selene:/ $ 思路 之所以要检测这些可执行文件的目录是否存在su文件是因为正常情况下，root过的手机都会依照传统方式通过执行su命令来提权切换到root用户下，那这就依靠在这些可执行文件的目录下放置su文件。对于Magisk来说，同样也是在每次启动后去动态修改bin目录，先是将magisk、magiskinit放入自身文件下的bin目录，再将例如su、magiskhide等做magisk的软链，最后通过bind mount同步到真实的bin目录下达到修改bin的效果 // native/jni/core/module.cpp static void inject_magisk_bins(root_node *system) { auto bin = system-\u003echild(\"bin\"); if (!bin) { bin = new inter_node(\"bin\", \"\"); system-\u003einsert(bin); } // Insert binaries bin-\u003einsert(new magisk_node(\"magisk\")); bin-\u003einsert(new magisk_node(\"magiskinit\")); // Also delete all applets to make sure no modules can override it for (int i = 0; applet_names[i]; ++i) delete bin-\u003eextract(applet_names[i]); for (int i = 0; init_applet[i]; ++i) delete bin-\u003eextract(init_applet[i]); } class magisk_node : public node_entry { public: explicit magisk_node(const char *name) : node_entry(name, DT_REG, this) {} void mount() override { const string \u0026dir_name = parent()-\u003enode_path(); if (name() == \"magisk\") { for (int i = 0; applet_names[i]; ++i) { string dest = dir_name + \"/\" + applet_names[i]; VLOGD(\"create\", \"./magisk\", dest.data()); xsymlink(\"./magisk\", dest.data()); } } else { for (int i = 0; init_applet[i]; ++i) { string dest = dir_name + \"/\" + init_applet[i]; VLOGD(\"create\", \"./magiskinit\", dest.data()); xsymlink(\"./magiskinit\", dest.data()); } } create_and_mount(MAGISKTMP + \"/\" + name()); } }; 所以，可以在/system/bin目录下看到magisk所做的变动，通过这个方面来检测magisk selene:/ $ ls -al /system/bin |grep magisk -rwxr-xr-x 1 root root 170224 2023-06-16 17:00 magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 magiskhide -\u003e ./magisk -rwxr-xr-x 1 root root 3987848 2023-06-16 17:00 magiskinit lrwxrwxrwx 1 root root 12 2023-06-16 17:00 magiskpolicy -\u003e ./magiskinit lrwxrwxrwx 1 root root 8 2023-06-16 17:00 resetprop -\u003e ./magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 su -\u003e ./magisk lrwxrwxrwx 1 root root 12 2023-06-16 17:00 supolicy -\u003e ./magiskinit 1.2 Magisk模块篡改系统文件检测 检测方式 static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) { dev_t data_dev = scan_mountinfo(); if (data_dev == 0) return -1; return scan_maps(data_dev); } static dev_t scan_mountinfo() { int major = 0; int minor = 0; char line[PATH_MAX]; char mountinfo[] = \"/proc/self/mountinfo\"; int fd = sys_open(mountinfo, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", mountinfo); return 0; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", mountinfo); close(fd); return 0; } // 遍历mountinfo文件，判断存在/ /data的行时拿它的设备号 while (fgets(line, PATH_MAX - 1, fp) != NULL) { if (strstr(line, \"/ /data \") != NULL) { sscanf(line, \"%*d %*d %d:%d\", \u0026major, \u0026minor); } } fclose(fp); // 根据major和minor创建设备号 return makedev(major, minor); } static int scan_maps(dev_t data_dev) { int module = 0; char line[PATH_MAX]; char maps[] = \"/proc/self/maps\"; int fd = sys_open(maps, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", maps); return -1; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", maps); close(fd); return -1; } while (fgets(line, PATH_MAX - 1, fp) != NULL) { // 在maps的内容里判断都否存在/data目录下的设备号 if (strchr(line, '/') == NULL) continue; if (strstr(line, \" /system/\") != NULL || strstr(line, \" /vendor/\") != NULL || strstr(line, \" /product/\") !=","date":"2023-06-17","objectID":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"Magisk检测方式","uri":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/#11-su文件检测"},{"categories":["Magisk生态"],"content":" 一、市面现存的检测方式 1 Magisk Detector来源于Magisk Detector（现已停止维护），我们可以从官方的细节文档看出它之前的设计思路 ，目前从最新的代码上看，仅仅存在三种检测方式 JNINativeMethod methods[] = { {\"haveSu\", \"()I\", haveSu}, {\"haveMagiskHide\", \"()I\", haveMagiskHide}, {\"haveMagicMount\", \"()I\", haveMagicMount}, }; 1.1 su文件检测 检测方式 static int scan_path() { char *path = getenv(\"PATH\"); char *p = strtok(path, \":\"); char supath[PATH_MAX]; do { sprintf(supath, \"%s/su\", p); if (access(supath, F_OK) == 0) { LOGW(\"Found su at %s\", supath); return 1; } } while ((p = strtok(NULL, \":\")) != NULL); return 0; } 代码比较少，很容易理解，通过获取系统环境变量path的值来确定当前有哪些可执行文件的目录，再依次遍历这些目录检测是否存在su文件，系统环境变量path内的路径通常是 selene:/ $ echo $PATH /product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin selene:/ $ 思路 之所以要检测这些可执行文件的目录是否存在su文件是因为正常情况下，root过的手机都会依照传统方式通过执行su命令来提权切换到root用户下，那这就依靠在这些可执行文件的目录下放置su文件。对于Magisk来说，同样也是在每次启动后去动态修改bin目录，先是将magisk、magiskinit放入自身文件下的bin目录，再将例如su、magiskhide等做magisk的软链，最后通过bind mount同步到真实的bin目录下达到修改bin的效果 // native/jni/core/module.cpp static void inject_magisk_bins(root_node *system) { auto bin = system-\u003echild(\"bin\"); if (!bin) { bin = new inter_node(\"bin\", \"\"); system-\u003einsert(bin); } // Insert binaries bin-\u003einsert(new magisk_node(\"magisk\")); bin-\u003einsert(new magisk_node(\"magiskinit\")); // Also delete all applets to make sure no modules can override it for (int i = 0; applet_names[i]; ++i) delete bin-\u003eextract(applet_names[i]); for (int i = 0; init_applet[i]; ++i) delete bin-\u003eextract(init_applet[i]); } class magisk_node : public node_entry { public: explicit magisk_node(const char *name) : node_entry(name, DT_REG, this) {} void mount() override { const string \u0026dir_name = parent()-\u003enode_path(); if (name() == \"magisk\") { for (int i = 0; applet_names[i]; ++i) { string dest = dir_name + \"/\" + applet_names[i]; VLOGD(\"create\", \"./magisk\", dest.data()); xsymlink(\"./magisk\", dest.data()); } } else { for (int i = 0; init_applet[i]; ++i) { string dest = dir_name + \"/\" + init_applet[i]; VLOGD(\"create\", \"./magiskinit\", dest.data()); xsymlink(\"./magiskinit\", dest.data()); } } create_and_mount(MAGISKTMP + \"/\" + name()); } }; 所以，可以在/system/bin目录下看到magisk所做的变动，通过这个方面来检测magisk selene:/ $ ls -al /system/bin |grep magisk -rwxr-xr-x 1 root root 170224 2023-06-16 17:00 magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 magiskhide -\u003e ./magisk -rwxr-xr-x 1 root root 3987848 2023-06-16 17:00 magiskinit lrwxrwxrwx 1 root root 12 2023-06-16 17:00 magiskpolicy -\u003e ./magiskinit lrwxrwxrwx 1 root root 8 2023-06-16 17:00 resetprop -\u003e ./magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 su -\u003e ./magisk lrwxrwxrwx 1 root root 12 2023-06-16 17:00 supolicy -\u003e ./magiskinit 1.2 Magisk模块篡改系统文件检测 检测方式 static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) { dev_t data_dev = scan_mountinfo(); if (data_dev == 0) return -1; return scan_maps(data_dev); } static dev_t scan_mountinfo() { int major = 0; int minor = 0; char line[PATH_MAX]; char mountinfo[] = \"/proc/self/mountinfo\"; int fd = sys_open(mountinfo, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", mountinfo); return 0; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", mountinfo); close(fd); return 0; } // 遍历mountinfo文件，判断存在/ /data的行时拿它的设备号 while (fgets(line, PATH_MAX - 1, fp) != NULL) { if (strstr(line, \"/ /data \") != NULL) { sscanf(line, \"%*d %*d %d:%d\", \u0026major, \u0026minor); } } fclose(fp); // 根据major和minor创建设备号 return makedev(major, minor); } static int scan_maps(dev_t data_dev) { int module = 0; char line[PATH_MAX]; char maps[] = \"/proc/self/maps\"; int fd = sys_open(maps, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", maps); return -1; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", maps); close(fd); return -1; } while (fgets(line, PATH_MAX - 1, fp) != NULL) { // 在maps的内容里判断都否存在/data目录下的设备号 if (strchr(line, '/') == NULL) continue; if (strstr(line, \" /system/\") != NULL || strstr(line, \" /vendor/\") != NULL || strstr(line, \" /product/\") !=","date":"2023-06-17","objectID":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"Magisk检测方式","uri":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/#12-magisk模块篡改系统文件检测"},{"categories":["Magisk生态"],"content":" 一、市面现存的检测方式 1 Magisk Detector来源于Magisk Detector（现已停止维护），我们可以从官方的细节文档看出它之前的设计思路 ，目前从最新的代码上看，仅仅存在三种检测方式 JNINativeMethod methods[] = { {\"haveSu\", \"()I\", haveSu}, {\"haveMagiskHide\", \"()I\", haveMagiskHide}, {\"haveMagicMount\", \"()I\", haveMagicMount}, }; 1.1 su文件检测 检测方式 static int scan_path() { char *path = getenv(\"PATH\"); char *p = strtok(path, \":\"); char supath[PATH_MAX]; do { sprintf(supath, \"%s/su\", p); if (access(supath, F_OK) == 0) { LOGW(\"Found su at %s\", supath); return 1; } } while ((p = strtok(NULL, \":\")) != NULL); return 0; } 代码比较少，很容易理解，通过获取系统环境变量path的值来确定当前有哪些可执行文件的目录，再依次遍历这些目录检测是否存在su文件，系统环境变量path内的路径通常是 selene:/ $ echo $PATH /product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin selene:/ $ 思路 之所以要检测这些可执行文件的目录是否存在su文件是因为正常情况下，root过的手机都会依照传统方式通过执行su命令来提权切换到root用户下，那这就依靠在这些可执行文件的目录下放置su文件。对于Magisk来说，同样也是在每次启动后去动态修改bin目录，先是将magisk、magiskinit放入自身文件下的bin目录，再将例如su、magiskhide等做magisk的软链，最后通过bind mount同步到真实的bin目录下达到修改bin的效果 // native/jni/core/module.cpp static void inject_magisk_bins(root_node *system) { auto bin = system-\u003echild(\"bin\"); if (!bin) { bin = new inter_node(\"bin\", \"\"); system-\u003einsert(bin); } // Insert binaries bin-\u003einsert(new magisk_node(\"magisk\")); bin-\u003einsert(new magisk_node(\"magiskinit\")); // Also delete all applets to make sure no modules can override it for (int i = 0; applet_names[i]; ++i) delete bin-\u003eextract(applet_names[i]); for (int i = 0; init_applet[i]; ++i) delete bin-\u003eextract(init_applet[i]); } class magisk_node : public node_entry { public: explicit magisk_node(const char *name) : node_entry(name, DT_REG, this) {} void mount() override { const string \u0026dir_name = parent()-\u003enode_path(); if (name() == \"magisk\") { for (int i = 0; applet_names[i]; ++i) { string dest = dir_name + \"/\" + applet_names[i]; VLOGD(\"create\", \"./magisk\", dest.data()); xsymlink(\"./magisk\", dest.data()); } } else { for (int i = 0; init_applet[i]; ++i) { string dest = dir_name + \"/\" + init_applet[i]; VLOGD(\"create\", \"./magiskinit\", dest.data()); xsymlink(\"./magiskinit\", dest.data()); } } create_and_mount(MAGISKTMP + \"/\" + name()); } }; 所以，可以在/system/bin目录下看到magisk所做的变动，通过这个方面来检测magisk selene:/ $ ls -al /system/bin |grep magisk -rwxr-xr-x 1 root root 170224 2023-06-16 17:00 magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 magiskhide -\u003e ./magisk -rwxr-xr-x 1 root root 3987848 2023-06-16 17:00 magiskinit lrwxrwxrwx 1 root root 12 2023-06-16 17:00 magiskpolicy -\u003e ./magiskinit lrwxrwxrwx 1 root root 8 2023-06-16 17:00 resetprop -\u003e ./magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 su -\u003e ./magisk lrwxrwxrwx 1 root root 12 2023-06-16 17:00 supolicy -\u003e ./magiskinit 1.2 Magisk模块篡改系统文件检测 检测方式 static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) { dev_t data_dev = scan_mountinfo(); if (data_dev == 0) return -1; return scan_maps(data_dev); } static dev_t scan_mountinfo() { int major = 0; int minor = 0; char line[PATH_MAX]; char mountinfo[] = \"/proc/self/mountinfo\"; int fd = sys_open(mountinfo, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", mountinfo); return 0; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", mountinfo); close(fd); return 0; } // 遍历mountinfo文件，判断存在/ /data的行时拿它的设备号 while (fgets(line, PATH_MAX - 1, fp) != NULL) { if (strstr(line, \"/ /data \") != NULL) { sscanf(line, \"%*d %*d %d:%d\", \u0026major, \u0026minor); } } fclose(fp); // 根据major和minor创建设备号 return makedev(major, minor); } static int scan_maps(dev_t data_dev) { int module = 0; char line[PATH_MAX]; char maps[] = \"/proc/self/maps\"; int fd = sys_open(maps, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", maps); return -1; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", maps); close(fd); return -1; } while (fgets(line, PATH_MAX - 1, fp) != NULL) { // 在maps的内容里判断都否存在/data目录下的设备号 if (strchr(line, '/') == NULL) continue; if (strstr(line, \" /system/\") != NULL || strstr(line, \" /vendor/\") != NULL || strstr(line, \" /product/\") !=","date":"2023-06-17","objectID":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"Magisk检测方式","uri":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/#13-magisk-hide开启检测"},{"categories":["Magisk生态"],"content":" 一、市面现存的检测方式 1 Magisk Detector来源于Magisk Detector（现已停止维护），我们可以从官方的细节文档看出它之前的设计思路 ，目前从最新的代码上看，仅仅存在三种检测方式 JNINativeMethod methods[] = { {\"haveSu\", \"()I\", haveSu}, {\"haveMagiskHide\", \"()I\", haveMagiskHide}, {\"haveMagicMount\", \"()I\", haveMagicMount}, }; 1.1 su文件检测 检测方式 static int scan_path() { char *path = getenv(\"PATH\"); char *p = strtok(path, \":\"); char supath[PATH_MAX]; do { sprintf(supath, \"%s/su\", p); if (access(supath, F_OK) == 0) { LOGW(\"Found su at %s\", supath); return 1; } } while ((p = strtok(NULL, \":\")) != NULL); return 0; } 代码比较少，很容易理解，通过获取系统环境变量path的值来确定当前有哪些可执行文件的目录，再依次遍历这些目录检测是否存在su文件，系统环境变量path内的路径通常是 selene:/ $ echo $PATH /product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin selene:/ $ 思路 之所以要检测这些可执行文件的目录是否存在su文件是因为正常情况下，root过的手机都会依照传统方式通过执行su命令来提权切换到root用户下，那这就依靠在这些可执行文件的目录下放置su文件。对于Magisk来说，同样也是在每次启动后去动态修改bin目录，先是将magisk、magiskinit放入自身文件下的bin目录，再将例如su、magiskhide等做magisk的软链，最后通过bind mount同步到真实的bin目录下达到修改bin的效果 // native/jni/core/module.cpp static void inject_magisk_bins(root_node *system) { auto bin = system-\u003echild(\"bin\"); if (!bin) { bin = new inter_node(\"bin\", \"\"); system-\u003einsert(bin); } // Insert binaries bin-\u003einsert(new magisk_node(\"magisk\")); bin-\u003einsert(new magisk_node(\"magiskinit\")); // Also delete all applets to make sure no modules can override it for (int i = 0; applet_names[i]; ++i) delete bin-\u003eextract(applet_names[i]); for (int i = 0; init_applet[i]; ++i) delete bin-\u003eextract(init_applet[i]); } class magisk_node : public node_entry { public: explicit magisk_node(const char *name) : node_entry(name, DT_REG, this) {} void mount() override { const string \u0026dir_name = parent()-\u003enode_path(); if (name() == \"magisk\") { for (int i = 0; applet_names[i]; ++i) { string dest = dir_name + \"/\" + applet_names[i]; VLOGD(\"create\", \"./magisk\", dest.data()); xsymlink(\"./magisk\", dest.data()); } } else { for (int i = 0; init_applet[i]; ++i) { string dest = dir_name + \"/\" + init_applet[i]; VLOGD(\"create\", \"./magiskinit\", dest.data()); xsymlink(\"./magiskinit\", dest.data()); } } create_and_mount(MAGISKTMP + \"/\" + name()); } }; 所以，可以在/system/bin目录下看到magisk所做的变动，通过这个方面来检测magisk selene:/ $ ls -al /system/bin |grep magisk -rwxr-xr-x 1 root root 170224 2023-06-16 17:00 magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 magiskhide -\u003e ./magisk -rwxr-xr-x 1 root root 3987848 2023-06-16 17:00 magiskinit lrwxrwxrwx 1 root root 12 2023-06-16 17:00 magiskpolicy -\u003e ./magiskinit lrwxrwxrwx 1 root root 8 2023-06-16 17:00 resetprop -\u003e ./magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 su -\u003e ./magisk lrwxrwxrwx 1 root root 12 2023-06-16 17:00 supolicy -\u003e ./magiskinit 1.2 Magisk模块篡改系统文件检测 检测方式 static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) { dev_t data_dev = scan_mountinfo(); if (data_dev == 0) return -1; return scan_maps(data_dev); } static dev_t scan_mountinfo() { int major = 0; int minor = 0; char line[PATH_MAX]; char mountinfo[] = \"/proc/self/mountinfo\"; int fd = sys_open(mountinfo, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", mountinfo); return 0; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", mountinfo); close(fd); return 0; } // 遍历mountinfo文件，判断存在/ /data的行时拿它的设备号 while (fgets(line, PATH_MAX - 1, fp) != NULL) { if (strstr(line, \"/ /data \") != NULL) { sscanf(line, \"%*d %*d %d:%d\", \u0026major, \u0026minor); } } fclose(fp); // 根据major和minor创建设备号 return makedev(major, minor); } static int scan_maps(dev_t data_dev) { int module = 0; char line[PATH_MAX]; char maps[] = \"/proc/self/maps\"; int fd = sys_open(maps, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", maps); return -1; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", maps); close(fd); return -1; } while (fgets(line, PATH_MAX - 1, fp) != NULL) { // 在maps的内容里判断都否存在/data目录下的设备号 if (strchr(line, '/') == NULL) continue; if (strstr(line, \" /system/\") != NULL || strstr(line, \" /vendor/\") != NULL || strstr(line, \" /product/\") !=","date":"2023-06-17","objectID":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"Magisk检测方式","uri":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/#2-detectmagiskhide"},{"categories":["Magisk生态"],"content":" 一、市面现存的检测方式 1 Magisk Detector来源于Magisk Detector（现已停止维护），我们可以从官方的细节文档看出它之前的设计思路 ，目前从最新的代码上看，仅仅存在三种检测方式 JNINativeMethod methods[] = { {\"haveSu\", \"()I\", haveSu}, {\"haveMagiskHide\", \"()I\", haveMagiskHide}, {\"haveMagicMount\", \"()I\", haveMagicMount}, }; 1.1 su文件检测 检测方式 static int scan_path() { char *path = getenv(\"PATH\"); char *p = strtok(path, \":\"); char supath[PATH_MAX]; do { sprintf(supath, \"%s/su\", p); if (access(supath, F_OK) == 0) { LOGW(\"Found su at %s\", supath); return 1; } } while ((p = strtok(NULL, \":\")) != NULL); return 0; } 代码比较少，很容易理解，通过获取系统环境变量path的值来确定当前有哪些可执行文件的目录，再依次遍历这些目录检测是否存在su文件，系统环境变量path内的路径通常是 selene:/ $ echo $PATH /product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin selene:/ $ 思路 之所以要检测这些可执行文件的目录是否存在su文件是因为正常情况下，root过的手机都会依照传统方式通过执行su命令来提权切换到root用户下，那这就依靠在这些可执行文件的目录下放置su文件。对于Magisk来说，同样也是在每次启动后去动态修改bin目录，先是将magisk、magiskinit放入自身文件下的bin目录，再将例如su、magiskhide等做magisk的软链，最后通过bind mount同步到真实的bin目录下达到修改bin的效果 // native/jni/core/module.cpp static void inject_magisk_bins(root_node *system) { auto bin = system-\u003echild(\"bin\"); if (!bin) { bin = new inter_node(\"bin\", \"\"); system-\u003einsert(bin); } // Insert binaries bin-\u003einsert(new magisk_node(\"magisk\")); bin-\u003einsert(new magisk_node(\"magiskinit\")); // Also delete all applets to make sure no modules can override it for (int i = 0; applet_names[i]; ++i) delete bin-\u003eextract(applet_names[i]); for (int i = 0; init_applet[i]; ++i) delete bin-\u003eextract(init_applet[i]); } class magisk_node : public node_entry { public: explicit magisk_node(const char *name) : node_entry(name, DT_REG, this) {} void mount() override { const string \u0026dir_name = parent()-\u003enode_path(); if (name() == \"magisk\") { for (int i = 0; applet_names[i]; ++i) { string dest = dir_name + \"/\" + applet_names[i]; VLOGD(\"create\", \"./magisk\", dest.data()); xsymlink(\"./magisk\", dest.data()); } } else { for (int i = 0; init_applet[i]; ++i) { string dest = dir_name + \"/\" + init_applet[i]; VLOGD(\"create\", \"./magiskinit\", dest.data()); xsymlink(\"./magiskinit\", dest.data()); } } create_and_mount(MAGISKTMP + \"/\" + name()); } }; 所以，可以在/system/bin目录下看到magisk所做的变动，通过这个方面来检测magisk selene:/ $ ls -al /system/bin |grep magisk -rwxr-xr-x 1 root root 170224 2023-06-16 17:00 magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 magiskhide -\u003e ./magisk -rwxr-xr-x 1 root root 3987848 2023-06-16 17:00 magiskinit lrwxrwxrwx 1 root root 12 2023-06-16 17:00 magiskpolicy -\u003e ./magiskinit lrwxrwxrwx 1 root root 8 2023-06-16 17:00 resetprop -\u003e ./magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 su -\u003e ./magisk lrwxrwxrwx 1 root root 12 2023-06-16 17:00 supolicy -\u003e ./magiskinit 1.2 Magisk模块篡改系统文件检测 检测方式 static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) { dev_t data_dev = scan_mountinfo(); if (data_dev == 0) return -1; return scan_maps(data_dev); } static dev_t scan_mountinfo() { int major = 0; int minor = 0; char line[PATH_MAX]; char mountinfo[] = \"/proc/self/mountinfo\"; int fd = sys_open(mountinfo, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", mountinfo); return 0; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", mountinfo); close(fd); return 0; } // 遍历mountinfo文件，判断存在/ /data的行时拿它的设备号 while (fgets(line, PATH_MAX - 1, fp) != NULL) { if (strstr(line, \"/ /data \") != NULL) { sscanf(line, \"%*d %*d %d:%d\", \u0026major, \u0026minor); } } fclose(fp); // 根据major和minor创建设备号 return makedev(major, minor); } static int scan_maps(dev_t data_dev) { int module = 0; char line[PATH_MAX]; char maps[] = \"/proc/self/maps\"; int fd = sys_open(maps, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", maps); return -1; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", maps); close(fd); return -1; } while (fgets(line, PATH_MAX - 1, fp) != NULL) { // 在maps的内容里判断都否存在/data目录下的设备号 if (strchr(line, '/') == NULL) continue; if (strstr(line, \" /system/\") != NULL || strstr(line, \" /vendor/\") != NULL || strstr(line, \" /product/\") !=","date":"2023-06-17","objectID":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"Magisk检测方式","uri":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/#21-su文件检测"},{"categories":["Magisk生态"],"content":" 一、市面现存的检测方式 1 Magisk Detector来源于Magisk Detector（现已停止维护），我们可以从官方的细节文档看出它之前的设计思路 ，目前从最新的代码上看，仅仅存在三种检测方式 JNINativeMethod methods[] = { {\"haveSu\", \"()I\", haveSu}, {\"haveMagiskHide\", \"()I\", haveMagiskHide}, {\"haveMagicMount\", \"()I\", haveMagicMount}, }; 1.1 su文件检测 检测方式 static int scan_path() { char *path = getenv(\"PATH\"); char *p = strtok(path, \":\"); char supath[PATH_MAX]; do { sprintf(supath, \"%s/su\", p); if (access(supath, F_OK) == 0) { LOGW(\"Found su at %s\", supath); return 1; } } while ((p = strtok(NULL, \":\")) != NULL); return 0; } 代码比较少，很容易理解，通过获取系统环境变量path的值来确定当前有哪些可执行文件的目录，再依次遍历这些目录检测是否存在su文件，系统环境变量path内的路径通常是 selene:/ $ echo $PATH /product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin selene:/ $ 思路 之所以要检测这些可执行文件的目录是否存在su文件是因为正常情况下，root过的手机都会依照传统方式通过执行su命令来提权切换到root用户下，那这就依靠在这些可执行文件的目录下放置su文件。对于Magisk来说，同样也是在每次启动后去动态修改bin目录，先是将magisk、magiskinit放入自身文件下的bin目录，再将例如su、magiskhide等做magisk的软链，最后通过bind mount同步到真实的bin目录下达到修改bin的效果 // native/jni/core/module.cpp static void inject_magisk_bins(root_node *system) { auto bin = system-\u003echild(\"bin\"); if (!bin) { bin = new inter_node(\"bin\", \"\"); system-\u003einsert(bin); } // Insert binaries bin-\u003einsert(new magisk_node(\"magisk\")); bin-\u003einsert(new magisk_node(\"magiskinit\")); // Also delete all applets to make sure no modules can override it for (int i = 0; applet_names[i]; ++i) delete bin-\u003eextract(applet_names[i]); for (int i = 0; init_applet[i]; ++i) delete bin-\u003eextract(init_applet[i]); } class magisk_node : public node_entry { public: explicit magisk_node(const char *name) : node_entry(name, DT_REG, this) {} void mount() override { const string \u0026dir_name = parent()-\u003enode_path(); if (name() == \"magisk\") { for (int i = 0; applet_names[i]; ++i) { string dest = dir_name + \"/\" + applet_names[i]; VLOGD(\"create\", \"./magisk\", dest.data()); xsymlink(\"./magisk\", dest.data()); } } else { for (int i = 0; init_applet[i]; ++i) { string dest = dir_name + \"/\" + init_applet[i]; VLOGD(\"create\", \"./magiskinit\", dest.data()); xsymlink(\"./magiskinit\", dest.data()); } } create_and_mount(MAGISKTMP + \"/\" + name()); } }; 所以，可以在/system/bin目录下看到magisk所做的变动，通过这个方面来检测magisk selene:/ $ ls -al /system/bin |grep magisk -rwxr-xr-x 1 root root 170224 2023-06-16 17:00 magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 magiskhide -\u003e ./magisk -rwxr-xr-x 1 root root 3987848 2023-06-16 17:00 magiskinit lrwxrwxrwx 1 root root 12 2023-06-16 17:00 magiskpolicy -\u003e ./magiskinit lrwxrwxrwx 1 root root 8 2023-06-16 17:00 resetprop -\u003e ./magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 su -\u003e ./magisk lrwxrwxrwx 1 root root 12 2023-06-16 17:00 supolicy -\u003e ./magiskinit 1.2 Magisk模块篡改系统文件检测 检测方式 static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) { dev_t data_dev = scan_mountinfo(); if (data_dev == 0) return -1; return scan_maps(data_dev); } static dev_t scan_mountinfo() { int major = 0; int minor = 0; char line[PATH_MAX]; char mountinfo[] = \"/proc/self/mountinfo\"; int fd = sys_open(mountinfo, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", mountinfo); return 0; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", mountinfo); close(fd); return 0; } // 遍历mountinfo文件，判断存在/ /data的行时拿它的设备号 while (fgets(line, PATH_MAX - 1, fp) != NULL) { if (strstr(line, \"/ /data \") != NULL) { sscanf(line, \"%*d %*d %d:%d\", \u0026major, \u0026minor); } } fclose(fp); // 根据major和minor创建设备号 return makedev(major, minor); } static int scan_maps(dev_t data_dev) { int module = 0; char line[PATH_MAX]; char maps[] = \"/proc/self/maps\"; int fd = sys_open(maps, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", maps); return -1; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", maps); close(fd); return -1; } while (fgets(line, PATH_MAX - 1, fp) != NULL) { // 在maps的内容里判断都否存在/data目录下的设备号 if (strchr(line, '/') == NULL) continue; if (strstr(line, \" /system/\") != NULL || strstr(line, \" /vendor/\") != NULL || strstr(line, \" /product/\") !=","date":"2023-06-17","objectID":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"Magisk检测方式","uri":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/#22-mount文件检测"},{"categories":["Magisk生态"],"content":" 一、市面现存的检测方式 1 Magisk Detector来源于Magisk Detector（现已停止维护），我们可以从官方的细节文档看出它之前的设计思路 ，目前从最新的代码上看，仅仅存在三种检测方式 JNINativeMethod methods[] = { {\"haveSu\", \"()I\", haveSu}, {\"haveMagiskHide\", \"()I\", haveMagiskHide}, {\"haveMagicMount\", \"()I\", haveMagicMount}, }; 1.1 su文件检测 检测方式 static int scan_path() { char *path = getenv(\"PATH\"); char *p = strtok(path, \":\"); char supath[PATH_MAX]; do { sprintf(supath, \"%s/su\", p); if (access(supath, F_OK) == 0) { LOGW(\"Found su at %s\", supath); return 1; } } while ((p = strtok(NULL, \":\")) != NULL); return 0; } 代码比较少，很容易理解，通过获取系统环境变量path的值来确定当前有哪些可执行文件的目录，再依次遍历这些目录检测是否存在su文件，系统环境变量path内的路径通常是 selene:/ $ echo $PATH /product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin selene:/ $ 思路 之所以要检测这些可执行文件的目录是否存在su文件是因为正常情况下，root过的手机都会依照传统方式通过执行su命令来提权切换到root用户下，那这就依靠在这些可执行文件的目录下放置su文件。对于Magisk来说，同样也是在每次启动后去动态修改bin目录，先是将magisk、magiskinit放入自身文件下的bin目录，再将例如su、magiskhide等做magisk的软链，最后通过bind mount同步到真实的bin目录下达到修改bin的效果 // native/jni/core/module.cpp static void inject_magisk_bins(root_node *system) { auto bin = system-\u003echild(\"bin\"); if (!bin) { bin = new inter_node(\"bin\", \"\"); system-\u003einsert(bin); } // Insert binaries bin-\u003einsert(new magisk_node(\"magisk\")); bin-\u003einsert(new magisk_node(\"magiskinit\")); // Also delete all applets to make sure no modules can override it for (int i = 0; applet_names[i]; ++i) delete bin-\u003eextract(applet_names[i]); for (int i = 0; init_applet[i]; ++i) delete bin-\u003eextract(init_applet[i]); } class magisk_node : public node_entry { public: explicit magisk_node(const char *name) : node_entry(name, DT_REG, this) {} void mount() override { const string \u0026dir_name = parent()-\u003enode_path(); if (name() == \"magisk\") { for (int i = 0; applet_names[i]; ++i) { string dest = dir_name + \"/\" + applet_names[i]; VLOGD(\"create\", \"./magisk\", dest.data()); xsymlink(\"./magisk\", dest.data()); } } else { for (int i = 0; init_applet[i]; ++i) { string dest = dir_name + \"/\" + init_applet[i]; VLOGD(\"create\", \"./magiskinit\", dest.data()); xsymlink(\"./magiskinit\", dest.data()); } } create_and_mount(MAGISKTMP + \"/\" + name()); } }; 所以，可以在/system/bin目录下看到magisk所做的变动，通过这个方面来检测magisk selene:/ $ ls -al /system/bin |grep magisk -rwxr-xr-x 1 root root 170224 2023-06-16 17:00 magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 magiskhide -\u003e ./magisk -rwxr-xr-x 1 root root 3987848 2023-06-16 17:00 magiskinit lrwxrwxrwx 1 root root 12 2023-06-16 17:00 magiskpolicy -\u003e ./magiskinit lrwxrwxrwx 1 root root 8 2023-06-16 17:00 resetprop -\u003e ./magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 su -\u003e ./magisk lrwxrwxrwx 1 root root 12 2023-06-16 17:00 supolicy -\u003e ./magiskinit 1.2 Magisk模块篡改系统文件检测 检测方式 static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) { dev_t data_dev = scan_mountinfo(); if (data_dev == 0) return -1; return scan_maps(data_dev); } static dev_t scan_mountinfo() { int major = 0; int minor = 0; char line[PATH_MAX]; char mountinfo[] = \"/proc/self/mountinfo\"; int fd = sys_open(mountinfo, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", mountinfo); return 0; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", mountinfo); close(fd); return 0; } // 遍历mountinfo文件，判断存在/ /data的行时拿它的设备号 while (fgets(line, PATH_MAX - 1, fp) != NULL) { if (strstr(line, \"/ /data \") != NULL) { sscanf(line, \"%*d %*d %d:%d\", \u0026major, \u0026minor); } } fclose(fp); // 根据major和minor创建设备号 return makedev(major, minor); } static int scan_maps(dev_t data_dev) { int module = 0; char line[PATH_MAX]; char maps[] = \"/proc/self/maps\"; int fd = sys_open(maps, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", maps); return -1; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", maps); close(fd); return -1; } while (fgets(line, PATH_MAX - 1, fp) != NULL) { // 在maps的内容里判断都否存在/data目录下的设备号 if (strchr(line, '/') == NULL) continue; if (strstr(line, \" /system/\") != NULL || strstr(line, \" /vendor/\") != NULL || strstr(line, \" /product/\") !=","date":"2023-06-17","objectID":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"Magisk检测方式","uri":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/#3-magiskkiller"},{"categories":["Magisk生态"],"content":" 一、市面现存的检测方式 1 Magisk Detector来源于Magisk Detector（现已停止维护），我们可以从官方的细节文档看出它之前的设计思路 ，目前从最新的代码上看，仅仅存在三种检测方式 JNINativeMethod methods[] = { {\"haveSu\", \"()I\", haveSu}, {\"haveMagiskHide\", \"()I\", haveMagiskHide}, {\"haveMagicMount\", \"()I\", haveMagicMount}, }; 1.1 su文件检测 检测方式 static int scan_path() { char *path = getenv(\"PATH\"); char *p = strtok(path, \":\"); char supath[PATH_MAX]; do { sprintf(supath, \"%s/su\", p); if (access(supath, F_OK) == 0) { LOGW(\"Found su at %s\", supath); return 1; } } while ((p = strtok(NULL, \":\")) != NULL); return 0; } 代码比较少，很容易理解，通过获取系统环境变量path的值来确定当前有哪些可执行文件的目录，再依次遍历这些目录检测是否存在su文件，系统环境变量path内的路径通常是 selene:/ $ echo $PATH /product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin selene:/ $ 思路 之所以要检测这些可执行文件的目录是否存在su文件是因为正常情况下，root过的手机都会依照传统方式通过执行su命令来提权切换到root用户下，那这就依靠在这些可执行文件的目录下放置su文件。对于Magisk来说，同样也是在每次启动后去动态修改bin目录，先是将magisk、magiskinit放入自身文件下的bin目录，再将例如su、magiskhide等做magisk的软链，最后通过bind mount同步到真实的bin目录下达到修改bin的效果 // native/jni/core/module.cpp static void inject_magisk_bins(root_node *system) { auto bin = system-\u003echild(\"bin\"); if (!bin) { bin = new inter_node(\"bin\", \"\"); system-\u003einsert(bin); } // Insert binaries bin-\u003einsert(new magisk_node(\"magisk\")); bin-\u003einsert(new magisk_node(\"magiskinit\")); // Also delete all applets to make sure no modules can override it for (int i = 0; applet_names[i]; ++i) delete bin-\u003eextract(applet_names[i]); for (int i = 0; init_applet[i]; ++i) delete bin-\u003eextract(init_applet[i]); } class magisk_node : public node_entry { public: explicit magisk_node(const char *name) : node_entry(name, DT_REG, this) {} void mount() override { const string \u0026dir_name = parent()-\u003enode_path(); if (name() == \"magisk\") { for (int i = 0; applet_names[i]; ++i) { string dest = dir_name + \"/\" + applet_names[i]; VLOGD(\"create\", \"./magisk\", dest.data()); xsymlink(\"./magisk\", dest.data()); } } else { for (int i = 0; init_applet[i]; ++i) { string dest = dir_name + \"/\" + init_applet[i]; VLOGD(\"create\", \"./magiskinit\", dest.data()); xsymlink(\"./magiskinit\", dest.data()); } } create_and_mount(MAGISKTMP + \"/\" + name()); } }; 所以，可以在/system/bin目录下看到magisk所做的变动，通过这个方面来检测magisk selene:/ $ ls -al /system/bin |grep magisk -rwxr-xr-x 1 root root 170224 2023-06-16 17:00 magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 magiskhide -\u003e ./magisk -rwxr-xr-x 1 root root 3987848 2023-06-16 17:00 magiskinit lrwxrwxrwx 1 root root 12 2023-06-16 17:00 magiskpolicy -\u003e ./magiskinit lrwxrwxrwx 1 root root 8 2023-06-16 17:00 resetprop -\u003e ./magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 su -\u003e ./magisk lrwxrwxrwx 1 root root 12 2023-06-16 17:00 supolicy -\u003e ./magiskinit 1.2 Magisk模块篡改系统文件检测 检测方式 static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) { dev_t data_dev = scan_mountinfo(); if (data_dev == 0) return -1; return scan_maps(data_dev); } static dev_t scan_mountinfo() { int major = 0; int minor = 0; char line[PATH_MAX]; char mountinfo[] = \"/proc/self/mountinfo\"; int fd = sys_open(mountinfo, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", mountinfo); return 0; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", mountinfo); close(fd); return 0; } // 遍历mountinfo文件，判断存在/ /data的行时拿它的设备号 while (fgets(line, PATH_MAX - 1, fp) != NULL) { if (strstr(line, \"/ /data \") != NULL) { sscanf(line, \"%*d %*d %d:%d\", \u0026major, \u0026minor); } } fclose(fp); // 根据major和minor创建设备号 return makedev(major, minor); } static int scan_maps(dev_t data_dev) { int module = 0; char line[PATH_MAX]; char maps[] = \"/proc/self/maps\"; int fd = sys_open(maps, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", maps); return -1; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", maps); close(fd); return -1; } while (fgets(line, PATH_MAX - 1, fp) != NULL) { // 在maps的内容里判断都否存在/data目录下的设备号 if (strchr(line, '/') == NULL) continue; if (strstr(line, \" /system/\") != NULL || strstr(line, \" /vendor/\") != NULL || strstr(line, \" /product/\") !=","date":"2023-06-17","objectID":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"Magisk检测方式","uri":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/#31-detectproperties"},{"categories":["Magisk生态"],"content":" 一、市面现存的检测方式 1 Magisk Detector来源于Magisk Detector（现已停止维护），我们可以从官方的细节文档看出它之前的设计思路 ，目前从最新的代码上看，仅仅存在三种检测方式 JNINativeMethod methods[] = { {\"haveSu\", \"()I\", haveSu}, {\"haveMagiskHide\", \"()I\", haveMagiskHide}, {\"haveMagicMount\", \"()I\", haveMagicMount}, }; 1.1 su文件检测 检测方式 static int scan_path() { char *path = getenv(\"PATH\"); char *p = strtok(path, \":\"); char supath[PATH_MAX]; do { sprintf(supath, \"%s/su\", p); if (access(supath, F_OK) == 0) { LOGW(\"Found su at %s\", supath); return 1; } } while ((p = strtok(NULL, \":\")) != NULL); return 0; } 代码比较少，很容易理解，通过获取系统环境变量path的值来确定当前有哪些可执行文件的目录，再依次遍历这些目录检测是否存在su文件，系统环境变量path内的路径通常是 selene:/ $ echo $PATH /product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin selene:/ $ 思路 之所以要检测这些可执行文件的目录是否存在su文件是因为正常情况下，root过的手机都会依照传统方式通过执行su命令来提权切换到root用户下，那这就依靠在这些可执行文件的目录下放置su文件。对于Magisk来说，同样也是在每次启动后去动态修改bin目录，先是将magisk、magiskinit放入自身文件下的bin目录，再将例如su、magiskhide等做magisk的软链，最后通过bind mount同步到真实的bin目录下达到修改bin的效果 // native/jni/core/module.cpp static void inject_magisk_bins(root_node *system) { auto bin = system-\u003echild(\"bin\"); if (!bin) { bin = new inter_node(\"bin\", \"\"); system-\u003einsert(bin); } // Insert binaries bin-\u003einsert(new magisk_node(\"magisk\")); bin-\u003einsert(new magisk_node(\"magiskinit\")); // Also delete all applets to make sure no modules can override it for (int i = 0; applet_names[i]; ++i) delete bin-\u003eextract(applet_names[i]); for (int i = 0; init_applet[i]; ++i) delete bin-\u003eextract(init_applet[i]); } class magisk_node : public node_entry { public: explicit magisk_node(const char *name) : node_entry(name, DT_REG, this) {} void mount() override { const string \u0026dir_name = parent()-\u003enode_path(); if (name() == \"magisk\") { for (int i = 0; applet_names[i]; ++i) { string dest = dir_name + \"/\" + applet_names[i]; VLOGD(\"create\", \"./magisk\", dest.data()); xsymlink(\"./magisk\", dest.data()); } } else { for (int i = 0; init_applet[i]; ++i) { string dest = dir_name + \"/\" + init_applet[i]; VLOGD(\"create\", \"./magiskinit\", dest.data()); xsymlink(\"./magiskinit\", dest.data()); } } create_and_mount(MAGISKTMP + \"/\" + name()); } }; 所以，可以在/system/bin目录下看到magisk所做的变动，通过这个方面来检测magisk selene:/ $ ls -al /system/bin |grep magisk -rwxr-xr-x 1 root root 170224 2023-06-16 17:00 magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 magiskhide -\u003e ./magisk -rwxr-xr-x 1 root root 3987848 2023-06-16 17:00 magiskinit lrwxrwxrwx 1 root root 12 2023-06-16 17:00 magiskpolicy -\u003e ./magiskinit lrwxrwxrwx 1 root root 8 2023-06-16 17:00 resetprop -\u003e ./magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 su -\u003e ./magisk lrwxrwxrwx 1 root root 12 2023-06-16 17:00 supolicy -\u003e ./magiskinit 1.2 Magisk模块篡改系统文件检测 检测方式 static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) { dev_t data_dev = scan_mountinfo(); if (data_dev == 0) return -1; return scan_maps(data_dev); } static dev_t scan_mountinfo() { int major = 0; int minor = 0; char line[PATH_MAX]; char mountinfo[] = \"/proc/self/mountinfo\"; int fd = sys_open(mountinfo, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", mountinfo); return 0; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", mountinfo); close(fd); return 0; } // 遍历mountinfo文件，判断存在/ /data的行时拿它的设备号 while (fgets(line, PATH_MAX - 1, fp) != NULL) { if (strstr(line, \"/ /data \") != NULL) { sscanf(line, \"%*d %*d %d:%d\", \u0026major, \u0026minor); } } fclose(fp); // 根据major和minor创建设备号 return makedev(major, minor); } static int scan_maps(dev_t data_dev) { int module = 0; char line[PATH_MAX]; char maps[] = \"/proc/self/maps\"; int fd = sys_open(maps, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", maps); return -1; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", maps); close(fd); return -1; } while (fgets(line, PATH_MAX - 1, fp) != NULL) { // 在maps的内容里判断都否存在/data目录下的设备号 if (strchr(line, '/') == NULL) continue; if (strstr(line, \" /system/\") != NULL || strstr(line, \" /vendor/\") != NULL || strstr(line, \" /product/\") !=","date":"2023-06-17","objectID":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"Magisk检测方式","uri":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/#32-detectmagiskpts"},{"categories":["Magisk生态"],"content":" 一、市面现存的检测方式 1 Magisk Detector来源于Magisk Detector（现已停止维护），我们可以从官方的细节文档看出它之前的设计思路 ，目前从最新的代码上看，仅仅存在三种检测方式 JNINativeMethod methods[] = { {\"haveSu\", \"()I\", haveSu}, {\"haveMagiskHide\", \"()I\", haveMagiskHide}, {\"haveMagicMount\", \"()I\", haveMagicMount}, }; 1.1 su文件检测 检测方式 static int scan_path() { char *path = getenv(\"PATH\"); char *p = strtok(path, \":\"); char supath[PATH_MAX]; do { sprintf(supath, \"%s/su\", p); if (access(supath, F_OK) == 0) { LOGW(\"Found su at %s\", supath); return 1; } } while ((p = strtok(NULL, \":\")) != NULL); return 0; } 代码比较少，很容易理解，通过获取系统环境变量path的值来确定当前有哪些可执行文件的目录，再依次遍历这些目录检测是否存在su文件，系统环境变量path内的路径通常是 selene:/ $ echo $PATH /product/bin:/apex/com.android.runtime/bin:/apex/com.android.art/bin:/system_ext/bin:/system/bin:/system/xbin:/odm/bin:/vendor/bin:/vendor/xbin selene:/ $ 思路 之所以要检测这些可执行文件的目录是否存在su文件是因为正常情况下，root过的手机都会依照传统方式通过执行su命令来提权切换到root用户下，那这就依靠在这些可执行文件的目录下放置su文件。对于Magisk来说，同样也是在每次启动后去动态修改bin目录，先是将magisk、magiskinit放入自身文件下的bin目录，再将例如su、magiskhide等做magisk的软链，最后通过bind mount同步到真实的bin目录下达到修改bin的效果 // native/jni/core/module.cpp static void inject_magisk_bins(root_node *system) { auto bin = system-\u003echild(\"bin\"); if (!bin) { bin = new inter_node(\"bin\", \"\"); system-\u003einsert(bin); } // Insert binaries bin-\u003einsert(new magisk_node(\"magisk\")); bin-\u003einsert(new magisk_node(\"magiskinit\")); // Also delete all applets to make sure no modules can override it for (int i = 0; applet_names[i]; ++i) delete bin-\u003eextract(applet_names[i]); for (int i = 0; init_applet[i]; ++i) delete bin-\u003eextract(init_applet[i]); } class magisk_node : public node_entry { public: explicit magisk_node(const char *name) : node_entry(name, DT_REG, this) {} void mount() override { const string \u0026dir_name = parent()-\u003enode_path(); if (name() == \"magisk\") { for (int i = 0; applet_names[i]; ++i) { string dest = dir_name + \"/\" + applet_names[i]; VLOGD(\"create\", \"./magisk\", dest.data()); xsymlink(\"./magisk\", dest.data()); } } else { for (int i = 0; init_applet[i]; ++i) { string dest = dir_name + \"/\" + init_applet[i]; VLOGD(\"create\", \"./magiskinit\", dest.data()); xsymlink(\"./magiskinit\", dest.data()); } } create_and_mount(MAGISKTMP + \"/\" + name()); } }; 所以，可以在/system/bin目录下看到magisk所做的变动，通过这个方面来检测magisk selene:/ $ ls -al /system/bin |grep magisk -rwxr-xr-x 1 root root 170224 2023-06-16 17:00 magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 magiskhide -\u003e ./magisk -rwxr-xr-x 1 root root 3987848 2023-06-16 17:00 magiskinit lrwxrwxrwx 1 root root 12 2023-06-16 17:00 magiskpolicy -\u003e ./magiskinit lrwxrwxrwx 1 root root 8 2023-06-16 17:00 resetprop -\u003e ./magisk lrwxrwxrwx 1 root root 8 2023-06-16 17:00 su -\u003e ./magisk lrwxrwxrwx 1 root root 12 2023-06-16 17:00 supolicy -\u003e ./magiskinit 1.2 Magisk模块篡改系统文件检测 检测方式 static jint haveMagicMount(JNIEnv *env __unused, jclass clazz __unused) { dev_t data_dev = scan_mountinfo(); if (data_dev == 0) return -1; return scan_maps(data_dev); } static dev_t scan_mountinfo() { int major = 0; int minor = 0; char line[PATH_MAX]; char mountinfo[] = \"/proc/self/mountinfo\"; int fd = sys_open(mountinfo, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", mountinfo); return 0; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", mountinfo); close(fd); return 0; } // 遍历mountinfo文件，判断存在/ /data的行时拿它的设备号 while (fgets(line, PATH_MAX - 1, fp) != NULL) { if (strstr(line, \"/ /data \") != NULL) { sscanf(line, \"%*d %*d %d:%d\", \u0026major, \u0026minor); } } fclose(fp); // 根据major和minor创建设备号 return makedev(major, minor); } static int scan_maps(dev_t data_dev) { int module = 0; char line[PATH_MAX]; char maps[] = \"/proc/self/maps\"; int fd = sys_open(maps, O_RDONLY, 0); if (fd \u003c 0) { LOGE(\"cannot open %s\", maps); return -1; } FILE *fp = fdopen(fd, \"r\"); if (fp == NULL) { LOGE(\"cannot open %s\", maps); close(fd); return -1; } while (fgets(line, PATH_MAX - 1, fp) != NULL) { // 在maps的内容里判断都否存在/data目录下的设备号 if (strchr(line, '/') == NULL) continue; if (strstr(line, \" /system/\") != NULL || strstr(line, \" /vendor/\") != NULL || strstr(line, \" /product/\") !=","date":"2023-06-17","objectID":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"Magisk检测方式","uri":"/magisk%E6%A3%80%E6%B5%8B%E6%96%B9%E5%BC%8F/#33-detecttracertask"},{"categories":["Magisk生态"],"content":" 前言承接上文，经过Magisk修补后的boot.img在启动引导过程中为了实现Root的功能很关键的一步在于patch了init.rc和sepolicy文件，在Magisk正式把init的执行权交由二阶段的原生init之后，便引导了Magisk deamon的启动 ","date":"2023-06-11","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节2","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/#前言"},{"categories":["Magisk生态"],"content":" 一、Magisk是如何工作的？ 1 init.rc首先了解下init.rc，它是一个配置文件，内部由Android初始化语言（Android Init Language）编写的脚本，主要包含五种类型语句：Action、Command、Service、Option 和 Import，关键的两种类型是Action和Service Action 以 “on” 关键字开头的action list //触发阶段 on early-init # Disable sysrq from keyboard write /proc/1/oom_score_adj -1000 # Set the security context of /adb_keys if present. restorecon /adb_keys ... ... # cgroup for system_server and surfaceflinger mkdir /dev/memcg/system 0550 system system start ueventd exec_start apexd-bootstrap Action简单理解是定义当触发XX阶段时应该执行的动作 Service service ueventd /system/bin/ueventd class core critical seclabel u:r:ueventd:s0 shutdown critical Service定义了进程，包括名称、权限、执行用户等等，一般都是由init进程通过fork产生子进程来启动 从源码上来看看init.rc是如何被解析并执行其中的类型语句的（以Android11的源码为例） // system/core/init/init.cpp static void LoadBootScripts(ActionManager\u0026 action_manager, ServiceList\u0026 service_list) { // 建立parser对象，传入的是ActionManager和ServiceList，对应init.rc的action和service Parser parser = CreateParser(action_manager, service_list); // 优先从属性中获取rc文件的path，正常情况下都是为空 std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\"); // 也就是在android11中init.rc都是存在/system/etc/init/hw/init.rc这个路径下 if (bootscript.empty()) { parser.ParseConfig(\"/system/etc/init/hw/init.rc\"); if (!parser.ParseConfig(\"/system/etc/init\")) { late_import_paths.emplace_back(\"/system/etc/init\"); } // late_import is available only in Q and earlier release. As we don't // have system_ext in those versions, skip late_import for system_ext. parser.ParseConfig(\"/system_ext/etc/init\"); if (!parser.ParseConfig(\"/vendor/etc/init\")) { late_import_paths.emplace_back(\"/vendor/etc/init\"); } if (!parser.ParseConfig(\"/odm/etc/init\")) { late_import_paths.emplace_back(\"/odm/etc/init\"); } if (!parser.ParseConfig(\"/product/etc/init\")) { late_import_paths.emplace_back(\"/product/etc/init\"); } } else { parser.ParseConfig(bootscript); } } // system/core/init/parser.cpp bool Parser::ParseConfig(const std::string\u0026 path) { if (is_dir(path.c_str())) { return ParseConfigDir(path); } // 只从文件角度来看看 auto result = ParseConfigFile(path); if (!result.ok()) { LOG(INFO) \u003c\u003c result.error(); } return result.ok(); } Result\u003cvoid\u003e Parser::ParseConfigFile(const std::string\u0026 path) { LOG(INFO) \u003c\u003c \"Parsing file \" \u003c\u003c path \u003c\u003c \"...\"; android::base::Timer t; // 读取文件内容 auto config_contents = ReadFile(path); if (!config_contents.ok()) { return Error() \u003c\u003c \"Unable to read config file '\" \u003c\u003c path \u003c\u003c \"': \" \u003c\u003c config_contents.error(); } // 将文件内容解析写入Parser类 ParseData(path, \u0026config_contents.value()); LOG(VERBOSE) \u003c\u003c \"(Parsing \" \u003c\u003c path \u003c\u003c \" took \" \u003c\u003c t \u003c\u003c \".)\"; return {}; } 以上这些步骤主要是init进程搜索init.rc并逐行解析init.rc文件，将文件中的action和service和传入的ActionManager和ServiceList关联起来等待后续触发 // system/core/init/init.cpp ActionManager\u0026 am = ActionManager::GetInstance(); ServiceList\u0026 sm = ServiceList::GetInstance(); // 完成init.rc解析与绑定 LoadBootScripts(am, sm); // Turning this on and letting the INFO logging be discarded adds 0.2s to // Nexus 9 boot time, so it's disabled by default. if (false) DumpState(); // Make the GSI status available before scripts start running. auto is_running = android::gsi::IsGsiRunning() ? \"1\" : \"0\"; SetProperty(gsi::kGsiBootedProp, is_running); auto is_installed = android::gsi::IsGsiInstalled() ? \"1\" : \"0\"; SetProperty(gsi::kGsiInstalledProp, is_installed); if (android::gsi::IsGsiRunning()) { std::string dsu_slot; if (android::gsi::GetActiveDsu(\u0026dsu_slot)) { SetProperty(gsi::kDsuSlotProp, dsu_slot); } } // 挂载触发时机 am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\"); am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\"); am.QueueBuiltinAction(TestPerfEventSelinuxAction, \"TestPerfEventSelinux\"); am.QueueBuiltinAction(ConnectEarlyStageSnapuserdAction, \"ConnectEarlyStageSnapuserd\"); am.QueueEventTrigger(\"early-init\"); ...... // Trigger all the boot actions to get us started. am.QueueEventTrigger(\"init\"); while (true) { ...... // 轮询监听，触发指令 if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) { am.ExecuteOneCommand(); // If there's more work to do, wake up a","date":"2023-06-11","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/:0:2","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节2","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/#一magisk是如何工作的"},{"categories":["Magisk生态"],"content":" 一、Magisk是如何工作的？ 1 init.rc首先了解下init.rc，它是一个配置文件，内部由Android初始化语言（Android Init Language）编写的脚本，主要包含五种类型语句：Action、Command、Service、Option 和 Import，关键的两种类型是Action和Service Action 以 “on” 关键字开头的action list //触发阶段 on early-init # Disable sysrq from keyboard write /proc/1/oom_score_adj -1000 # Set the security context of /adb_keys if present. restorecon /adb_keys ... ... # cgroup for system_server and surfaceflinger mkdir /dev/memcg/system 0550 system system start ueventd exec_start apexd-bootstrap Action简单理解是定义当触发XX阶段时应该执行的动作 Service service ueventd /system/bin/ueventd class core critical seclabel u:r:ueventd:s0 shutdown critical Service定义了进程，包括名称、权限、执行用户等等，一般都是由init进程通过fork产生子进程来启动 从源码上来看看init.rc是如何被解析并执行其中的类型语句的（以Android11的源码为例） // system/core/init/init.cpp static void LoadBootScripts(ActionManager\u0026 action_manager, ServiceList\u0026 service_list) { // 建立parser对象，传入的是ActionManager和ServiceList，对应init.rc的action和service Parser parser = CreateParser(action_manager, service_list); // 优先从属性中获取rc文件的path，正常情况下都是为空 std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\"); // 也就是在android11中init.rc都是存在/system/etc/init/hw/init.rc这个路径下 if (bootscript.empty()) { parser.ParseConfig(\"/system/etc/init/hw/init.rc\"); if (!parser.ParseConfig(\"/system/etc/init\")) { late_import_paths.emplace_back(\"/system/etc/init\"); } // late_import is available only in Q and earlier release. As we don't // have system_ext in those versions, skip late_import for system_ext. parser.ParseConfig(\"/system_ext/etc/init\"); if (!parser.ParseConfig(\"/vendor/etc/init\")) { late_import_paths.emplace_back(\"/vendor/etc/init\"); } if (!parser.ParseConfig(\"/odm/etc/init\")) { late_import_paths.emplace_back(\"/odm/etc/init\"); } if (!parser.ParseConfig(\"/product/etc/init\")) { late_import_paths.emplace_back(\"/product/etc/init\"); } } else { parser.ParseConfig(bootscript); } } // system/core/init/parser.cpp bool Parser::ParseConfig(const std::string\u0026 path) { if (is_dir(path.c_str())) { return ParseConfigDir(path); } // 只从文件角度来看看 auto result = ParseConfigFile(path); if (!result.ok()) { LOG(INFO) \u003c\u003c result.error(); } return result.ok(); } Result Parser::ParseConfigFile(const std::string\u0026 path) { LOG(INFO) \u003c\u003c \"Parsing file \" \u003c\u003c path \u003c\u003c \"...\"; android::base::Timer t; // 读取文件内容 auto config_contents = ReadFile(path); if (!config_contents.ok()) { return Error() \u003c\u003c \"Unable to read config file '\" \u003c\u003c path \u003c\u003c \"': \" \u003c\u003c config_contents.error(); } // 将文件内容解析写入Parser类 ParseData(path, \u0026config_contents.value()); LOG(VERBOSE) \u003c\u003c \"(Parsing \" \u003c\u003c path \u003c\u003c \" took \" \u003c\u003c t \u003c\u003c \".)\"; return {}; } 以上这些步骤主要是init进程搜索init.rc并逐行解析init.rc文件，将文件中的action和service和传入的ActionManager和ServiceList关联起来等待后续触发 // system/core/init/init.cpp ActionManager\u0026 am = ActionManager::GetInstance(); ServiceList\u0026 sm = ServiceList::GetInstance(); // 完成init.rc解析与绑定 LoadBootScripts(am, sm); // Turning this on and letting the INFO logging be discarded adds 0.2s to // Nexus 9 boot time, so it's disabled by default. if (false) DumpState(); // Make the GSI status available before scripts start running. auto is_running = android::gsi::IsGsiRunning() ? \"1\" : \"0\"; SetProperty(gsi::kGsiBootedProp, is_running); auto is_installed = android::gsi::IsGsiInstalled() ? \"1\" : \"0\"; SetProperty(gsi::kGsiInstalledProp, is_installed); if (android::gsi::IsGsiRunning()) { std::string dsu_slot; if (android::gsi::GetActiveDsu(\u0026dsu_slot)) { SetProperty(gsi::kDsuSlotProp, dsu_slot); } } // 挂载触发时机 am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\"); am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\"); am.QueueBuiltinAction(TestPerfEventSelinuxAction, \"TestPerfEventSelinux\"); am.QueueBuiltinAction(ConnectEarlyStageSnapuserdAction, \"ConnectEarlyStageSnapuserd\"); am.QueueEventTrigger(\"early-init\"); ...... // Trigger all the boot actions to get us started. am.QueueEventTrigger(\"init\"); while (true) { ...... // 轮询监听，触发指令 if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) { am.ExecuteOneCommand(); // If there's more work to do, wake up a","date":"2023-06-11","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/:0:2","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节2","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/#1-initrc"},{"categories":["Magisk生态"],"content":" 一、Magisk是如何工作的？ 1 init.rc首先了解下init.rc，它是一个配置文件，内部由Android初始化语言（Android Init Language）编写的脚本，主要包含五种类型语句：Action、Command、Service、Option 和 Import，关键的两种类型是Action和Service Action 以 “on” 关键字开头的action list //触发阶段 on early-init # Disable sysrq from keyboard write /proc/1/oom_score_adj -1000 # Set the security context of /adb_keys if present. restorecon /adb_keys ... ... # cgroup for system_server and surfaceflinger mkdir /dev/memcg/system 0550 system system start ueventd exec_start apexd-bootstrap Action简单理解是定义当触发XX阶段时应该执行的动作 Service service ueventd /system/bin/ueventd class core critical seclabel u:r:ueventd:s0 shutdown critical Service定义了进程，包括名称、权限、执行用户等等，一般都是由init进程通过fork产生子进程来启动 从源码上来看看init.rc是如何被解析并执行其中的类型语句的（以Android11的源码为例） // system/core/init/init.cpp static void LoadBootScripts(ActionManager\u0026 action_manager, ServiceList\u0026 service_list) { // 建立parser对象，传入的是ActionManager和ServiceList，对应init.rc的action和service Parser parser = CreateParser(action_manager, service_list); // 优先从属性中获取rc文件的path，正常情况下都是为空 std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\"); // 也就是在android11中init.rc都是存在/system/etc/init/hw/init.rc这个路径下 if (bootscript.empty()) { parser.ParseConfig(\"/system/etc/init/hw/init.rc\"); if (!parser.ParseConfig(\"/system/etc/init\")) { late_import_paths.emplace_back(\"/system/etc/init\"); } // late_import is available only in Q and earlier release. As we don't // have system_ext in those versions, skip late_import for system_ext. parser.ParseConfig(\"/system_ext/etc/init\"); if (!parser.ParseConfig(\"/vendor/etc/init\")) { late_import_paths.emplace_back(\"/vendor/etc/init\"); } if (!parser.ParseConfig(\"/odm/etc/init\")) { late_import_paths.emplace_back(\"/odm/etc/init\"); } if (!parser.ParseConfig(\"/product/etc/init\")) { late_import_paths.emplace_back(\"/product/etc/init\"); } } else { parser.ParseConfig(bootscript); } } // system/core/init/parser.cpp bool Parser::ParseConfig(const std::string\u0026 path) { if (is_dir(path.c_str())) { return ParseConfigDir(path); } // 只从文件角度来看看 auto result = ParseConfigFile(path); if (!result.ok()) { LOG(INFO) \u003c\u003c result.error(); } return result.ok(); } Result Parser::ParseConfigFile(const std::string\u0026 path) { LOG(INFO) \u003c\u003c \"Parsing file \" \u003c\u003c path \u003c\u003c \"...\"; android::base::Timer t; // 读取文件内容 auto config_contents = ReadFile(path); if (!config_contents.ok()) { return Error() \u003c\u003c \"Unable to read config file '\" \u003c\u003c path \u003c\u003c \"': \" \u003c\u003c config_contents.error(); } // 将文件内容解析写入Parser类 ParseData(path, \u0026config_contents.value()); LOG(VERBOSE) \u003c\u003c \"(Parsing \" \u003c\u003c path \u003c\u003c \" took \" \u003c\u003c t \u003c\u003c \".)\"; return {}; } 以上这些步骤主要是init进程搜索init.rc并逐行解析init.rc文件，将文件中的action和service和传入的ActionManager和ServiceList关联起来等待后续触发 // system/core/init/init.cpp ActionManager\u0026 am = ActionManager::GetInstance(); ServiceList\u0026 sm = ServiceList::GetInstance(); // 完成init.rc解析与绑定 LoadBootScripts(am, sm); // Turning this on and letting the INFO logging be discarded adds 0.2s to // Nexus 9 boot time, so it's disabled by default. if (false) DumpState(); // Make the GSI status available before scripts start running. auto is_running = android::gsi::IsGsiRunning() ? \"1\" : \"0\"; SetProperty(gsi::kGsiBootedProp, is_running); auto is_installed = android::gsi::IsGsiInstalled() ? \"1\" : \"0\"; SetProperty(gsi::kGsiInstalledProp, is_installed); if (android::gsi::IsGsiRunning()) { std::string dsu_slot; if (android::gsi::GetActiveDsu(\u0026dsu_slot)) { SetProperty(gsi::kDsuSlotProp, dsu_slot); } } // 挂载触发时机 am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\"); am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\"); am.QueueBuiltinAction(TestPerfEventSelinuxAction, \"TestPerfEventSelinux\"); am.QueueBuiltinAction(ConnectEarlyStageSnapuserdAction, \"ConnectEarlyStageSnapuserd\"); am.QueueEventTrigger(\"early-init\"); ...... // Trigger all the boot actions to get us started. am.QueueEventTrigger(\"init\"); while (true) { ...... // 轮询监听，触发指令 if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) { am.ExecuteOneCommand(); // If there's more work to do, wake up a","date":"2023-06-11","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/:0:2","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节2","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/#2-magisk-core"},{"categories":["Magisk生态"],"content":" 一、Magisk是如何工作的？ 1 init.rc首先了解下init.rc，它是一个配置文件，内部由Android初始化语言（Android Init Language）编写的脚本，主要包含五种类型语句：Action、Command、Service、Option 和 Import，关键的两种类型是Action和Service Action 以 “on” 关键字开头的action list //触发阶段 on early-init # Disable sysrq from keyboard write /proc/1/oom_score_adj -1000 # Set the security context of /adb_keys if present. restorecon /adb_keys ... ... # cgroup for system_server and surfaceflinger mkdir /dev/memcg/system 0550 system system start ueventd exec_start apexd-bootstrap Action简单理解是定义当触发XX阶段时应该执行的动作 Service service ueventd /system/bin/ueventd class core critical seclabel u:r:ueventd:s0 shutdown critical Service定义了进程，包括名称、权限、执行用户等等，一般都是由init进程通过fork产生子进程来启动 从源码上来看看init.rc是如何被解析并执行其中的类型语句的（以Android11的源码为例） // system/core/init/init.cpp static void LoadBootScripts(ActionManager\u0026 action_manager, ServiceList\u0026 service_list) { // 建立parser对象，传入的是ActionManager和ServiceList，对应init.rc的action和service Parser parser = CreateParser(action_manager, service_list); // 优先从属性中获取rc文件的path，正常情况下都是为空 std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\"); // 也就是在android11中init.rc都是存在/system/etc/init/hw/init.rc这个路径下 if (bootscript.empty()) { parser.ParseConfig(\"/system/etc/init/hw/init.rc\"); if (!parser.ParseConfig(\"/system/etc/init\")) { late_import_paths.emplace_back(\"/system/etc/init\"); } // late_import is available only in Q and earlier release. As we don't // have system_ext in those versions, skip late_import for system_ext. parser.ParseConfig(\"/system_ext/etc/init\"); if (!parser.ParseConfig(\"/vendor/etc/init\")) { late_import_paths.emplace_back(\"/vendor/etc/init\"); } if (!parser.ParseConfig(\"/odm/etc/init\")) { late_import_paths.emplace_back(\"/odm/etc/init\"); } if (!parser.ParseConfig(\"/product/etc/init\")) { late_import_paths.emplace_back(\"/product/etc/init\"); } } else { parser.ParseConfig(bootscript); } } // system/core/init/parser.cpp bool Parser::ParseConfig(const std::string\u0026 path) { if (is_dir(path.c_str())) { return ParseConfigDir(path); } // 只从文件角度来看看 auto result = ParseConfigFile(path); if (!result.ok()) { LOG(INFO) \u003c\u003c result.error(); } return result.ok(); } Result Parser::ParseConfigFile(const std::string\u0026 path) { LOG(INFO) \u003c\u003c \"Parsing file \" \u003c\u003c path \u003c\u003c \"...\"; android::base::Timer t; // 读取文件内容 auto config_contents = ReadFile(path); if (!config_contents.ok()) { return Error() \u003c\u003c \"Unable to read config file '\" \u003c\u003c path \u003c\u003c \"': \" \u003c\u003c config_contents.error(); } // 将文件内容解析写入Parser类 ParseData(path, \u0026config_contents.value()); LOG(VERBOSE) \u003c\u003c \"(Parsing \" \u003c\u003c path \u003c\u003c \" took \" \u003c\u003c t \u003c\u003c \".)\"; return {}; } 以上这些步骤主要是init进程搜索init.rc并逐行解析init.rc文件，将文件中的action和service和传入的ActionManager和ServiceList关联起来等待后续触发 // system/core/init/init.cpp ActionManager\u0026 am = ActionManager::GetInstance(); ServiceList\u0026 sm = ServiceList::GetInstance(); // 完成init.rc解析与绑定 LoadBootScripts(am, sm); // Turning this on and letting the INFO logging be discarded adds 0.2s to // Nexus 9 boot time, so it's disabled by default. if (false) DumpState(); // Make the GSI status available before scripts start running. auto is_running = android::gsi::IsGsiRunning() ? \"1\" : \"0\"; SetProperty(gsi::kGsiBootedProp, is_running); auto is_installed = android::gsi::IsGsiInstalled() ? \"1\" : \"0\"; SetProperty(gsi::kGsiInstalledProp, is_installed); if (android::gsi::IsGsiRunning()) { std::string dsu_slot; if (android::gsi::GetActiveDsu(\u0026dsu_slot)) { SetProperty(gsi::kDsuSlotProp, dsu_slot); } } // 挂载触发时机 am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\"); am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\"); am.QueueBuiltinAction(TestPerfEventSelinuxAction, \"TestPerfEventSelinux\"); am.QueueBuiltinAction(ConnectEarlyStageSnapuserdAction, \"ConnectEarlyStageSnapuserd\"); am.QueueEventTrigger(\"early-init\"); ...... // Trigger all the boot actions to get us started. am.QueueEventTrigger(\"init\"); while (true) { ...... // 轮询监听，触发指令 if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) { am.ExecuteOneCommand(); // If there's more work to do, wake up a","date":"2023-06-11","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/:0:2","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节2","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/#21-post-fs-data"},{"categories":["Magisk生态"],"content":" 一、Magisk是如何工作的？ 1 init.rc首先了解下init.rc，它是一个配置文件，内部由Android初始化语言（Android Init Language）编写的脚本，主要包含五种类型语句：Action、Command、Service、Option 和 Import，关键的两种类型是Action和Service Action 以 “on” 关键字开头的action list //触发阶段 on early-init # Disable sysrq from keyboard write /proc/1/oom_score_adj -1000 # Set the security context of /adb_keys if present. restorecon /adb_keys ... ... # cgroup for system_server and surfaceflinger mkdir /dev/memcg/system 0550 system system start ueventd exec_start apexd-bootstrap Action简单理解是定义当触发XX阶段时应该执行的动作 Service service ueventd /system/bin/ueventd class core critical seclabel u:r:ueventd:s0 shutdown critical Service定义了进程，包括名称、权限、执行用户等等，一般都是由init进程通过fork产生子进程来启动 从源码上来看看init.rc是如何被解析并执行其中的类型语句的（以Android11的源码为例） // system/core/init/init.cpp static void LoadBootScripts(ActionManager\u0026 action_manager, ServiceList\u0026 service_list) { // 建立parser对象，传入的是ActionManager和ServiceList，对应init.rc的action和service Parser parser = CreateParser(action_manager, service_list); // 优先从属性中获取rc文件的path，正常情况下都是为空 std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\"); // 也就是在android11中init.rc都是存在/system/etc/init/hw/init.rc这个路径下 if (bootscript.empty()) { parser.ParseConfig(\"/system/etc/init/hw/init.rc\"); if (!parser.ParseConfig(\"/system/etc/init\")) { late_import_paths.emplace_back(\"/system/etc/init\"); } // late_import is available only in Q and earlier release. As we don't // have system_ext in those versions, skip late_import for system_ext. parser.ParseConfig(\"/system_ext/etc/init\"); if (!parser.ParseConfig(\"/vendor/etc/init\")) { late_import_paths.emplace_back(\"/vendor/etc/init\"); } if (!parser.ParseConfig(\"/odm/etc/init\")) { late_import_paths.emplace_back(\"/odm/etc/init\"); } if (!parser.ParseConfig(\"/product/etc/init\")) { late_import_paths.emplace_back(\"/product/etc/init\"); } } else { parser.ParseConfig(bootscript); } } // system/core/init/parser.cpp bool Parser::ParseConfig(const std::string\u0026 path) { if (is_dir(path.c_str())) { return ParseConfigDir(path); } // 只从文件角度来看看 auto result = ParseConfigFile(path); if (!result.ok()) { LOG(INFO) \u003c\u003c result.error(); } return result.ok(); } Result Parser::ParseConfigFile(const std::string\u0026 path) { LOG(INFO) \u003c\u003c \"Parsing file \" \u003c\u003c path \u003c\u003c \"...\"; android::base::Timer t; // 读取文件内容 auto config_contents = ReadFile(path); if (!config_contents.ok()) { return Error() \u003c\u003c \"Unable to read config file '\" \u003c\u003c path \u003c\u003c \"': \" \u003c\u003c config_contents.error(); } // 将文件内容解析写入Parser类 ParseData(path, \u0026config_contents.value()); LOG(VERBOSE) \u003c\u003c \"(Parsing \" \u003c\u003c path \u003c\u003c \" took \" \u003c\u003c t \u003c\u003c \".)\"; return {}; } 以上这些步骤主要是init进程搜索init.rc并逐行解析init.rc文件，将文件中的action和service和传入的ActionManager和ServiceList关联起来等待后续触发 // system/core/init/init.cpp ActionManager\u0026 am = ActionManager::GetInstance(); ServiceList\u0026 sm = ServiceList::GetInstance(); // 完成init.rc解析与绑定 LoadBootScripts(am, sm); // Turning this on and letting the INFO logging be discarded adds 0.2s to // Nexus 9 boot time, so it's disabled by default. if (false) DumpState(); // Make the GSI status available before scripts start running. auto is_running = android::gsi::IsGsiRunning() ? \"1\" : \"0\"; SetProperty(gsi::kGsiBootedProp, is_running); auto is_installed = android::gsi::IsGsiInstalled() ? \"1\" : \"0\"; SetProperty(gsi::kGsiInstalledProp, is_installed); if (android::gsi::IsGsiRunning()) { std::string dsu_slot; if (android::gsi::GetActiveDsu(\u0026dsu_slot)) { SetProperty(gsi::kDsuSlotProp, dsu_slot); } } // 挂载触发时机 am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\"); am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\"); am.QueueBuiltinAction(TestPerfEventSelinuxAction, \"TestPerfEventSelinux\"); am.QueueBuiltinAction(ConnectEarlyStageSnapuserdAction, \"ConnectEarlyStageSnapuserd\"); am.QueueEventTrigger(\"early-init\"); ...... // Trigger all the boot actions to get us started. am.QueueEventTrigger(\"init\"); while (true) { ...... // 轮询监听，触发指令 if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) { am.ExecuteOneCommand(); // If there's more work to do, wake up a","date":"2023-06-11","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/:0:2","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节2","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/#22-service"},{"categories":["Magisk生态"],"content":" 一、Magisk是如何工作的？ 1 init.rc首先了解下init.rc，它是一个配置文件，内部由Android初始化语言（Android Init Language）编写的脚本，主要包含五种类型语句：Action、Command、Service、Option 和 Import，关键的两种类型是Action和Service Action 以 “on” 关键字开头的action list //触发阶段 on early-init # Disable sysrq from keyboard write /proc/1/oom_score_adj -1000 # Set the security context of /adb_keys if present. restorecon /adb_keys ... ... # cgroup for system_server and surfaceflinger mkdir /dev/memcg/system 0550 system system start ueventd exec_start apexd-bootstrap Action简单理解是定义当触发XX阶段时应该执行的动作 Service service ueventd /system/bin/ueventd class core critical seclabel u:r:ueventd:s0 shutdown critical Service定义了进程，包括名称、权限、执行用户等等，一般都是由init进程通过fork产生子进程来启动 从源码上来看看init.rc是如何被解析并执行其中的类型语句的（以Android11的源码为例） // system/core/init/init.cpp static void LoadBootScripts(ActionManager\u0026 action_manager, ServiceList\u0026 service_list) { // 建立parser对象，传入的是ActionManager和ServiceList，对应init.rc的action和service Parser parser = CreateParser(action_manager, service_list); // 优先从属性中获取rc文件的path，正常情况下都是为空 std::string bootscript = GetProperty(\"ro.boot.init_rc\", \"\"); // 也就是在android11中init.rc都是存在/system/etc/init/hw/init.rc这个路径下 if (bootscript.empty()) { parser.ParseConfig(\"/system/etc/init/hw/init.rc\"); if (!parser.ParseConfig(\"/system/etc/init\")) { late_import_paths.emplace_back(\"/system/etc/init\"); } // late_import is available only in Q and earlier release. As we don't // have system_ext in those versions, skip late_import for system_ext. parser.ParseConfig(\"/system_ext/etc/init\"); if (!parser.ParseConfig(\"/vendor/etc/init\")) { late_import_paths.emplace_back(\"/vendor/etc/init\"); } if (!parser.ParseConfig(\"/odm/etc/init\")) { late_import_paths.emplace_back(\"/odm/etc/init\"); } if (!parser.ParseConfig(\"/product/etc/init\")) { late_import_paths.emplace_back(\"/product/etc/init\"); } } else { parser.ParseConfig(bootscript); } } // system/core/init/parser.cpp bool Parser::ParseConfig(const std::string\u0026 path) { if (is_dir(path.c_str())) { return ParseConfigDir(path); } // 只从文件角度来看看 auto result = ParseConfigFile(path); if (!result.ok()) { LOG(INFO) \u003c\u003c result.error(); } return result.ok(); } Result Parser::ParseConfigFile(const std::string\u0026 path) { LOG(INFO) \u003c\u003c \"Parsing file \" \u003c\u003c path \u003c\u003c \"...\"; android::base::Timer t; // 读取文件内容 auto config_contents = ReadFile(path); if (!config_contents.ok()) { return Error() \u003c\u003c \"Unable to read config file '\" \u003c\u003c path \u003c\u003c \"': \" \u003c\u003c config_contents.error(); } // 将文件内容解析写入Parser类 ParseData(path, \u0026config_contents.value()); LOG(VERBOSE) \u003c\u003c \"(Parsing \" \u003c\u003c path \u003c\u003c \" took \" \u003c\u003c t \u003c\u003c \".)\"; return {}; } 以上这些步骤主要是init进程搜索init.rc并逐行解析init.rc文件，将文件中的action和service和传入的ActionManager和ServiceList关联起来等待后续触发 // system/core/init/init.cpp ActionManager\u0026 am = ActionManager::GetInstance(); ServiceList\u0026 sm = ServiceList::GetInstance(); // 完成init.rc解析与绑定 LoadBootScripts(am, sm); // Turning this on and letting the INFO logging be discarded adds 0.2s to // Nexus 9 boot time, so it's disabled by default. if (false) DumpState(); // Make the GSI status available before scripts start running. auto is_running = android::gsi::IsGsiRunning() ? \"1\" : \"0\"; SetProperty(gsi::kGsiBootedProp, is_running); auto is_installed = android::gsi::IsGsiInstalled() ? \"1\" : \"0\"; SetProperty(gsi::kGsiInstalledProp, is_installed); if (android::gsi::IsGsiRunning()) { std::string dsu_slot; if (android::gsi::GetActiveDsu(\u0026dsu_slot)) { SetProperty(gsi::kDsuSlotProp, dsu_slot); } } // 挂载触发时机 am.QueueBuiltinAction(SetupCgroupsAction, \"SetupCgroups\"); am.QueueBuiltinAction(SetKptrRestrictAction, \"SetKptrRestrict\"); am.QueueBuiltinAction(TestPerfEventSelinuxAction, \"TestPerfEventSelinux\"); am.QueueBuiltinAction(ConnectEarlyStageSnapuserdAction, \"ConnectEarlyStageSnapuserd\"); am.QueueEventTrigger(\"early-init\"); ...... // Trigger all the boot actions to get us started. am.QueueEventTrigger(\"init\"); while (true) { ...... // 轮询监听，触发指令 if (!(prop_waiter_state.MightBeWaiting() || Service::is_exec_service_running())) { am.ExecuteOneCommand(); // If there's more work to do, wake up a","date":"2023-06-11","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/:0:2","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节2","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%822/#23-boot-complete"},{"categories":["Magisk生态"],"content":" 前言相信Magisk对于移动安全从业者来说都不陌生了，我虽然也是一个版本接着一个版本的使用，但是始终没有去摸透Magisk的生态，希望借助之后想写的Magisk系列的文章来深度学习下Magisk，也正如Magisk在其主页所说的那样 Magisk is a suite of open source software for customizing Android, supporting devices higher than Android 6.0. Some highlight features: MagiskSU: Provide root access for applications Magisk Modules: Modify read-only partitions by installing modules MagiskBoot: The most complete tool for unpacking and repacking Android boot images Zygisk: Run code in every Android applications’ processes Magisk作为一套工具包，它的实现原理（包括它的su实现、boot patch、module机制等等）都是很值得去阅读理解的 ","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:1","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#前言"},{"categories":["Magisk生态"],"content":" 一、预备知识 boot.img的组成 android启动流程 android secure体系 linux存储 …… ","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:2","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#一预备知识"},{"categories":["Magisk生态"],"content":" 二、什么是Root？Android平台的基础是Linux内核，每个应用被严格控制运行在自己的沙盒中，不能越过边界，但是拥有Root权限就意味着你可以绕过内核的权限校验去任意执行你想要的功能。 ","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:3","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#二什么是root"},{"categories":["Magisk生态"],"content":" 三、Android是如何限制Root的？在Android4.3之前的版本中，android会给每一个应用分配一个独一无二的ID（也就是user-ID，也称为UID），所以每个应用都有自己的权限边界，这个时候想要拥有Root权限的话，可以通过set-user-ID-root的机制执行su二进制文件来进行提权或者通过setgid/setuid来让自己拥有更多的权限。 但是自从Android4.3推出Security Enhancements in Android 4.3之后，堵住了setgid/setuid入口，引入了全新的安全体系（基于强制访问控制(MAC)的SELinux），构成了SEAndroid，进一步定义Android应用沙盒的边界，运行在单独的进程中，所以每个应用都有自己的权限边界，这样即使是进程具有root的能力，SELinux依然可以通过创建安全策略(sepolicy)来限制root进程的能力范围来增强Android的安全性。而在Android4.4之后推出的Security Enhancements in Android 4.4，进一步要求Android打开了SELinux的Enforcing模式。 上面这种改变也是因为过去的Android安全机制是基于DAC（自主访问控制）来实现的，其原理就是：进程理论上所拥有的权限与执行它的用户的权限相同，DAC使用了ACL（Access Control List，访问控制列表）来给非管理者用户提供不同的权限，而root用户对文件系统有完全自由的控制权，因此，想办法把自己的权限提升到root用户就可以完成任何事情。而正是因为这种宽松的管理方式，促使MAC（强制访问控制）的诞生，MAC核心思想：即任何进程想在SELinux系统中干任何事情，都必须先在安全策略配置文件中赋予权限，MAC不再像DAC一样简单的把进程分为root/others等，而是每个进程（Subject，主体）和文件（Object，客体）都配置了一个类型（Type），当一个进程去操控（读写等）一个文件时，系统会检测该进程类型是否有对该文件类型的操作权限 例如 (base) ✘ 大慈大悲观世音菩萨  ~/Projects/Android_boot_image_editor   master  as selene:/ $ ps -efZ|grep miui u:r:miuibooster:s0 root 943 1 0 17:43:34 ? 00:00:00 miuibooster u:r:platform_app:s0:c512,c768 u0_a122 1597 611 0 17:43:43 ? 00:00:01 com.miui.miwallpaper u:r:platform_app:s0:c512,c768 u0_a102 1950 610 0 17:43:44 ? 00:00:06 com.miui.home u:r:untrusted_app:s0:c234,c256,c512,c768 u0_a234 2212 610 0 17:43:45 ? 00:00:00 com.miui.weather2 u:r:platform_app:s0:c512,c768 u0_a163 2572 611 0 17:43:49 ? 00:00:00 com.miui.voiceassist u:r:system_app:s0 system 2616 610 0 17:43:49 ? 00:00:00 com.miui.contentcatcher u:r:system_app:s0 system 2667 610 0 17:43:49 ? 00:00:02 com.miui.daemon u:r:system_app:s0 system 2794 610 0 17:43:49 ? 00:00:00 com.miui.face u:r:untrusted_app:s0:c512,c768 u0_a78 2902 610 0 17:43:50 ? 00:00:00 com.miui.personalassistant u:r:system_app:s0 system 2971 610 0 17:43:50 ? 00:00:00 com.miui.notification:remote 可以看到，像miuibooster、platform_app这样即表示进程归属的type，而具体的type的权限可以从官方的te文件中查找 因此，在Android4.4之后，获取Root面临的困难是先DAC、后MAC的访问权限控制，市面上通用的做法是修改sepolicy获得一个不受限制的SELinux context，当拥有这个context之后，就可以修改init.rc启动类似su daemon的服务，这样保障了系统运行时后台随时都存在一个拥有root权限的服务，剩下需要做的就只是考虑该如何和这个daemon进行通信 ","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:4","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#三android是如何限制root的"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment\u003cInstallViewModel, FragmentInstallMd2Binding\u003e() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel\u003cInstallViewModel\u003e() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 \u003cButton style=\"@style/WidgetFoundation.Button.Text\" gone=\"@{viewModel.step != 1}\" isEnabled=\"@{viewModel.method == @id/method_patch ? viewModel.data != null : viewModel.method != -1}\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:onClick=\"@{() -\u003e viewModel.install()}\" android:text=\"@string/install_start\" app:icon=\"@drawable/ic_forth_md2\" app:iconGravity=\"textEnd\" /\u003e // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#四magisk是如何工作的"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#1-patch-boot"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#11-boot_patch分块解析"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#12-magiskboot的作用"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#121-main"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#122-unpack"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#123-cpio"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#124-dtb"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#125-hexpatch"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#126-repack"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#127-patch示例"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#13-patch-boot流程图"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#2-booting-process"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#21-android启动方式的演变"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#211-method-a---传统的ramdisk"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#212-method-b---传统的sar机制"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#212-method-c---两阶段初始化ramdisk-to-sar"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#22-magiskinit的处理"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#221-rootfsinit"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#222-recoveryinit"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#223-sarinit"},{"categories":["Magisk生态"],"content":" 四、Magisk是如何工作的？有了上面对于android权限访问控制体系以及现阶段Root实现方式的了解，我们大概能猜到Magisk是如何实现Root的了？那么Magisk它具体的实现包括 如何修改sepolicy、init.rc？ 如何做到systemless的？ 如何适配多种版本、机型？ 是否具备扩展功能？ …… 是如何实现的呢，接下来通过源码来分析下 下面正式开始分析Magisk的内部工作原理（大家都知道Magisk在v24.1之后推出了Zygisk的模式，为了避免新增部分影响我们对于原始流程的分析，因此我选择先忽略掉这部分，以前一个版本v23.0的源码来作为样本阅读） 1 patch bootMagisk Manager做的第一步就是对boot的修补，所以第一步就从Magisk Manager的修补boot页面开始追下来 // com/topjohnwu/magisk/ui/install/InstallFragment.kt // 对应layout class InstallFragment : BaseUIFragment() { override val layoutRes = R.layout.fragment_install_md2 override val viewModel by viewModel() ...... } // layout/fragment_install_md2.xml // layout中的开始按钮，对应的方法是InstallViewModel中的install方法 // com/topjohnwu/magisk/ui/install/InstallViewModel.kt // 引导出FlashFragment fun install() { when (method) { R.id.method_patch -\u003e FlashFragment.patch(data!!).navigate() R.id.method_direct -\u003e FlashFragment.flash(false).navigate() R.id.method_inactive_slot -\u003e FlashFragment.flash(true).navigate() else -\u003e error(\"Unknown value\") } state = State.LOADING } // com/topjohnwu/magisk/ui/flash/FlashFragment.kt // 类似onCreate方法，触发startFlashing override fun onViewCreated(view: View, savedInstanceState: Bundle?) { super.onViewCreated(view, savedInstanceState) defaultOrientation = activity.requestedOrientation activity.requestedOrientation = ActivityInfo.SCREEN_ORIENTATION_NOSENSOR viewModel.startFlashing() } // com/topjohnwu/magisk/ui/flash/FlashViewModel.kt Const.Value.PATCH_FILE -\u003e { uri ?: return@launch showReboot = false MagiskInstaller.Patch(uri, outItems, logItems).exec() } // com/topjohnwu/magisk/core/tasks/MagiskInstaller.kt // patchFile也就是传入的原生boot.img protected fun doPatchFile(patchFile: Uri) = extractFiles() \u0026\u0026 handleFile(patchFile) 进入到关键类：MagiskInstaller private fun extractFiles(): Boolean { ...... // 创建/data/data/package_name/install目录 installDir = File(context.filesDir.parent, \"install\") installDir.deleteRecursively() installDir.mkdirs() try { // Extract binaries // 从stub或者full中获取so文件 if (isRunningAsStub) { val zf = ZipFile(DynAPK.current(context)) zf.entries().asSequence().filter { !it.isDirectory \u0026\u0026 it.name.startsWith(\"lib/${Const.CPU_ABI_32}/\") }.forEach { val n = it.name.substring(it.name.lastIndexOf('/') + 1) val name = n.substring(3, n.length - 3) val dest = File(installDir, name) zf.getInputStream(it).writeTo(dest) } } else { // 获取lib库中的so文件 val libs = Const.NATIVE_LIB_DIR.listFiles { _, name -\u003e name.startsWith(\"lib\") \u0026\u0026 name.endsWith(\".so\") } ?: emptyArray() for (lib in libs) { // 重命名so文件并做软链，例如libmagiskboot.so-\u003emagiskboot // 并软链到/data/data/package_name/install/magiskboot val name = lib.name.substring(3, lib.name.length - 3) Os.symlink(lib.path, \"$installDir/$name\") } } // Extract scripts // 从asset目录中抽出三个shell脚本 for (script in listOf(\"util_functions.sh\", \"boot_patch.sh\", \"addon.d.sh\")) { val dest = File(installDir, script) context.assets.open(script).writeTo(dest) } // Extract chromeos tools // 同理 File(installDir, \"chromeos\").mkdir() for (file in listOf(\"futility\", \"kernel_data_key.vbprivk\", \"kernel.keyblock\")) { val name = \"chromeos/$file\" val dest = File(installDir, name) context.assets.open(name).writeTo(dest) } } catch (e: Exception) { console.add(\"! Unable to extract files\") Timber.e(e) return false } ...... } extractFiles这一步做的功能就是准备资源，把so文件变成可执行文件以及准备好shell脚本，根据Apk对应下的目录可看到文件如下： (base) 大慈大悲观世音菩萨  ~/Downloads/Magisk-v23.0 (1)  ll assets total 88 -rw-rw-rw-@ 1 tcc0lin staff 3.4K 1 1 1981 addon.d.sh -rw-rw-rw-@ 1 tcc0lin staff 5.3K 1 1 1981 boot_patch.sh drwxr-xr-x@ 5 tcc0lin staff 160B 5 31 09:08 chromeos","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:5","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#224-firststageinitsecondstageinit"},{"categories":["Magisk生态"],"content":" 五、参考感谢这些文章带来的启发 https://android.stackexchange.com/questions/213167/how-does-magisk-work https://bbs.kanxue.com/thread-275939.htm#msg_header_h2_3 ","date":"2023-06-09","objectID":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/:0:6","series":null,"tags":["Magisk","源码分析"],"title":"重读Magisk内部实现细节","uri":"/%E9%87%8D%E8%AF%BBmagisk%E5%86%85%E9%83%A8%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82/#五参考"},{"categories":["加密算法研究"],"content":"DES是一种对称密钥的块加密算法。”对称密钥”，是因为加密、解密用的密钥是一样的（这不同于RSA等非对称密钥体系）。“块加密”，是因为这种算法把明文划分为很多个等长的块(block)，对每个块进行加密，最后以某种手段拼在一起。“块加密”亦称“分组加密”。 1973年，NSA向社会征集满足安全要求的加密算法。1973-1974年，IBM研发了DES加密算法。1974年，NSA开始了第二次征集，此后DES在1976年成为美国联邦标准。 ","date":"2023-05-09","objectID":"/%E4%BB%8Efips-46-3%E4%B8%AD%E7%90%86%E8%A7%A3des%E7%AE%97%E6%B3%95/:0:0","series":null,"tags":["DES算法"],"title":"从FIPS 46-3中理解DES算法","uri":"/%E4%BB%8Efips-46-3%E4%B8%AD%E7%90%86%E8%A7%A3des%E7%AE%97%E6%B3%95/#"},{"categories":["加密算法研究"],"content":" 一、DES概述DES的功能是：给定一个64位的明文和一个64位的密钥，输出一个64位的密文。这个密文可以用相同的密钥解密。所谓“64位的密钥”，其实里面只有54位在起作用。剩余的位可以直接丢弃，或者当作奇偶校验位。 虽然DES一次只能加密8个字节，但我们只需要把明文划分成每8个字节一组的块，就可以实现任意长度明文的加密。如果明文长度不是8个字节的倍数，还得进行填充。现在流行的填充方式是PKCS7/PKCS5，都是很简单的思路，用于把任意长度的文本填充成8字节的倍数长，也能方便地恢复原文，这里不再赘述。此外，独立地对每个块加密，最后直接拼起来是不行的（这种方式称为“电子密码本”，ECB模式。它会导致明文中重复的块，加密结果也重复，这对于图片之类的数据来说几乎是致命的）。因为不涵盖在算法流程中，因此对有关DES输入输出的处理后续再讲。 DES有一个非常不平凡的性质——加密与解密算法几乎一模一样。这大大简化了软件和硬件的设计。和加密算法的区别是，给它加上一行（倒转子密钥的顺序），就是一个解密算法了。 在这篇文章中，我们只关注一个核心任务——如何把64位的明文，用64位的密钥，加密成64位的密文，并执行解密。 ","date":"2023-05-09","objectID":"/%E4%BB%8Efips-46-3%E4%B8%AD%E7%90%86%E8%A7%A3des%E7%AE%97%E6%B3%95/:0:1","series":null,"tags":["DES算法"],"title":"从FIPS 46-3中理解DES算法","uri":"/%E4%BB%8Efips-46-3%E4%B8%AD%E7%90%86%E8%A7%A3des%E7%AE%97%E6%B3%95/#一des概述"},{"categories":["加密算法研究"],"content":" 二、DES算法框架DES算法是在Feistel Network（费斯妥网络）的基础上执行的。以下是DES算法的流程图： 可以看到，整个算法可以看成是两个部分 密钥调度计算（右边基于给定密钥生成子密钥的过程） 所谓密钥调度，就是从一把64位的主密钥，得到16把48位的子密钥，然后把这些子密钥参与到后续16轮迭代加密中。那么，如何从一把主密钥得到16把子密钥呢？ 首先是从64位的主密钥中通过选择置换1选取特定的56位，其余的位就作为检验位，不参与后续计算。于是我们现在手上有了一个56位的密钥 接着把它分成左、右两个半密钥C0、D0，它们都是28位的密钥 然后对C0和D0进行16轮的迭代，每轮迭代都包括以下步骤： 左、右两个半密钥Cn、Dn都左旋（也就是循环左移。整个数组往左移，左边弹出去了的东西补到最右边去）一定位数得到Cn+1、Dn+1，这个左移的位数也是指定的。有些轮次是1位，有些轮次是2位 把左、右半密钥拼起来成为Kn+1，再通过选择置换2得到Kn，就得到了这一轮生成的子密钥。这个置换是从56位的数组里面选取指定的48位。所以现在每一轮都可以生成一个48位的子密钥。（注意，步骤3并不改变左右半密钥）。 最后，经过16轮迭代之后，就生成了16个48位的子密钥，这些子密钥被用于加密和解密数据 解密过程中，除了子密钥输出的顺序相反外，密钥调度的过程与加密完全相同 迭代加密（左边的16轮迭代加密的过程） 迭代加密就是由具体数据参与的主流程的加密逻辑，具体逻辑是 输入的明文（64bit）做一个置换（IP置换）。仍然得到64bit的数组（位数不等会导致信息丢失） 同样基于Feistel Network的概念将数据拆分成左右两个半数据，各32bit 每轮迭代都是接收一组L、R，返回L’、R’，作为下一轮迭代的 L, R . 迭代过程如下： L' = R R' = L⊕F(R,subkey) 关键在于F函数，也称为轮（Round）函数，是整个算法的核心，用于以子密钥加密32bit的信息 步骤3执行16轮，每轮分别更新L、R值 将最终得到的L、R值进行合并，再做一次置换（FP置换），即可得到密文 以上就是DES算法的大致过程，文中也提到，加解密的唯一区别就在于子密钥的顺序不同 1 密钥调度计算详细来看看DES如何通过给定的主密钥而生成16把子密钥的，图示如下： 首先，采用“选择置换1 (PC-1)”，从64位key里面选出56位。这一步属于encode，对信息安全没有帮助。PC-1方法如下： const int pc_1[56] = { 57 ,49 ,41 ,33 ,25 ,17 ,9 , 1 ,58 ,50 ,42 ,34 ,26 ,18 , 10 ,2 ,59 ,51 ,43 ,35 ,27 , 19 ,11 ,3 ,60 ,52 ,44 ,36 , 63 ,55 ,47 ,39 ,31 ,23 ,15 , 7 ,62 ,54 ,46 ,38 ,30 ,22 , 14 ,6 ,61 ,53 ,45 ,37 ,29 , 21 ,13 ,5 ,28 ,20 ,12 ,4 }; string key_56 = \"\"; for (int i = 0; i \u003c 56; i++) key_56 += key_64[pc_1[i] - 1]; 经过PC-1之后，我们有了左、右两个半密钥，长度都是28位。接下来，我们每一轮把左、右半密钥左旋几位，再调用PC-2方法来造子密钥。框架如下： int num_leftShift[16] = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; L_key[0] = shift_bit(key_firstHalf, num_leftShift[0]); R_key[0] = shift_bit(key_secondHalf, num_leftShift[0]); for (int i = 1; i \u003c 16; i++) { L_key[i] = shift_bit(L_key[i - 1], num_leftShift[i]); R_key[i] = shift_bit(R_key[i - 1], num_leftShift[i]); } for (int i = 0; i \u003c 16; i++) { keys_56[i] = L_key[i] + R_key[i]; // making 56 bits keys } 其中， shift_bit是循环左移，实现如下： string shift_bit(string s, int n) { string k = \"\"; for (int i = n; i \u003c s.size(); i++) k += s[i]; for (int i = 0; i \u003c n; i++) k += s[i]; return k; } PC-2又是一个简单置换，用于从左右半密钥拼起来的56位密钥中，选取48位作为一个子密钥。实现如下： const int pc_2[48] = { 14 ,17 ,11 ,24 ,1 ,5 , 3 ,28 ,15 ,6 ,21 ,10 , 23 ,19 ,12 ,4 ,26 ,8 , 16 ,7 ,27 ,20 ,13 ,2 , 41 ,52 ,31 ,37 ,47 ,55 , 30 ,40 ,51 ,45 ,33 ,48 , 44 ,49 ,39 ,56 ,34 ,53 , 46 ,42 ,50 ,36 ,29 ,32 }; for (int i = 0; i \u003c 16; i++) { key_48[i] = \"\"; for (int j = 0; j \u003c 48; j++) key_48[i] += keys_56[i][pc_2[j] - 1]; // making 48 bits keys } 这样，我们就实现了密钥调度算法。基于主密钥而得到的16个48位的子密钥。不难看出，整个密钥调度的过程都是对主密钥的encode。生成这么多子密钥的目的，是使得加密迭代变得更加复杂、难以分析 2 迭代加密 加密迭代的过程已经描述过。先把信息进行一次初始置换(IP置换)；再进行16轮迭代；最后再给(R+L)这个数组来一次最终置换(FP置换)，即可输出作为密文 const int IP_t[64] = { 58 ,50 ,42 ,34 ,26 ,18 ,10 ,2 , 60 ,52 ,44 ,36 ,28 ,20 ,12 ,4 , 62 ,54 ,46 ,38 ,30 ,22 ,14 ,6 , 64 ,56 ,48 ,40 ,32 ,24 ,16 ,8 , 57 ,49 ,41 ,33 ,25 ,17 ,9 ,1 , 59 ,51 ,43 ,35 ,27 ,19 ,11 ,3 , 61 ,53 ,45 ,37 ,29 ,21 ,13 ,5 , 63 ,55 ,47 ,39 ,31 ,23 ,15 ,7 }; string IP = \"\"; // permuted key for (int i = 0; i \u003c 64; i++) IP += plain_txt_64[IP_t[i] - 1]; DES的安全性在很大程度上取决于F函数，也就是轮函数。那么Feistel函数是干了什么事呢？来看下面一张流程图： 一个32-bit的块，经过一个扩张(Expand函数)，变成48位，然后与子密钥异或。得到的48-bit的结果分为8组，每一组是6-bit的数据，丢进对应的S盒，输出4-bit的信息。把这些输出收集起来，一共是4*8=32位，做一次置换(P置换)，得到32-bit的结果。这与输进来的32-bit信息是等长度的。 Expand算法是指定的 const int E_t[48] = { 32 ,1 ,2 ,3 ,4 ,5 , // expantion table 4 ,5 ,6 ,7 ,8 ,9 , 8 ,9 ,10 ,11 ,12 ,13 , 12 ,13 ,14 ,15 ,16 ,17 , 16 ,17 ,18 ,19 ,20 ,21 , 20 ,21 ,22 ,23 ,24 ,25 , 24 ,25 ,26 ,27 ,28 ,29 , 28 ,29 ,30 ,31 ,32 ,1 }; R_48[0] = \"\"; for (int j = 0; j \u003c 48; j++) R_48[0] += R[E_t[j] - 1]; string xor_add(string s1, string s2) { string result = \"\"; for (int j = 0; j \u003c s1.size(); j++) { if (s1[j] != s2[j]) result += '1'; else result += '0'; } return result; } R_xor_K[0] = xor_add(R_48[0], key_48[0]); 分成8组分别进入S盒处理 for (int j = 0; j \u003c48; j += 6) // dividing each value of R_xor_K to 8 string contaning 6 char each for (int k = j; k \u003c j + 6; k++) s[0][j / 6] += R_xor_K[0][k]; s_1[0] = \"\"; for (int j = 0; j \u003c 8; j++) s_1[0] += get_element_from_box(s[0][j], j","date":"2023-05-09","objectID":"/%E4%BB%8Efips-46-3%E4%B8%AD%E7%90%86%E8%A7%A3des%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["DES算法"],"title":"从FIPS 46-3中理解DES算法","uri":"/%E4%BB%8Efips-46-3%E4%B8%AD%E7%90%86%E8%A7%A3des%E7%AE%97%E6%B3%95/#二des算法框架"},{"categories":["加密算法研究"],"content":" 二、DES算法框架DES算法是在Feistel Network（费斯妥网络）的基础上执行的。以下是DES算法的流程图： 可以看到，整个算法可以看成是两个部分 密钥调度计算（右边基于给定密钥生成子密钥的过程） 所谓密钥调度，就是从一把64位的主密钥，得到16把48位的子密钥，然后把这些子密钥参与到后续16轮迭代加密中。那么，如何从一把主密钥得到16把子密钥呢？ 首先是从64位的主密钥中通过选择置换1选取特定的56位，其余的位就作为检验位，不参与后续计算。于是我们现在手上有了一个56位的密钥 接着把它分成左、右两个半密钥C0、D0，它们都是28位的密钥 然后对C0和D0进行16轮的迭代，每轮迭代都包括以下步骤： 左、右两个半密钥Cn、Dn都左旋（也就是循环左移。整个数组往左移，左边弹出去了的东西补到最右边去）一定位数得到Cn+1、Dn+1，这个左移的位数也是指定的。有些轮次是1位，有些轮次是2位 把左、右半密钥拼起来成为Kn+1，再通过选择置换2得到Kn，就得到了这一轮生成的子密钥。这个置换是从56位的数组里面选取指定的48位。所以现在每一轮都可以生成一个48位的子密钥。（注意，步骤3并不改变左右半密钥）。 最后，经过16轮迭代之后，就生成了16个48位的子密钥，这些子密钥被用于加密和解密数据 解密过程中，除了子密钥输出的顺序相反外，密钥调度的过程与加密完全相同 迭代加密（左边的16轮迭代加密的过程） 迭代加密就是由具体数据参与的主流程的加密逻辑，具体逻辑是 输入的明文（64bit）做一个置换（IP置换）。仍然得到64bit的数组（位数不等会导致信息丢失） 同样基于Feistel Network的概念将数据拆分成左右两个半数据，各32bit 每轮迭代都是接收一组L、R，返回L’、R’，作为下一轮迭代的 L, R . 迭代过程如下： L' = R R' = L⊕F(R,subkey) 关键在于F函数，也称为轮（Round）函数，是整个算法的核心，用于以子密钥加密32bit的信息 步骤3执行16轮，每轮分别更新L、R值 将最终得到的L、R值进行合并，再做一次置换（FP置换），即可得到密文 以上就是DES算法的大致过程，文中也提到，加解密的唯一区别就在于子密钥的顺序不同 1 密钥调度计算详细来看看DES如何通过给定的主密钥而生成16把子密钥的，图示如下： 首先，采用“选择置换1 (PC-1)”，从64位key里面选出56位。这一步属于encode，对信息安全没有帮助。PC-1方法如下： const int pc_1[56] = { 57 ,49 ,41 ,33 ,25 ,17 ,9 , 1 ,58 ,50 ,42 ,34 ,26 ,18 , 10 ,2 ,59 ,51 ,43 ,35 ,27 , 19 ,11 ,3 ,60 ,52 ,44 ,36 , 63 ,55 ,47 ,39 ,31 ,23 ,15 , 7 ,62 ,54 ,46 ,38 ,30 ,22 , 14 ,6 ,61 ,53 ,45 ,37 ,29 , 21 ,13 ,5 ,28 ,20 ,12 ,4 }; string key_56 = \"\"; for (int i = 0; i \u003c 56; i++) key_56 += key_64[pc_1[i] - 1]; 经过PC-1之后，我们有了左、右两个半密钥，长度都是28位。接下来，我们每一轮把左、右半密钥左旋几位，再调用PC-2方法来造子密钥。框架如下： int num_leftShift[16] = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; L_key[0] = shift_bit(key_firstHalf, num_leftShift[0]); R_key[0] = shift_bit(key_secondHalf, num_leftShift[0]); for (int i = 1; i \u003c 16; i++) { L_key[i] = shift_bit(L_key[i - 1], num_leftShift[i]); R_key[i] = shift_bit(R_key[i - 1], num_leftShift[i]); } for (int i = 0; i \u003c 16; i++) { keys_56[i] = L_key[i] + R_key[i]; // making 56 bits keys } 其中， shift_bit是循环左移，实现如下： string shift_bit(string s, int n) { string k = \"\"; for (int i = n; i \u003c s.size(); i++) k += s[i]; for (int i = 0; i \u003c n; i++) k += s[i]; return k; } PC-2又是一个简单置换，用于从左右半密钥拼起来的56位密钥中，选取48位作为一个子密钥。实现如下： const int pc_2[48] = { 14 ,17 ,11 ,24 ,1 ,5 , 3 ,28 ,15 ,6 ,21 ,10 , 23 ,19 ,12 ,4 ,26 ,8 , 16 ,7 ,27 ,20 ,13 ,2 , 41 ,52 ,31 ,37 ,47 ,55 , 30 ,40 ,51 ,45 ,33 ,48 , 44 ,49 ,39 ,56 ,34 ,53 , 46 ,42 ,50 ,36 ,29 ,32 }; for (int i = 0; i \u003c 16; i++) { key_48[i] = \"\"; for (int j = 0; j \u003c 48; j++) key_48[i] += keys_56[i][pc_2[j] - 1]; // making 48 bits keys } 这样，我们就实现了密钥调度算法。基于主密钥而得到的16个48位的子密钥。不难看出，整个密钥调度的过程都是对主密钥的encode。生成这么多子密钥的目的，是使得加密迭代变得更加复杂、难以分析 2 迭代加密 加密迭代的过程已经描述过。先把信息进行一次初始置换(IP置换)；再进行16轮迭代；最后再给(R+L)这个数组来一次最终置换(FP置换)，即可输出作为密文 const int IP_t[64] = { 58 ,50 ,42 ,34 ,26 ,18 ,10 ,2 , 60 ,52 ,44 ,36 ,28 ,20 ,12 ,4 , 62 ,54 ,46 ,38 ,30 ,22 ,14 ,6 , 64 ,56 ,48 ,40 ,32 ,24 ,16 ,8 , 57 ,49 ,41 ,33 ,25 ,17 ,9 ,1 , 59 ,51 ,43 ,35 ,27 ,19 ,11 ,3 , 61 ,53 ,45 ,37 ,29 ,21 ,13 ,5 , 63 ,55 ,47 ,39 ,31 ,23 ,15 ,7 }; string IP = \"\"; // permuted key for (int i = 0; i \u003c 64; i++) IP += plain_txt_64[IP_t[i] - 1]; DES的安全性在很大程度上取决于F函数，也就是轮函数。那么Feistel函数是干了什么事呢？来看下面一张流程图： 一个32-bit的块，经过一个扩张(Expand函数)，变成48位，然后与子密钥异或。得到的48-bit的结果分为8组，每一组是6-bit的数据，丢进对应的S盒，输出4-bit的信息。把这些输出收集起来，一共是4*8=32位，做一次置换(P置换)，得到32-bit的结果。这与输进来的32-bit信息是等长度的。 Expand算法是指定的 const int E_t[48] = { 32 ,1 ,2 ,3 ,4 ,5 , // expantion table 4 ,5 ,6 ,7 ,8 ,9 , 8 ,9 ,10 ,11 ,12 ,13 , 12 ,13 ,14 ,15 ,16 ,17 , 16 ,17 ,18 ,19 ,20 ,21 , 20 ,21 ,22 ,23 ,24 ,25 , 24 ,25 ,26 ,27 ,28 ,29 , 28 ,29 ,30 ,31 ,32 ,1 }; R_48[0] = \"\"; for (int j = 0; j \u003c 48; j++) R_48[0] += R[E_t[j] - 1]; string xor_add(string s1, string s2) { string result = \"\"; for (int j = 0; j \u003c s1.size(); j++) { if (s1[j] != s2[j]) result += '1'; else result += '0'; } return result; } R_xor_K[0] = xor_add(R_48[0], key_48[0]); 分成8组分别进入S盒处理 for (int j = 0; j \u003c48; j += 6) // dividing each value of R_xor_K to 8 string contaning 6 char each for (int k = j; k \u003c j + 6; k++) s[0][j / 6] += R_xor_K[0][k]; s_1[0] = \"\"; for (int j = 0; j \u003c 8; j++) s_1[0] += get_element_from_box(s[0][j], j","date":"2023-05-09","objectID":"/%E4%BB%8Efips-46-3%E4%B8%AD%E7%90%86%E8%A7%A3des%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["DES算法"],"title":"从FIPS 46-3中理解DES算法","uri":"/%E4%BB%8Efips-46-3%E4%B8%AD%E7%90%86%E8%A7%A3des%E7%AE%97%E6%B3%95/#1-密钥调度计算"},{"categories":["加密算法研究"],"content":" 二、DES算法框架DES算法是在Feistel Network（费斯妥网络）的基础上执行的。以下是DES算法的流程图： 可以看到，整个算法可以看成是两个部分 密钥调度计算（右边基于给定密钥生成子密钥的过程） 所谓密钥调度，就是从一把64位的主密钥，得到16把48位的子密钥，然后把这些子密钥参与到后续16轮迭代加密中。那么，如何从一把主密钥得到16把子密钥呢？ 首先是从64位的主密钥中通过选择置换1选取特定的56位，其余的位就作为检验位，不参与后续计算。于是我们现在手上有了一个56位的密钥 接着把它分成左、右两个半密钥C0、D0，它们都是28位的密钥 然后对C0和D0进行16轮的迭代，每轮迭代都包括以下步骤： 左、右两个半密钥Cn、Dn都左旋（也就是循环左移。整个数组往左移，左边弹出去了的东西补到最右边去）一定位数得到Cn+1、Dn+1，这个左移的位数也是指定的。有些轮次是1位，有些轮次是2位 把左、右半密钥拼起来成为Kn+1，再通过选择置换2得到Kn，就得到了这一轮生成的子密钥。这个置换是从56位的数组里面选取指定的48位。所以现在每一轮都可以生成一个48位的子密钥。（注意，步骤3并不改变左右半密钥）。 最后，经过16轮迭代之后，就生成了16个48位的子密钥，这些子密钥被用于加密和解密数据 解密过程中，除了子密钥输出的顺序相反外，密钥调度的过程与加密完全相同 迭代加密（左边的16轮迭代加密的过程） 迭代加密就是由具体数据参与的主流程的加密逻辑，具体逻辑是 输入的明文（64bit）做一个置换（IP置换）。仍然得到64bit的数组（位数不等会导致信息丢失） 同样基于Feistel Network的概念将数据拆分成左右两个半数据，各32bit 每轮迭代都是接收一组L、R，返回L’、R’，作为下一轮迭代的 L, R . 迭代过程如下： L' = R R' = L⊕F(R,subkey) 关键在于F函数，也称为轮（Round）函数，是整个算法的核心，用于以子密钥加密32bit的信息 步骤3执行16轮，每轮分别更新L、R值 将最终得到的L、R值进行合并，再做一次置换（FP置换），即可得到密文 以上就是DES算法的大致过程，文中也提到，加解密的唯一区别就在于子密钥的顺序不同 1 密钥调度计算详细来看看DES如何通过给定的主密钥而生成16把子密钥的，图示如下： 首先，采用“选择置换1 (PC-1)”，从64位key里面选出56位。这一步属于encode，对信息安全没有帮助。PC-1方法如下： const int pc_1[56] = { 57 ,49 ,41 ,33 ,25 ,17 ,9 , 1 ,58 ,50 ,42 ,34 ,26 ,18 , 10 ,2 ,59 ,51 ,43 ,35 ,27 , 19 ,11 ,3 ,60 ,52 ,44 ,36 , 63 ,55 ,47 ,39 ,31 ,23 ,15 , 7 ,62 ,54 ,46 ,38 ,30 ,22 , 14 ,6 ,61 ,53 ,45 ,37 ,29 , 21 ,13 ,5 ,28 ,20 ,12 ,4 }; string key_56 = \"\"; for (int i = 0; i \u003c 56; i++) key_56 += key_64[pc_1[i] - 1]; 经过PC-1之后，我们有了左、右两个半密钥，长度都是28位。接下来，我们每一轮把左、右半密钥左旋几位，再调用PC-2方法来造子密钥。框架如下： int num_leftShift[16] = { 1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1 }; L_key[0] = shift_bit(key_firstHalf, num_leftShift[0]); R_key[0] = shift_bit(key_secondHalf, num_leftShift[0]); for (int i = 1; i \u003c 16; i++) { L_key[i] = shift_bit(L_key[i - 1], num_leftShift[i]); R_key[i] = shift_bit(R_key[i - 1], num_leftShift[i]); } for (int i = 0; i \u003c 16; i++) { keys_56[i] = L_key[i] + R_key[i]; // making 56 bits keys } 其中， shift_bit是循环左移，实现如下： string shift_bit(string s, int n) { string k = \"\"; for (int i = n; i \u003c s.size(); i++) k += s[i]; for (int i = 0; i \u003c n; i++) k += s[i]; return k; } PC-2又是一个简单置换，用于从左右半密钥拼起来的56位密钥中，选取48位作为一个子密钥。实现如下： const int pc_2[48] = { 14 ,17 ,11 ,24 ,1 ,5 , 3 ,28 ,15 ,6 ,21 ,10 , 23 ,19 ,12 ,4 ,26 ,8 , 16 ,7 ,27 ,20 ,13 ,2 , 41 ,52 ,31 ,37 ,47 ,55 , 30 ,40 ,51 ,45 ,33 ,48 , 44 ,49 ,39 ,56 ,34 ,53 , 46 ,42 ,50 ,36 ,29 ,32 }; for (int i = 0; i \u003c 16; i++) { key_48[i] = \"\"; for (int j = 0; j \u003c 48; j++) key_48[i] += keys_56[i][pc_2[j] - 1]; // making 48 bits keys } 这样，我们就实现了密钥调度算法。基于主密钥而得到的16个48位的子密钥。不难看出，整个密钥调度的过程都是对主密钥的encode。生成这么多子密钥的目的，是使得加密迭代变得更加复杂、难以分析 2 迭代加密 加密迭代的过程已经描述过。先把信息进行一次初始置换(IP置换)；再进行16轮迭代；最后再给(R+L)这个数组来一次最终置换(FP置换)，即可输出作为密文 const int IP_t[64] = { 58 ,50 ,42 ,34 ,26 ,18 ,10 ,2 , 60 ,52 ,44 ,36 ,28 ,20 ,12 ,4 , 62 ,54 ,46 ,38 ,30 ,22 ,14 ,6 , 64 ,56 ,48 ,40 ,32 ,24 ,16 ,8 , 57 ,49 ,41 ,33 ,25 ,17 ,9 ,1 , 59 ,51 ,43 ,35 ,27 ,19 ,11 ,3 , 61 ,53 ,45 ,37 ,29 ,21 ,13 ,5 , 63 ,55 ,47 ,39 ,31 ,23 ,15 ,7 }; string IP = \"\"; // permuted key for (int i = 0; i \u003c 64; i++) IP += plain_txt_64[IP_t[i] - 1]; DES的安全性在很大程度上取决于F函数，也就是轮函数。那么Feistel函数是干了什么事呢？来看下面一张流程图： 一个32-bit的块，经过一个扩张(Expand函数)，变成48位，然后与子密钥异或。得到的48-bit的结果分为8组，每一组是6-bit的数据，丢进对应的S盒，输出4-bit的信息。把这些输出收集起来，一共是4*8=32位，做一次置换(P置换)，得到32-bit的结果。这与输进来的32-bit信息是等长度的。 Expand算法是指定的 const int E_t[48] = { 32 ,1 ,2 ,3 ,4 ,5 , // expantion table 4 ,5 ,6 ,7 ,8 ,9 , 8 ,9 ,10 ,11 ,12 ,13 , 12 ,13 ,14 ,15 ,16 ,17 , 16 ,17 ,18 ,19 ,20 ,21 , 20 ,21 ,22 ,23 ,24 ,25 , 24 ,25 ,26 ,27 ,28 ,29 , 28 ,29 ,30 ,31 ,32 ,1 }; R_48[0] = \"\"; for (int j = 0; j \u003c 48; j++) R_48[0] += R[E_t[j] - 1]; string xor_add(string s1, string s2) { string result = \"\"; for (int j = 0; j \u003c s1.size(); j++) { if (s1[j] != s2[j]) result += '1'; else result += '0'; } return result; } R_xor_K[0] = xor_add(R_48[0], key_48[0]); 分成8组分别进入S盒处理 for (int j = 0; j \u003c48; j += 6) // dividing each value of R_xor_K to 8 string contaning 6 char each for (int k = j; k \u003c j + 6; k++) s[0][j / 6] += R_xor_K[0][k]; s_1[0] = \"\"; for (int j = 0; j \u003c 8; j++) s_1[0] += get_element_from_box(s[0][j], j","date":"2023-05-09","objectID":"/%E4%BB%8Efips-46-3%E4%B8%AD%E7%90%86%E8%A7%A3des%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["DES算法"],"title":"从FIPS 46-3中理解DES算法","uri":"/%E4%BB%8Efips-46-3%E4%B8%AD%E7%90%86%E8%A7%A3des%E7%AE%97%E6%B3%95/#2-迭代加密"},{"categories":["加密算法研究"],"content":" 三、理解DES也算是第一代的公认的对称加密的标准算法，核心在于F函数的概念与实现。当然DES算法主体流程还是依赖于固定64位的输入输出，而到了实际使用上还存在有不同的工作方式以及安全性问题，这些问题还等到后续继续补充 ","date":"2023-05-09","objectID":"/%E4%BB%8Efips-46-3%E4%B8%AD%E7%90%86%E8%A7%A3des%E7%AE%97%E6%B3%95/:0:3","series":null,"tags":["DES算法"],"title":"从FIPS 46-3中理解DES算法","uri":"/%E4%BB%8Efips-46-3%E4%B8%AD%E7%90%86%E8%A7%A3des%E7%AE%97%E6%B3%95/#三理解"},{"categories":["加密算法研究"],"content":" 一、前置知识点MD5算法的输入是任意长度的信息，而输出是固定的长度为128位的信息，也就是固定大小为16字节的数组（byte=8bit） ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/:0:1","series":null,"tags":["MD5算法"],"title":"从RFC1321中理解MD5算法","uri":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/#一前置知识点"},{"categories":["加密算法研究"],"content":" 二、算法流程根据上面所说，MD5算法的输入是任意长度的信息，长度可以是0，也可以不是8的倍数，针对任意长度的输入，就需要通过下面的五个步骤来计算出它的MD5值 1 补位输入可以是不定长的信息，但是实际上转化到算法逻辑中时又需要根据定长的信息来计算，因此，首先需要做的就是补位操作，方法如下： 将二进制数据对512进行取模，如果有余数不等于448，则将余数补足到448的长度，补足的规则是先补1，后面全补0，相当于N*512+448的长度，N为一个非负整数（也包括0） 例如 # 以长度20解释 1001001001 #长度为10 10010010011000000000 #先补1后补0 2 记录信息长度上一步将最后的余数补充到448，距离512还相差64，这64位二进制就是用来记录信息的长度的，当然，如果信息长度超过64位，则取低64位。经过以上这两步的处理，整个输入信息的长度已经被扩充成N*512+448+64=(N+1)*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求 3 初始化变量这一步引入MD5算法中第一个关键点—初始常量（可以叫幻数、魔数或者IV），这些参数以小端字节序来表示，会参与到后续的计算，也会直接影响最终的计算结果。 word A: 01 23 45 67 word B: 89 ab cd ef word C: fe dc ba 98 word D: 76 54 32 10 每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即小端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476 4 处理分组数据在前两步我们将数据处理成了N*512的分组形式，下面再对每个分组进行二次分组成16份，也就是16*32=512，每个子分组是32bit的数据 每个分组的计算流程都是一样的，简单来说如下：默认初始变量有a、b、c、d四个变量，首先以第三步的四个变量分别对其赋值，也就是 A = a B = b C = c D = d 之后开始四轮的循环计算，每轮有16次操作，分别对应一个非线性函数以及子分组、常量，每次操作都会计算出a、b、c、d其中一个变量的新值作替换，这样经过四轮计算之后，a、b、c、d的值也就更新了一遍，后续的其他分组也是如此操作 下面具体讲下其中的逻辑： 首先是MD5算法中第二个关键点—非线性函数，分别是 F(X,Y,Z) = XY v not(X) Z G(X,Y,Z) = XZ v Y not(Z) H(X,Y,Z) = X xor Y xor Z I(X,Y,Z) = Y xor (X v not(Z)) // c++实现 F, G, H and I are basic MD5 functions. inline MD5::uint4 MD5::F(uint4 x, uint4 y, uint4 z) { return (x \u0026 y) | (~x \u0026 z); } inline MD5::uint4 MD5::G(uint4 x, uint4 y, uint4 z) { return (x \u0026 z) | (y \u0026 ~z); } inline MD5::uint4 MD5::H(uint4 x, uint4 y, uint4 z) { return x ^ y ^ z; } inline MD5::uint4 MD5::I(uint4 x, uint4 y, uint4 z) { return y ^ (x | ~z); } 每轮中都会使用其中一个函数来进行计算，因此函数的逻辑也直接决定最终的结果，具体使用到的地方如下 // rotate_left rotates x left n bits. inline MD5::uint4 MD5::rotate_left(uint4 x, int n) { return (x \u003c\u003c n) | (x \u003e\u003e (32 - n)); } // FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4. // Rotation is separate from addition to prevent recomputation. inline void MD5::FF(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + F(b, c, d) + x + ac, s) + b; } inline void MD5::GG(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + G(b, c, d) + x + ac, s) + b; } inline void MD5::HH(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + H(b, c, d) + x + ac, s) + b; } inline void MD5::II(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + I(b, c, d) + x + ac, s) + b; } 四个函数格式相似，不同的只是引用到刚才所说的非线性函数 讲到主逻辑之前还需要提到MD5算法中第三个关键点—T常量表 它的计算方式也比较简单，之前说到计算会有4*16=64次，因此也就需要64个常量，公式如 4294967296*abs(sin(i)) 其中i是取值从1到64，而4294967296=2的32次方，最后计算可得出T常量表如 unsigned int T[64] = { 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 }; 还有第四个关键点—转换常量 unsigned int S1[4] = {7, 12, 17, 22}; unsigned int S2[4] = {5, 9, 14, 20}; unsigned int S3[4] = {4, 11, 16, 23}; unsigned int S4[4] = {6, 10, 15, 21}; 参与到非线性函数中循环左移的操作 主逻辑 /* Round 1 */ FF(a, b, c, d, x[0], S1[0], T[0]); /* 1 */ FF(d, a, b, c, x[1], S1[1], T[1]); /* 2 */ FF(c, d, a, b, x[2], S1[2], T[2]); /* 3 */ FF(b, c, d, a, x[3], S1[3], T[3]); /* 4 */ FF(a, b, c, d, x[4], S1[0], T[4]); /* 5 */ FF(d, a, b, c, x[5], S1[1], T[5]); /* 6 */ FF(c, d, a, b, x[6], S1[2], T[6]); /* 7 */ FF(b, c, d, a, x[7], S1[3], T[7]); /* 8 */ FF(a, b, c, d, x[8], S1[0], T[8]); /* 9 */ FF(d, a, b, c, x[9], S1[1], T[9]); /* 10 */ FF(c, d, a, b, x[10], S1[2], T[10]); /","date":"2023-05-09","objectID":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["MD5算法"],"title":"从RFC1321中理解MD5算法","uri":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/#二算法流程"},{"categories":["加密算法研究"],"content":" 二、算法流程根据上面所说，MD5算法的输入是任意长度的信息，长度可以是0，也可以不是8的倍数，针对任意长度的输入，就需要通过下面的五个步骤来计算出它的MD5值 1 补位输入可以是不定长的信息，但是实际上转化到算法逻辑中时又需要根据定长的信息来计算，因此，首先需要做的就是补位操作，方法如下： 将二进制数据对512进行取模，如果有余数不等于448，则将余数补足到448的长度，补足的规则是先补1，后面全补0，相当于N*512+448的长度，N为一个非负整数（也包括0） 例如 # 以长度20解释 1001001001 #长度为10 10010010011000000000 #先补1后补0 2 记录信息长度上一步将最后的余数补充到448，距离512还相差64，这64位二进制就是用来记录信息的长度的，当然，如果信息长度超过64位，则取低64位。经过以上这两步的处理，整个输入信息的长度已经被扩充成N*512+448+64=(N+1)*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求 3 初始化变量这一步引入MD5算法中第一个关键点—初始常量（可以叫幻数、魔数或者IV），这些参数以小端字节序来表示，会参与到后续的计算，也会直接影响最终的计算结果。 word A: 01 23 45 67 word B: 89 ab cd ef word C: fe dc ba 98 word D: 76 54 32 10 每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即小端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476 4 处理分组数据在前两步我们将数据处理成了N*512的分组形式，下面再对每个分组进行二次分组成16份，也就是16*32=512，每个子分组是32bit的数据 每个分组的计算流程都是一样的，简单来说如下：默认初始变量有a、b、c、d四个变量，首先以第三步的四个变量分别对其赋值，也就是 A = a B = b C = c D = d 之后开始四轮的循环计算，每轮有16次操作，分别对应一个非线性函数以及子分组、常量，每次操作都会计算出a、b、c、d其中一个变量的新值作替换，这样经过四轮计算之后，a、b、c、d的值也就更新了一遍，后续的其他分组也是如此操作 下面具体讲下其中的逻辑： 首先是MD5算法中第二个关键点—非线性函数，分别是 F(X,Y,Z) = XY v not(X) Z G(X,Y,Z) = XZ v Y not(Z) H(X,Y,Z) = X xor Y xor Z I(X,Y,Z) = Y xor (X v not(Z)) // c++实现 F, G, H and I are basic MD5 functions. inline MD5::uint4 MD5::F(uint4 x, uint4 y, uint4 z) { return (x \u0026 y) | (~x \u0026 z); } inline MD5::uint4 MD5::G(uint4 x, uint4 y, uint4 z) { return (x \u0026 z) | (y \u0026 ~z); } inline MD5::uint4 MD5::H(uint4 x, uint4 y, uint4 z) { return x ^ y ^ z; } inline MD5::uint4 MD5::I(uint4 x, uint4 y, uint4 z) { return y ^ (x | ~z); } 每轮中都会使用其中一个函数来进行计算，因此函数的逻辑也直接决定最终的结果，具体使用到的地方如下 // rotate_left rotates x left n bits. inline MD5::uint4 MD5::rotate_left(uint4 x, int n) { return (x \u003c\u003c n) | (x \u003e\u003e (32 - n)); } // FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4. // Rotation is separate from addition to prevent recomputation. inline void MD5::FF(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + F(b, c, d) + x + ac, s) + b; } inline void MD5::GG(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + G(b, c, d) + x + ac, s) + b; } inline void MD5::HH(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + H(b, c, d) + x + ac, s) + b; } inline void MD5::II(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + I(b, c, d) + x + ac, s) + b; } 四个函数格式相似，不同的只是引用到刚才所说的非线性函数 讲到主逻辑之前还需要提到MD5算法中第三个关键点—T常量表 它的计算方式也比较简单，之前说到计算会有4*16=64次，因此也就需要64个常量，公式如 4294967296*abs(sin(i)) 其中i是取值从1到64，而4294967296=2的32次方，最后计算可得出T常量表如 unsigned int T[64] = { 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 }; 还有第四个关键点—转换常量 unsigned int S1[4] = {7, 12, 17, 22}; unsigned int S2[4] = {5, 9, 14, 20}; unsigned int S3[4] = {4, 11, 16, 23}; unsigned int S4[4] = {6, 10, 15, 21}; 参与到非线性函数中循环左移的操作 主逻辑 /* Round 1 */ FF(a, b, c, d, x[0], S1[0], T[0]); /* 1 */ FF(d, a, b, c, x[1], S1[1], T[1]); /* 2 */ FF(c, d, a, b, x[2], S1[2], T[2]); /* 3 */ FF(b, c, d, a, x[3], S1[3], T[3]); /* 4 */ FF(a, b, c, d, x[4], S1[0], T[4]); /* 5 */ FF(d, a, b, c, x[5], S1[1], T[5]); /* 6 */ FF(c, d, a, b, x[6], S1[2], T[6]); /* 7 */ FF(b, c, d, a, x[7], S1[3], T[7]); /* 8 */ FF(a, b, c, d, x[8], S1[0], T[8]); /* 9 */ FF(d, a, b, c, x[9], S1[1], T[9]); /* 10 */ FF(c, d, a, b, x[10], S1[2], T[10]); /","date":"2023-05-09","objectID":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["MD5算法"],"title":"从RFC1321中理解MD5算法","uri":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/#1-补位"},{"categories":["加密算法研究"],"content":" 二、算法流程根据上面所说，MD5算法的输入是任意长度的信息，长度可以是0，也可以不是8的倍数，针对任意长度的输入，就需要通过下面的五个步骤来计算出它的MD5值 1 补位输入可以是不定长的信息，但是实际上转化到算法逻辑中时又需要根据定长的信息来计算，因此，首先需要做的就是补位操作，方法如下： 将二进制数据对512进行取模，如果有余数不等于448，则将余数补足到448的长度，补足的规则是先补1，后面全补0，相当于N*512+448的长度，N为一个非负整数（也包括0） 例如 # 以长度20解释 1001001001 #长度为10 10010010011000000000 #先补1后补0 2 记录信息长度上一步将最后的余数补充到448，距离512还相差64，这64位二进制就是用来记录信息的长度的，当然，如果信息长度超过64位，则取低64位。经过以上这两步的处理，整个输入信息的长度已经被扩充成N*512+448+64=(N+1)*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求 3 初始化变量这一步引入MD5算法中第一个关键点—初始常量（可以叫幻数、魔数或者IV），这些参数以小端字节序来表示，会参与到后续的计算，也会直接影响最终的计算结果。 word A: 01 23 45 67 word B: 89 ab cd ef word C: fe dc ba 98 word D: 76 54 32 10 每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即小端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476 4 处理分组数据在前两步我们将数据处理成了N*512的分组形式，下面再对每个分组进行二次分组成16份，也就是16*32=512，每个子分组是32bit的数据 每个分组的计算流程都是一样的，简单来说如下：默认初始变量有a、b、c、d四个变量，首先以第三步的四个变量分别对其赋值，也就是 A = a B = b C = c D = d 之后开始四轮的循环计算，每轮有16次操作，分别对应一个非线性函数以及子分组、常量，每次操作都会计算出a、b、c、d其中一个变量的新值作替换，这样经过四轮计算之后，a、b、c、d的值也就更新了一遍，后续的其他分组也是如此操作 下面具体讲下其中的逻辑： 首先是MD5算法中第二个关键点—非线性函数，分别是 F(X,Y,Z) = XY v not(X) Z G(X,Y,Z) = XZ v Y not(Z) H(X,Y,Z) = X xor Y xor Z I(X,Y,Z) = Y xor (X v not(Z)) // c++实现 F, G, H and I are basic MD5 functions. inline MD5::uint4 MD5::F(uint4 x, uint4 y, uint4 z) { return (x \u0026 y) | (~x \u0026 z); } inline MD5::uint4 MD5::G(uint4 x, uint4 y, uint4 z) { return (x \u0026 z) | (y \u0026 ~z); } inline MD5::uint4 MD5::H(uint4 x, uint4 y, uint4 z) { return x ^ y ^ z; } inline MD5::uint4 MD5::I(uint4 x, uint4 y, uint4 z) { return y ^ (x | ~z); } 每轮中都会使用其中一个函数来进行计算，因此函数的逻辑也直接决定最终的结果，具体使用到的地方如下 // rotate_left rotates x left n bits. inline MD5::uint4 MD5::rotate_left(uint4 x, int n) { return (x \u003c\u003c n) | (x \u003e\u003e (32 - n)); } // FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4. // Rotation is separate from addition to prevent recomputation. inline void MD5::FF(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + F(b, c, d) + x + ac, s) + b; } inline void MD5::GG(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + G(b, c, d) + x + ac, s) + b; } inline void MD5::HH(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + H(b, c, d) + x + ac, s) + b; } inline void MD5::II(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + I(b, c, d) + x + ac, s) + b; } 四个函数格式相似，不同的只是引用到刚才所说的非线性函数 讲到主逻辑之前还需要提到MD5算法中第三个关键点—T常量表 它的计算方式也比较简单，之前说到计算会有4*16=64次，因此也就需要64个常量，公式如 4294967296*abs(sin(i)) 其中i是取值从1到64，而4294967296=2的32次方，最后计算可得出T常量表如 unsigned int T[64] = { 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 }; 还有第四个关键点—转换常量 unsigned int S1[4] = {7, 12, 17, 22}; unsigned int S2[4] = {5, 9, 14, 20}; unsigned int S3[4] = {4, 11, 16, 23}; unsigned int S4[4] = {6, 10, 15, 21}; 参与到非线性函数中循环左移的操作 主逻辑 /* Round 1 */ FF(a, b, c, d, x[0], S1[0], T[0]); /* 1 */ FF(d, a, b, c, x[1], S1[1], T[1]); /* 2 */ FF(c, d, a, b, x[2], S1[2], T[2]); /* 3 */ FF(b, c, d, a, x[3], S1[3], T[3]); /* 4 */ FF(a, b, c, d, x[4], S1[0], T[4]); /* 5 */ FF(d, a, b, c, x[5], S1[1], T[5]); /* 6 */ FF(c, d, a, b, x[6], S1[2], T[6]); /* 7 */ FF(b, c, d, a, x[7], S1[3], T[7]); /* 8 */ FF(a, b, c, d, x[8], S1[0], T[8]); /* 9 */ FF(d, a, b, c, x[9], S1[1], T[9]); /* 10 */ FF(c, d, a, b, x[10], S1[2], T[10]); /","date":"2023-05-09","objectID":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["MD5算法"],"title":"从RFC1321中理解MD5算法","uri":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/#2-记录信息长度"},{"categories":["加密算法研究"],"content":" 二、算法流程根据上面所说，MD5算法的输入是任意长度的信息，长度可以是0，也可以不是8的倍数，针对任意长度的输入，就需要通过下面的五个步骤来计算出它的MD5值 1 补位输入可以是不定长的信息，但是实际上转化到算法逻辑中时又需要根据定长的信息来计算，因此，首先需要做的就是补位操作，方法如下： 将二进制数据对512进行取模，如果有余数不等于448，则将余数补足到448的长度，补足的规则是先补1，后面全补0，相当于N*512+448的长度，N为一个非负整数（也包括0） 例如 # 以长度20解释 1001001001 #长度为10 10010010011000000000 #先补1后补0 2 记录信息长度上一步将最后的余数补充到448，距离512还相差64，这64位二进制就是用来记录信息的长度的，当然，如果信息长度超过64位，则取低64位。经过以上这两步的处理，整个输入信息的长度已经被扩充成N*512+448+64=(N+1)*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求 3 初始化变量这一步引入MD5算法中第一个关键点—初始常量（可以叫幻数、魔数或者IV），这些参数以小端字节序来表示，会参与到后续的计算，也会直接影响最终的计算结果。 word A: 01 23 45 67 word B: 89 ab cd ef word C: fe dc ba 98 word D: 76 54 32 10 每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即小端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476 4 处理分组数据在前两步我们将数据处理成了N*512的分组形式，下面再对每个分组进行二次分组成16份，也就是16*32=512，每个子分组是32bit的数据 每个分组的计算流程都是一样的，简单来说如下：默认初始变量有a、b、c、d四个变量，首先以第三步的四个变量分别对其赋值，也就是 A = a B = b C = c D = d 之后开始四轮的循环计算，每轮有16次操作，分别对应一个非线性函数以及子分组、常量，每次操作都会计算出a、b、c、d其中一个变量的新值作替换，这样经过四轮计算之后，a、b、c、d的值也就更新了一遍，后续的其他分组也是如此操作 下面具体讲下其中的逻辑： 首先是MD5算法中第二个关键点—非线性函数，分别是 F(X,Y,Z) = XY v not(X) Z G(X,Y,Z) = XZ v Y not(Z) H(X,Y,Z) = X xor Y xor Z I(X,Y,Z) = Y xor (X v not(Z)) // c++实现 F, G, H and I are basic MD5 functions. inline MD5::uint4 MD5::F(uint4 x, uint4 y, uint4 z) { return (x \u0026 y) | (~x \u0026 z); } inline MD5::uint4 MD5::G(uint4 x, uint4 y, uint4 z) { return (x \u0026 z) | (y \u0026 ~z); } inline MD5::uint4 MD5::H(uint4 x, uint4 y, uint4 z) { return x ^ y ^ z; } inline MD5::uint4 MD5::I(uint4 x, uint4 y, uint4 z) { return y ^ (x | ~z); } 每轮中都会使用其中一个函数来进行计算，因此函数的逻辑也直接决定最终的结果，具体使用到的地方如下 // rotate_left rotates x left n bits. inline MD5::uint4 MD5::rotate_left(uint4 x, int n) { return (x \u003c\u003c n) | (x \u003e\u003e (32 - n)); } // FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4. // Rotation is separate from addition to prevent recomputation. inline void MD5::FF(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + F(b, c, d) + x + ac, s) + b; } inline void MD5::GG(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + G(b, c, d) + x + ac, s) + b; } inline void MD5::HH(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + H(b, c, d) + x + ac, s) + b; } inline void MD5::II(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + I(b, c, d) + x + ac, s) + b; } 四个函数格式相似，不同的只是引用到刚才所说的非线性函数 讲到主逻辑之前还需要提到MD5算法中第三个关键点—T常量表 它的计算方式也比较简单，之前说到计算会有4*16=64次，因此也就需要64个常量，公式如 4294967296*abs(sin(i)) 其中i是取值从1到64，而4294967296=2的32次方，最后计算可得出T常量表如 unsigned int T[64] = { 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 }; 还有第四个关键点—转换常量 unsigned int S1[4] = {7, 12, 17, 22}; unsigned int S2[4] = {5, 9, 14, 20}; unsigned int S3[4] = {4, 11, 16, 23}; unsigned int S4[4] = {6, 10, 15, 21}; 参与到非线性函数中循环左移的操作 主逻辑 /* Round 1 */ FF(a, b, c, d, x[0], S1[0], T[0]); /* 1 */ FF(d, a, b, c, x[1], S1[1], T[1]); /* 2 */ FF(c, d, a, b, x[2], S1[2], T[2]); /* 3 */ FF(b, c, d, a, x[3], S1[3], T[3]); /* 4 */ FF(a, b, c, d, x[4], S1[0], T[4]); /* 5 */ FF(d, a, b, c, x[5], S1[1], T[5]); /* 6 */ FF(c, d, a, b, x[6], S1[2], T[6]); /* 7 */ FF(b, c, d, a, x[7], S1[3], T[7]); /* 8 */ FF(a, b, c, d, x[8], S1[0], T[8]); /* 9 */ FF(d, a, b, c, x[9], S1[1], T[9]); /* 10 */ FF(c, d, a, b, x[10], S1[2], T[10]); /","date":"2023-05-09","objectID":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["MD5算法"],"title":"从RFC1321中理解MD5算法","uri":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/#3-初始化变量"},{"categories":["加密算法研究"],"content":" 二、算法流程根据上面所说，MD5算法的输入是任意长度的信息，长度可以是0，也可以不是8的倍数，针对任意长度的输入，就需要通过下面的五个步骤来计算出它的MD5值 1 补位输入可以是不定长的信息，但是实际上转化到算法逻辑中时又需要根据定长的信息来计算，因此，首先需要做的就是补位操作，方法如下： 将二进制数据对512进行取模，如果有余数不等于448，则将余数补足到448的长度，补足的规则是先补1，后面全补0，相当于N*512+448的长度，N为一个非负整数（也包括0） 例如 # 以长度20解释 1001001001 #长度为10 10010010011000000000 #先补1后补0 2 记录信息长度上一步将最后的余数补充到448，距离512还相差64，这64位二进制就是用来记录信息的长度的，当然，如果信息长度超过64位，则取低64位。经过以上这两步的处理，整个输入信息的长度已经被扩充成N*512+448+64=(N+1)*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求 3 初始化变量这一步引入MD5算法中第一个关键点—初始常量（可以叫幻数、魔数或者IV），这些参数以小端字节序来表示，会参与到后续的计算，也会直接影响最终的计算结果。 word A: 01 23 45 67 word B: 89 ab cd ef word C: fe dc ba 98 word D: 76 54 32 10 每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即小端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476 4 处理分组数据在前两步我们将数据处理成了N*512的分组形式，下面再对每个分组进行二次分组成16份，也就是16*32=512，每个子分组是32bit的数据 每个分组的计算流程都是一样的，简单来说如下：默认初始变量有a、b、c、d四个变量，首先以第三步的四个变量分别对其赋值，也就是 A = a B = b C = c D = d 之后开始四轮的循环计算，每轮有16次操作，分别对应一个非线性函数以及子分组、常量，每次操作都会计算出a、b、c、d其中一个变量的新值作替换，这样经过四轮计算之后，a、b、c、d的值也就更新了一遍，后续的其他分组也是如此操作 下面具体讲下其中的逻辑： 首先是MD5算法中第二个关键点—非线性函数，分别是 F(X,Y,Z) = XY v not(X) Z G(X,Y,Z) = XZ v Y not(Z) H(X,Y,Z) = X xor Y xor Z I(X,Y,Z) = Y xor (X v not(Z)) // c++实现 F, G, H and I are basic MD5 functions. inline MD5::uint4 MD5::F(uint4 x, uint4 y, uint4 z) { return (x \u0026 y) | (~x \u0026 z); } inline MD5::uint4 MD5::G(uint4 x, uint4 y, uint4 z) { return (x \u0026 z) | (y \u0026 ~z); } inline MD5::uint4 MD5::H(uint4 x, uint4 y, uint4 z) { return x ^ y ^ z; } inline MD5::uint4 MD5::I(uint4 x, uint4 y, uint4 z) { return y ^ (x | ~z); } 每轮中都会使用其中一个函数来进行计算，因此函数的逻辑也直接决定最终的结果，具体使用到的地方如下 // rotate_left rotates x left n bits. inline MD5::uint4 MD5::rotate_left(uint4 x, int n) { return (x \u003c\u003c n) | (x \u003e\u003e (32 - n)); } // FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4. // Rotation is separate from addition to prevent recomputation. inline void MD5::FF(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + F(b, c, d) + x + ac, s) + b; } inline void MD5::GG(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + G(b, c, d) + x + ac, s) + b; } inline void MD5::HH(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + H(b, c, d) + x + ac, s) + b; } inline void MD5::II(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + I(b, c, d) + x + ac, s) + b; } 四个函数格式相似，不同的只是引用到刚才所说的非线性函数 讲到主逻辑之前还需要提到MD5算法中第三个关键点—T常量表 它的计算方式也比较简单，之前说到计算会有4*16=64次，因此也就需要64个常量，公式如 4294967296*abs(sin(i)) 其中i是取值从1到64，而4294967296=2的32次方，最后计算可得出T常量表如 unsigned int T[64] = { 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 }; 还有第四个关键点—转换常量 unsigned int S1[4] = {7, 12, 17, 22}; unsigned int S2[4] = {5, 9, 14, 20}; unsigned int S3[4] = {4, 11, 16, 23}; unsigned int S4[4] = {6, 10, 15, 21}; 参与到非线性函数中循环左移的操作 主逻辑 /* Round 1 */ FF(a, b, c, d, x[0], S1[0], T[0]); /* 1 */ FF(d, a, b, c, x[1], S1[1], T[1]); /* 2 */ FF(c, d, a, b, x[2], S1[2], T[2]); /* 3 */ FF(b, c, d, a, x[3], S1[3], T[3]); /* 4 */ FF(a, b, c, d, x[4], S1[0], T[4]); /* 5 */ FF(d, a, b, c, x[5], S1[1], T[5]); /* 6 */ FF(c, d, a, b, x[6], S1[2], T[6]); /* 7 */ FF(b, c, d, a, x[7], S1[3], T[7]); /* 8 */ FF(a, b, c, d, x[8], S1[0], T[8]); /* 9 */ FF(d, a, b, c, x[9], S1[1], T[9]); /* 10 */ FF(c, d, a, b, x[10], S1[2], T[10]); /","date":"2023-05-09","objectID":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["MD5算法"],"title":"从RFC1321中理解MD5算法","uri":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/#4-处理分组数据"},{"categories":["加密算法研究"],"content":" 二、算法流程根据上面所说，MD5算法的输入是任意长度的信息，长度可以是0，也可以不是8的倍数，针对任意长度的输入，就需要通过下面的五个步骤来计算出它的MD5值 1 补位输入可以是不定长的信息，但是实际上转化到算法逻辑中时又需要根据定长的信息来计算，因此，首先需要做的就是补位操作，方法如下： 将二进制数据对512进行取模，如果有余数不等于448，则将余数补足到448的长度，补足的规则是先补1，后面全补0，相当于N*512+448的长度，N为一个非负整数（也包括0） 例如 # 以长度20解释 1001001001 #长度为10 10010010011000000000 #先补1后补0 2 记录信息长度上一步将最后的余数补充到448，距离512还相差64，这64位二进制就是用来记录信息的长度的，当然，如果信息长度超过64位，则取低64位。经过以上这两步的处理，整个输入信息的长度已经被扩充成N*512+448+64=(N+1)*512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求 3 初始化变量这一步引入MD5算法中第一个关键点—初始常量（可以叫幻数、魔数或者IV），这些参数以小端字节序来表示，会参与到后续的计算，也会直接影响最终的计算结果。 word A: 01 23 45 67 word B: 89 ab cd ef word C: fe dc ba 98 word D: 76 54 32 10 每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即小端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476 4 处理分组数据在前两步我们将数据处理成了N*512的分组形式，下面再对每个分组进行二次分组成16份，也就是16*32=512，每个子分组是32bit的数据 每个分组的计算流程都是一样的，简单来说如下：默认初始变量有a、b、c、d四个变量，首先以第三步的四个变量分别对其赋值，也就是 A = a B = b C = c D = d 之后开始四轮的循环计算，每轮有16次操作，分别对应一个非线性函数以及子分组、常量，每次操作都会计算出a、b、c、d其中一个变量的新值作替换，这样经过四轮计算之后，a、b、c、d的值也就更新了一遍，后续的其他分组也是如此操作 下面具体讲下其中的逻辑： 首先是MD5算法中第二个关键点—非线性函数，分别是 F(X,Y,Z) = XY v not(X) Z G(X,Y,Z) = XZ v Y not(Z) H(X,Y,Z) = X xor Y xor Z I(X,Y,Z) = Y xor (X v not(Z)) // c++实现 F, G, H and I are basic MD5 functions. inline MD5::uint4 MD5::F(uint4 x, uint4 y, uint4 z) { return (x \u0026 y) | (~x \u0026 z); } inline MD5::uint4 MD5::G(uint4 x, uint4 y, uint4 z) { return (x \u0026 z) | (y \u0026 ~z); } inline MD5::uint4 MD5::H(uint4 x, uint4 y, uint4 z) { return x ^ y ^ z; } inline MD5::uint4 MD5::I(uint4 x, uint4 y, uint4 z) { return y ^ (x | ~z); } 每轮中都会使用其中一个函数来进行计算，因此函数的逻辑也直接决定最终的结果，具体使用到的地方如下 // rotate_left rotates x left n bits. inline MD5::uint4 MD5::rotate_left(uint4 x, int n) { return (x \u003c\u003c n) | (x \u003e\u003e (32 - n)); } // FF, GG, HH, and II transformations for rounds 1, 2, 3, and 4. // Rotation is separate from addition to prevent recomputation. inline void MD5::FF(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + F(b, c, d) + x + ac, s) + b; } inline void MD5::GG(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + G(b, c, d) + x + ac, s) + b; } inline void MD5::HH(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + H(b, c, d) + x + ac, s) + b; } inline void MD5::II(uint4 \u0026a, uint4 b, uint4 c, uint4 d, uint4 x, uint4 s, uint4 ac) { a = rotate_left(a + I(b, c, d) + x + ac, s) + b; } 四个函数格式相似，不同的只是引用到刚才所说的非线性函数 讲到主逻辑之前还需要提到MD5算法中第三个关键点—T常量表 它的计算方式也比较简单，之前说到计算会有4*16=64次，因此也就需要64个常量，公式如 4294967296*abs(sin(i)) 其中i是取值从1到64，而4294967296=2的32次方，最后计算可得出T常量表如 unsigned int T[64] = { 0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391 }; 还有第四个关键点—转换常量 unsigned int S1[4] = {7, 12, 17, 22}; unsigned int S2[4] = {5, 9, 14, 20}; unsigned int S3[4] = {4, 11, 16, 23}; unsigned int S4[4] = {6, 10, 15, 21}; 参与到非线性函数中循环左移的操作 主逻辑 /* Round 1 */ FF(a, b, c, d, x[0], S1[0], T[0]); /* 1 */ FF(d, a, b, c, x[1], S1[1], T[1]); /* 2 */ FF(c, d, a, b, x[2], S1[2], T[2]); /* 3 */ FF(b, c, d, a, x[3], S1[3], T[3]); /* 4 */ FF(a, b, c, d, x[4], S1[0], T[4]); /* 5 */ FF(d, a, b, c, x[5], S1[1], T[5]); /* 6 */ FF(c, d, a, b, x[6], S1[2], T[6]); /* 7 */ FF(b, c, d, a, x[7], S1[3], T[7]); /* 8 */ FF(a, b, c, d, x[8], S1[0], T[8]); /* 9 */ FF(d, a, b, c, x[9], S1[1], T[9]); /* 10 */ FF(c, d, a, b, x[10], S1[2], T[10]); /","date":"2023-05-09","objectID":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["MD5算法"],"title":"从RFC1321中理解MD5算法","uri":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/#5-输出结果"},{"categories":["加密算法研究"],"content":" 总结综合上面所讲到的MD5算法原理，可以看出MD5还是比较简单易懂的，与最终结果相关的正如上面所讲到的有四个关键点，理解它们的含义以及作用在后续我们对MD5算法进行魔改的时候是很有帮助的 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/:0:3","series":null,"tags":["MD5算法"],"title":"从RFC1321中理解MD5算法","uri":"/%E4%BB%8Erfc1321%E4%B8%AD%E7%90%86%E8%A7%A3md5%E7%AE%97%E6%B3%95/#总结"},{"categories":["加密算法研究"],"content":" 一、RC5算法概述作为同样是由Rivest推出的算法，RC5算法与RC4算法是完全不同的，一个明显的特征是RC5采用的是基于Feistel对称结构的分组加密算法 和许多加密方法不同，RC5支持可变的块大小(32、64或128比特)，密钥长度（0至2040位）和加密轮数（0～255）。最初建议选择的参数是64位的块大小，128位的密钥和12轮加密 RC5的一个关键特征是使用基于数据的置换。RC5的其中一个目标是促进对于这类作为原始密码的操作的研究和评估。RC5也包括一些的取模加法和逻辑异或(XOR)运算。加密结构是基于Feistel来完成的，虽然结构简单，但密钥的生成算法更复杂。密钥扩展使用了e和黄金比例代入一个单向函数，将所得值作为“袖子里是空的”数字（即无任何来源依据的魔法数字）。算法的诱人的简洁性和基于数据的置换的特性，让RC5吸引了众多密码研究人员将其作为研究对象。 RC5通常被记为RC5-w/r/b，w=字的大小（以bit为单位），r=加密轮数，b=密钥的字节数。这样，RC5-32/16/16表示为RC5的块长为64位（注：RC5使用两个字块）、16轮加密和16字节密钥。Ron Rivest推荐的最低安全版本为RC5-32/16/16 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc2040%E4%B8%AD%E7%90%86%E8%A7%A3rc5%E7%AE%97%E6%B3%95/:0:1","series":null,"tags":["RC5算法"],"title":"从RFC2040中理解RC5算法","uri":"/%E4%BB%8Erfc2040%E4%B8%AD%E7%90%86%E8%A7%A3rc5%E7%AE%97%E6%B3%95/#一rc5算法概述"},{"categories":["加密算法研究"],"content":" 二、RC5算法框架为了便于理解RC5算法，假设输入明文块的长度为64位，其他块长的操作原理是一样的 在一次性初始操作中，输入明文块分成两个32位块A和B，前两个子密钥（稍后会介绍如何生成）S[0]和S[1]分别加进A和B，分别产生C和D，表示一次性操作结束 接着进行各轮计算，每轮完成以下操作： 位异或运算 循环左移 对C和D增加下一个子密钥，先是加法运算，然后将结果用2^32求模 1 初始化操作第一步的初始化计算可以看成是RC4融合了DES的做法，融合了RC4的密钥计算和DES的Feistel的一个对称结构运用 首先会将明文分为两个等长的A和B，接着是第一个子密钥S[0]与A相加，第二个子密钥S[1]与B相加 2 子密钥的计算子密钥的计算可以分成生成和混合两步，预计要产生2r+2个子密钥，每个密钥长度为w位 生成 这一步使用两个常量P和Q。生成的子密钥数组称为S，第一个子密钥为S[0]用P值初始化。每个后续子密钥（S[1]，S[2]，…）根据前面的子密钥和常量Q求出，用2^32求模，这个过程要进行2(r+1)-1次，其中r位轮数 // Set magic constants rc5_p = 0xb7e15163; rc5_q = 0x9e3779b9; // Cleaning user key for(int i=0; i\u003cRC5_B; i++) rc5_key[i]=0; for(rc5_s[0]=rc5_p,i=1; i\u003cRC5_T; i++) rc5_s[i] = rc5_s[i-1]+rc5_q; for(i=RC5_B-1, l[RC5_C-1]=0; i!=-1; i--) l[i/u] = (l[i/u]\u003c\u003c8)+key[i]; 混合 // 3*t \u003e 3*c for(a=b=i=j=k=0; k\u003c3*RC5_T; k++, i=(i+1)%RC5_T, j=(j+1)%RC5_C) { a = rc5_s[i] = RC5_ROTL(rc5_s[i]+(a+b),3); b = l[j] = RC5_ROTL(l[j]+(a+b),(a+b)); } 混合之后得到了新的长度为(2 * r) + 2的密钥组，需要注意的是，代码中提到了P和Q两个变量，其实是根据以下的公式而得来的 Pw = Odd((e-2)*2^32) Qw = Odd((Φ-2)*2^32) e表示自然对数的底 Φ表示黄金分割比率 Odd(x)表示最接近x的奇整数 3 轮计算 RC5_TWORD i; RC5_TWORD a=pt[0]+rc5_s[0]; RC5_TWORD b=pt[1]+rc5_s[1]; for(i=1; i\u003c=RC5_R; i++) { a = RC5_ROTL(a^b, b)+rc5_s[2*i]; b = RC5_ROTL(b^a, a)+rc5_s[2*i+1]; } ct[0] = a; ct[1] = b; ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc2040%E4%B8%AD%E7%90%86%E8%A7%A3rc5%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["RC5算法"],"title":"从RFC2040中理解RC5算法","uri":"/%E4%BB%8Erfc2040%E4%B8%AD%E7%90%86%E8%A7%A3rc5%E7%AE%97%E6%B3%95/#二rc5算法框架"},{"categories":["加密算法研究"],"content":" 二、RC5算法框架为了便于理解RC5算法，假设输入明文块的长度为64位，其他块长的操作原理是一样的 在一次性初始操作中，输入明文块分成两个32位块A和B，前两个子密钥（稍后会介绍如何生成）S[0]和S[1]分别加进A和B，分别产生C和D，表示一次性操作结束 接着进行各轮计算，每轮完成以下操作： 位异或运算 循环左移 对C和D增加下一个子密钥，先是加法运算，然后将结果用2^32求模 1 初始化操作第一步的初始化计算可以看成是RC4融合了DES的做法，融合了RC4的密钥计算和DES的Feistel的一个对称结构运用 首先会将明文分为两个等长的A和B，接着是第一个子密钥S[0]与A相加，第二个子密钥S[1]与B相加 2 子密钥的计算子密钥的计算可以分成生成和混合两步，预计要产生2r+2个子密钥，每个密钥长度为w位 生成 这一步使用两个常量P和Q。生成的子密钥数组称为S，第一个子密钥为S[0]用P值初始化。每个后续子密钥（S[1]，S[2]，…）根据前面的子密钥和常量Q求出，用2^32求模，这个过程要进行2(r+1)-1次，其中r位轮数 // Set magic constants rc5_p = 0xb7e15163; rc5_q = 0x9e3779b9; // Cleaning user key for(int i=0; i","date":"2023-05-09","objectID":"/%E4%BB%8Erfc2040%E4%B8%AD%E7%90%86%E8%A7%A3rc5%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["RC5算法"],"title":"从RFC2040中理解RC5算法","uri":"/%E4%BB%8Erfc2040%E4%B8%AD%E7%90%86%E8%A7%A3rc5%E7%AE%97%E6%B3%95/#1-初始化操作"},{"categories":["加密算法研究"],"content":" 二、RC5算法框架为了便于理解RC5算法，假设输入明文块的长度为64位，其他块长的操作原理是一样的 在一次性初始操作中，输入明文块分成两个32位块A和B，前两个子密钥（稍后会介绍如何生成）S[0]和S[1]分别加进A和B，分别产生C和D，表示一次性操作结束 接着进行各轮计算，每轮完成以下操作： 位异或运算 循环左移 对C和D增加下一个子密钥，先是加法运算，然后将结果用2^32求模 1 初始化操作第一步的初始化计算可以看成是RC4融合了DES的做法，融合了RC4的密钥计算和DES的Feistel的一个对称结构运用 首先会将明文分为两个等长的A和B，接着是第一个子密钥S[0]与A相加，第二个子密钥S[1]与B相加 2 子密钥的计算子密钥的计算可以分成生成和混合两步，预计要产生2r+2个子密钥，每个密钥长度为w位 生成 这一步使用两个常量P和Q。生成的子密钥数组称为S，第一个子密钥为S[0]用P值初始化。每个后续子密钥（S[1]，S[2]，…）根据前面的子密钥和常量Q求出，用2^32求模，这个过程要进行2(r+1)-1次，其中r位轮数 // Set magic constants rc5_p = 0xb7e15163; rc5_q = 0x9e3779b9; // Cleaning user key for(int i=0; i","date":"2023-05-09","objectID":"/%E4%BB%8Erfc2040%E4%B8%AD%E7%90%86%E8%A7%A3rc5%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["RC5算法"],"title":"从RFC2040中理解RC5算法","uri":"/%E4%BB%8Erfc2040%E4%B8%AD%E7%90%86%E8%A7%A3rc5%E7%AE%97%E6%B3%95/#2-子密钥的计算"},{"categories":["加密算法研究"],"content":" 二、RC5算法框架为了便于理解RC5算法，假设输入明文块的长度为64位，其他块长的操作原理是一样的 在一次性初始操作中，输入明文块分成两个32位块A和B，前两个子密钥（稍后会介绍如何生成）S[0]和S[1]分别加进A和B，分别产生C和D，表示一次性操作结束 接着进行各轮计算，每轮完成以下操作： 位异或运算 循环左移 对C和D增加下一个子密钥，先是加法运算，然后将结果用2^32求模 1 初始化操作第一步的初始化计算可以看成是RC4融合了DES的做法，融合了RC4的密钥计算和DES的Feistel的一个对称结构运用 首先会将明文分为两个等长的A和B，接着是第一个子密钥S[0]与A相加，第二个子密钥S[1]与B相加 2 子密钥的计算子密钥的计算可以分成生成和混合两步，预计要产生2r+2个子密钥，每个密钥长度为w位 生成 这一步使用两个常量P和Q。生成的子密钥数组称为S，第一个子密钥为S[0]用P值初始化。每个后续子密钥（S[1]，S[2]，…）根据前面的子密钥和常量Q求出，用2^32求模，这个过程要进行2(r+1)-1次，其中r位轮数 // Set magic constants rc5_p = 0xb7e15163; rc5_q = 0x9e3779b9; // Cleaning user key for(int i=0; i","date":"2023-05-09","objectID":"/%E4%BB%8Erfc2040%E4%B8%AD%E7%90%86%E8%A7%A3rc5%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["RC5算法"],"title":"从RFC2040中理解RC5算法","uri":"/%E4%BB%8Erfc2040%E4%B8%AD%E7%90%86%E8%A7%A3rc5%E7%AE%97%E6%B3%95/#3-轮计算"},{"categories":["加密算法研究"],"content":" 三、理解","date":"2023-05-09","objectID":"/%E4%BB%8Erfc2040%E4%B8%AD%E7%90%86%E8%A7%A3rc5%E7%AE%97%E6%B3%95/:0:3","series":null,"tags":["RC5算法"],"title":"从RFC2040中理解RC5算法","uri":"/%E4%BB%8Erfc2040%E4%B8%AD%E7%90%86%E8%A7%A3rc5%E7%AE%97%E6%B3%95/#三理解"},{"categories":["加密算法研究"],"content":" 一、前置知识点总体上来说，SHA1算法和MD5算法很类似（因为它们都属于是针对于信息摘要的哈希算法），大体的算法流程也是基本相同，可以回忆下MD5算法的五个步骤，可以说SHA1是升级版本的MD5。不同点从直观上看，SHA1返回的信息长度是160位（20个字节），而MD5则是128位（16个字节），因此相较于MD5算法来说会更加安全一些（不过也仅仅是一些而已） ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/:0:1","series":null,"tags":["SHA1算法"],"title":"从RFC3174中理解SHA1算法","uri":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/#一前置知识点"},{"categories":["加密算法研究"],"content":" 二、算法流程算法流程就不多做介绍，和MD5算法类似，同样需要通过五个步骤来完成 1 补位基本一样，不做额外说明 2 记录信息长度同上 3 初始化变量这一步开始有不同了，SHA1算法也同样有初始变量，与MD5不同的是，MD5最终是依靠初始变量组合起来的16个字节的结果，而SHA1结果为20个字节，因此也在初始变量中多了4个字节，定义如下 uint32_t H0 = 0x67452301; // 0x01, 0x23, 0x45, 0x67 uint32_t H1 = 0xEFCDAB89; // 0x89, 0xAB, 0xCD, 0xEF uint32_t H2 = 0x98BADCFE; // 0xFE, 0xDC, 0xBA, 0x98 uint32_t H3 = 0x10325476; // 0x76, 0x54, 0x32, 0x10 uint32_t H4 = 0xC3D2E1F0; // 0xF0, 0xE1, 0xD2, 0xC3 初始化变量的个数和结果有直接关系，因为结果是由初始化变量组合在一起的 4 处理分组数据这一步大体结构一样，但是处理的方式有点不同 分组方式不说了，同样是将数据处理成了N*512的分组形式，下面再对每个分组进行二次分组成16份，也就是16*32=512，每个子分组是32bit的数据，着重讲讲和MD5算法的不同点 相比于MD5的四轮计算，SHA1也会涉及到四轮计算，每轮则增加到20次，一共是80次非线性函数计算，对于每轮使用的数据和MD5也是有区别的，MD5处理每次分组的数据就是把数据分成16组，每轮使用的都是这16组数据，而SHA1则不一样，只有前16组使用的是拆分的数据，从16-80则根据公式得到新的数据 /* a. Divide M(i) into 16 words W(0), W(1), ..., W(15), where W(0) is the left - most word. */ for (t = 0; t \u003c= 15; t++) { W[t] = M[t]; } /* b. For t = 16 to 79 let W(t) = S^1(W(t-3) XOR W(t-8) XOR W(t-14) XOR W(t-16)). */ for (t = 16; t \u003c= 79; t++) { W[t] = MoveLeft(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1); } 首先先看看四个非线性函数参考（二、四轮其实是一样的） /* f(X, Y, Z) */ /* [0, 19] */ static uint32_t Ch(uint32_t X, uint32_t Y, uint32_t Z) { return (X \u0026 Y) ^ ((~X) \u0026 Z); } /* [20, 39] */ /* [60, 79] */ static uint32_t Parity(uint32_t X, uint32_t Y, uint32_t Z) { return X ^ Y ^ Z; } /* [40, 59] */ static uint32_t Maj(uint32_t X, uint32_t Y, uint32_t Z) { return (X \u0026 Y) ^ (X \u0026 Z) ^ (Y \u0026 Z); } 接着是每次计算所会涉及到的常量K，还记得在MD5中有个常量表T表，T表是根据公式计算得来的64个常量，而K就是直接给好的 K(t) = 5A827999 ( 0 \u003c= t \u003c= 19) K(t) = 6ED9EBA1 (20 \u003c= t \u003c= 39) K(t) = 8F1BBCDC (40 \u003c= t \u003c= 59) K(t) = CA62C1D6 (60 \u003c= t \u003c= 79) 文档也给的很干脆，每轮一个固定常量 下面该讲到具体的处理了，MD5算法每次计算改变的只是一个变量的值，但是SHA1每次计算则会改变五个变量的值 uint32_t temp = MoveLeft(A, 5) + Ch(B, C, D) + E + W[t] + K[0]; E = D; D = C; C = MoveLeft(B, 30); B = A; A = temp; 最终只需要将得到的a、b、c、d重新赋值再作为初始变量传递给下一分组计算即可 5 输出结果在经过分组计算后能够得到A、B、C、D、E，从低位字节A开始，高位字节E结束 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["SHA1算法"],"title":"从RFC3174中理解SHA1算法","uri":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/#二算法流程"},{"categories":["加密算法研究"],"content":" 二、算法流程算法流程就不多做介绍，和MD5算法类似，同样需要通过五个步骤来完成 1 补位基本一样，不做额外说明 2 记录信息长度同上 3 初始化变量这一步开始有不同了，SHA1算法也同样有初始变量，与MD5不同的是，MD5最终是依靠初始变量组合起来的16个字节的结果，而SHA1结果为20个字节，因此也在初始变量中多了4个字节，定义如下 uint32_t H0 = 0x67452301; // 0x01, 0x23, 0x45, 0x67 uint32_t H1 = 0xEFCDAB89; // 0x89, 0xAB, 0xCD, 0xEF uint32_t H2 = 0x98BADCFE; // 0xFE, 0xDC, 0xBA, 0x98 uint32_t H3 = 0x10325476; // 0x76, 0x54, 0x32, 0x10 uint32_t H4 = 0xC3D2E1F0; // 0xF0, 0xE1, 0xD2, 0xC3 初始化变量的个数和结果有直接关系，因为结果是由初始化变量组合在一起的 4 处理分组数据这一步大体结构一样，但是处理的方式有点不同 分组方式不说了，同样是将数据处理成了N*512的分组形式，下面再对每个分组进行二次分组成16份，也就是16*32=512，每个子分组是32bit的数据，着重讲讲和MD5算法的不同点 相比于MD5的四轮计算，SHA1也会涉及到四轮计算，每轮则增加到20次，一共是80次非线性函数计算，对于每轮使用的数据和MD5也是有区别的，MD5处理每次分组的数据就是把数据分成16组，每轮使用的都是这16组数据，而SHA1则不一样，只有前16组使用的是拆分的数据，从16-80则根据公式得到新的数据 /* a. Divide M(i) into 16 words W(0), W(1), ..., W(15), where W(0) is the left - most word. */ for (t = 0; t \u003c= 15; t++) { W[t] = M[t]; } /* b. For t = 16 to 79 let W(t) = S^1(W(t-3) XOR W(t-8) XOR W(t-14) XOR W(t-16)). */ for (t = 16; t \u003c= 79; t++) { W[t] = MoveLeft(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1); } 首先先看看四个非线性函数参考（二、四轮其实是一样的） /* f(X, Y, Z) */ /* [0, 19] */ static uint32_t Ch(uint32_t X, uint32_t Y, uint32_t Z) { return (X \u0026 Y) ^ ((~X) \u0026 Z); } /* [20, 39] */ /* [60, 79] */ static uint32_t Parity(uint32_t X, uint32_t Y, uint32_t Z) { return X ^ Y ^ Z; } /* [40, 59] */ static uint32_t Maj(uint32_t X, uint32_t Y, uint32_t Z) { return (X \u0026 Y) ^ (X \u0026 Z) ^ (Y \u0026 Z); } 接着是每次计算所会涉及到的常量K，还记得在MD5中有个常量表T表，T表是根据公式计算得来的64个常量，而K就是直接给好的 K(t) = 5A827999 ( 0 \u003c= t \u003c= 19) K(t) = 6ED9EBA1 (20 \u003c= t \u003c= 39) K(t) = 8F1BBCDC (40 \u003c= t \u003c= 59) K(t) = CA62C1D6 (60 \u003c= t \u003c= 79) 文档也给的很干脆，每轮一个固定常量 下面该讲到具体的处理了，MD5算法每次计算改变的只是一个变量的值，但是SHA1每次计算则会改变五个变量的值 uint32_t temp = MoveLeft(A, 5) + Ch(B, C, D) + E + W[t] + K[0]; E = D; D = C; C = MoveLeft(B, 30); B = A; A = temp; 最终只需要将得到的a、b、c、d重新赋值再作为初始变量传递给下一分组计算即可 5 输出结果在经过分组计算后能够得到A、B、C、D、E，从低位字节A开始，高位字节E结束 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["SHA1算法"],"title":"从RFC3174中理解SHA1算法","uri":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/#1-补位"},{"categories":["加密算法研究"],"content":" 二、算法流程算法流程就不多做介绍，和MD5算法类似，同样需要通过五个步骤来完成 1 补位基本一样，不做额外说明 2 记录信息长度同上 3 初始化变量这一步开始有不同了，SHA1算法也同样有初始变量，与MD5不同的是，MD5最终是依靠初始变量组合起来的16个字节的结果，而SHA1结果为20个字节，因此也在初始变量中多了4个字节，定义如下 uint32_t H0 = 0x67452301; // 0x01, 0x23, 0x45, 0x67 uint32_t H1 = 0xEFCDAB89; // 0x89, 0xAB, 0xCD, 0xEF uint32_t H2 = 0x98BADCFE; // 0xFE, 0xDC, 0xBA, 0x98 uint32_t H3 = 0x10325476; // 0x76, 0x54, 0x32, 0x10 uint32_t H4 = 0xC3D2E1F0; // 0xF0, 0xE1, 0xD2, 0xC3 初始化变量的个数和结果有直接关系，因为结果是由初始化变量组合在一起的 4 处理分组数据这一步大体结构一样，但是处理的方式有点不同 分组方式不说了，同样是将数据处理成了N*512的分组形式，下面再对每个分组进行二次分组成16份，也就是16*32=512，每个子分组是32bit的数据，着重讲讲和MD5算法的不同点 相比于MD5的四轮计算，SHA1也会涉及到四轮计算，每轮则增加到20次，一共是80次非线性函数计算，对于每轮使用的数据和MD5也是有区别的，MD5处理每次分组的数据就是把数据分成16组，每轮使用的都是这16组数据，而SHA1则不一样，只有前16组使用的是拆分的数据，从16-80则根据公式得到新的数据 /* a. Divide M(i) into 16 words W(0), W(1), ..., W(15), where W(0) is the left - most word. */ for (t = 0; t \u003c= 15; t++) { W[t] = M[t]; } /* b. For t = 16 to 79 let W(t) = S^1(W(t-3) XOR W(t-8) XOR W(t-14) XOR W(t-16)). */ for (t = 16; t \u003c= 79; t++) { W[t] = MoveLeft(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1); } 首先先看看四个非线性函数参考（二、四轮其实是一样的） /* f(X, Y, Z) */ /* [0, 19] */ static uint32_t Ch(uint32_t X, uint32_t Y, uint32_t Z) { return (X \u0026 Y) ^ ((~X) \u0026 Z); } /* [20, 39] */ /* [60, 79] */ static uint32_t Parity(uint32_t X, uint32_t Y, uint32_t Z) { return X ^ Y ^ Z; } /* [40, 59] */ static uint32_t Maj(uint32_t X, uint32_t Y, uint32_t Z) { return (X \u0026 Y) ^ (X \u0026 Z) ^ (Y \u0026 Z); } 接着是每次计算所会涉及到的常量K，还记得在MD5中有个常量表T表，T表是根据公式计算得来的64个常量，而K就是直接给好的 K(t) = 5A827999 ( 0 \u003c= t \u003c= 19) K(t) = 6ED9EBA1 (20 \u003c= t \u003c= 39) K(t) = 8F1BBCDC (40 \u003c= t \u003c= 59) K(t) = CA62C1D6 (60 \u003c= t \u003c= 79) 文档也给的很干脆，每轮一个固定常量 下面该讲到具体的处理了，MD5算法每次计算改变的只是一个变量的值，但是SHA1每次计算则会改变五个变量的值 uint32_t temp = MoveLeft(A, 5) + Ch(B, C, D) + E + W[t] + K[0]; E = D; D = C; C = MoveLeft(B, 30); B = A; A = temp; 最终只需要将得到的a、b、c、d重新赋值再作为初始变量传递给下一分组计算即可 5 输出结果在经过分组计算后能够得到A、B、C、D、E，从低位字节A开始，高位字节E结束 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["SHA1算法"],"title":"从RFC3174中理解SHA1算法","uri":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/#2-记录信息长度"},{"categories":["加密算法研究"],"content":" 二、算法流程算法流程就不多做介绍，和MD5算法类似，同样需要通过五个步骤来完成 1 补位基本一样，不做额外说明 2 记录信息长度同上 3 初始化变量这一步开始有不同了，SHA1算法也同样有初始变量，与MD5不同的是，MD5最终是依靠初始变量组合起来的16个字节的结果，而SHA1结果为20个字节，因此也在初始变量中多了4个字节，定义如下 uint32_t H0 = 0x67452301; // 0x01, 0x23, 0x45, 0x67 uint32_t H1 = 0xEFCDAB89; // 0x89, 0xAB, 0xCD, 0xEF uint32_t H2 = 0x98BADCFE; // 0xFE, 0xDC, 0xBA, 0x98 uint32_t H3 = 0x10325476; // 0x76, 0x54, 0x32, 0x10 uint32_t H4 = 0xC3D2E1F0; // 0xF0, 0xE1, 0xD2, 0xC3 初始化变量的个数和结果有直接关系，因为结果是由初始化变量组合在一起的 4 处理分组数据这一步大体结构一样，但是处理的方式有点不同 分组方式不说了，同样是将数据处理成了N*512的分组形式，下面再对每个分组进行二次分组成16份，也就是16*32=512，每个子分组是32bit的数据，着重讲讲和MD5算法的不同点 相比于MD5的四轮计算，SHA1也会涉及到四轮计算，每轮则增加到20次，一共是80次非线性函数计算，对于每轮使用的数据和MD5也是有区别的，MD5处理每次分组的数据就是把数据分成16组，每轮使用的都是这16组数据，而SHA1则不一样，只有前16组使用的是拆分的数据，从16-80则根据公式得到新的数据 /* a. Divide M(i) into 16 words W(0), W(1), ..., W(15), where W(0) is the left - most word. */ for (t = 0; t \u003c= 15; t++) { W[t] = M[t]; } /* b. For t = 16 to 79 let W(t) = S^1(W(t-3) XOR W(t-8) XOR W(t-14) XOR W(t-16)). */ for (t = 16; t \u003c= 79; t++) { W[t] = MoveLeft(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1); } 首先先看看四个非线性函数参考（二、四轮其实是一样的） /* f(X, Y, Z) */ /* [0, 19] */ static uint32_t Ch(uint32_t X, uint32_t Y, uint32_t Z) { return (X \u0026 Y) ^ ((~X) \u0026 Z); } /* [20, 39] */ /* [60, 79] */ static uint32_t Parity(uint32_t X, uint32_t Y, uint32_t Z) { return X ^ Y ^ Z; } /* [40, 59] */ static uint32_t Maj(uint32_t X, uint32_t Y, uint32_t Z) { return (X \u0026 Y) ^ (X \u0026 Z) ^ (Y \u0026 Z); } 接着是每次计算所会涉及到的常量K，还记得在MD5中有个常量表T表，T表是根据公式计算得来的64个常量，而K就是直接给好的 K(t) = 5A827999 ( 0 \u003c= t \u003c= 19) K(t) = 6ED9EBA1 (20 \u003c= t \u003c= 39) K(t) = 8F1BBCDC (40 \u003c= t \u003c= 59) K(t) = CA62C1D6 (60 \u003c= t \u003c= 79) 文档也给的很干脆，每轮一个固定常量 下面该讲到具体的处理了，MD5算法每次计算改变的只是一个变量的值，但是SHA1每次计算则会改变五个变量的值 uint32_t temp = MoveLeft(A, 5) + Ch(B, C, D) + E + W[t] + K[0]; E = D; D = C; C = MoveLeft(B, 30); B = A; A = temp; 最终只需要将得到的a、b、c、d重新赋值再作为初始变量传递给下一分组计算即可 5 输出结果在经过分组计算后能够得到A、B、C、D、E，从低位字节A开始，高位字节E结束 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["SHA1算法"],"title":"从RFC3174中理解SHA1算法","uri":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/#3-初始化变量"},{"categories":["加密算法研究"],"content":" 二、算法流程算法流程就不多做介绍，和MD5算法类似，同样需要通过五个步骤来完成 1 补位基本一样，不做额外说明 2 记录信息长度同上 3 初始化变量这一步开始有不同了，SHA1算法也同样有初始变量，与MD5不同的是，MD5最终是依靠初始变量组合起来的16个字节的结果，而SHA1结果为20个字节，因此也在初始变量中多了4个字节，定义如下 uint32_t H0 = 0x67452301; // 0x01, 0x23, 0x45, 0x67 uint32_t H1 = 0xEFCDAB89; // 0x89, 0xAB, 0xCD, 0xEF uint32_t H2 = 0x98BADCFE; // 0xFE, 0xDC, 0xBA, 0x98 uint32_t H3 = 0x10325476; // 0x76, 0x54, 0x32, 0x10 uint32_t H4 = 0xC3D2E1F0; // 0xF0, 0xE1, 0xD2, 0xC3 初始化变量的个数和结果有直接关系，因为结果是由初始化变量组合在一起的 4 处理分组数据这一步大体结构一样，但是处理的方式有点不同 分组方式不说了，同样是将数据处理成了N*512的分组形式，下面再对每个分组进行二次分组成16份，也就是16*32=512，每个子分组是32bit的数据，着重讲讲和MD5算法的不同点 相比于MD5的四轮计算，SHA1也会涉及到四轮计算，每轮则增加到20次，一共是80次非线性函数计算，对于每轮使用的数据和MD5也是有区别的，MD5处理每次分组的数据就是把数据分成16组，每轮使用的都是这16组数据，而SHA1则不一样，只有前16组使用的是拆分的数据，从16-80则根据公式得到新的数据 /* a. Divide M(i) into 16 words W(0), W(1), ..., W(15), where W(0) is the left - most word. */ for (t = 0; t \u003c= 15; t++) { W[t] = M[t]; } /* b. For t = 16 to 79 let W(t) = S^1(W(t-3) XOR W(t-8) XOR W(t-14) XOR W(t-16)). */ for (t = 16; t \u003c= 79; t++) { W[t] = MoveLeft(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1); } 首先先看看四个非线性函数参考（二、四轮其实是一样的） /* f(X, Y, Z) */ /* [0, 19] */ static uint32_t Ch(uint32_t X, uint32_t Y, uint32_t Z) { return (X \u0026 Y) ^ ((~X) \u0026 Z); } /* [20, 39] */ /* [60, 79] */ static uint32_t Parity(uint32_t X, uint32_t Y, uint32_t Z) { return X ^ Y ^ Z; } /* [40, 59] */ static uint32_t Maj(uint32_t X, uint32_t Y, uint32_t Z) { return (X \u0026 Y) ^ (X \u0026 Z) ^ (Y \u0026 Z); } 接着是每次计算所会涉及到的常量K，还记得在MD5中有个常量表T表，T表是根据公式计算得来的64个常量，而K就是直接给好的 K(t) = 5A827999 ( 0 \u003c= t \u003c= 19) K(t) = 6ED9EBA1 (20 \u003c= t \u003c= 39) K(t) = 8F1BBCDC (40 \u003c= t \u003c= 59) K(t) = CA62C1D6 (60 \u003c= t \u003c= 79) 文档也给的很干脆，每轮一个固定常量 下面该讲到具体的处理了，MD5算法每次计算改变的只是一个变量的值，但是SHA1每次计算则会改变五个变量的值 uint32_t temp = MoveLeft(A, 5) + Ch(B, C, D) + E + W[t] + K[0]; E = D; D = C; C = MoveLeft(B, 30); B = A; A = temp; 最终只需要将得到的a、b、c、d重新赋值再作为初始变量传递给下一分组计算即可 5 输出结果在经过分组计算后能够得到A、B、C、D、E，从低位字节A开始，高位字节E结束 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["SHA1算法"],"title":"从RFC3174中理解SHA1算法","uri":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/#4-处理分组数据"},{"categories":["加密算法研究"],"content":" 二、算法流程算法流程就不多做介绍，和MD5算法类似，同样需要通过五个步骤来完成 1 补位基本一样，不做额外说明 2 记录信息长度同上 3 初始化变量这一步开始有不同了，SHA1算法也同样有初始变量，与MD5不同的是，MD5最终是依靠初始变量组合起来的16个字节的结果，而SHA1结果为20个字节，因此也在初始变量中多了4个字节，定义如下 uint32_t H0 = 0x67452301; // 0x01, 0x23, 0x45, 0x67 uint32_t H1 = 0xEFCDAB89; // 0x89, 0xAB, 0xCD, 0xEF uint32_t H2 = 0x98BADCFE; // 0xFE, 0xDC, 0xBA, 0x98 uint32_t H3 = 0x10325476; // 0x76, 0x54, 0x32, 0x10 uint32_t H4 = 0xC3D2E1F0; // 0xF0, 0xE1, 0xD2, 0xC3 初始化变量的个数和结果有直接关系，因为结果是由初始化变量组合在一起的 4 处理分组数据这一步大体结构一样，但是处理的方式有点不同 分组方式不说了，同样是将数据处理成了N*512的分组形式，下面再对每个分组进行二次分组成16份，也就是16*32=512，每个子分组是32bit的数据，着重讲讲和MD5算法的不同点 相比于MD5的四轮计算，SHA1也会涉及到四轮计算，每轮则增加到20次，一共是80次非线性函数计算，对于每轮使用的数据和MD5也是有区别的，MD5处理每次分组的数据就是把数据分成16组，每轮使用的都是这16组数据，而SHA1则不一样，只有前16组使用的是拆分的数据，从16-80则根据公式得到新的数据 /* a. Divide M(i) into 16 words W(0), W(1), ..., W(15), where W(0) is the left - most word. */ for (t = 0; t \u003c= 15; t++) { W[t] = M[t]; } /* b. For t = 16 to 79 let W(t) = S^1(W(t-3) XOR W(t-8) XOR W(t-14) XOR W(t-16)). */ for (t = 16; t \u003c= 79; t++) { W[t] = MoveLeft(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1); } 首先先看看四个非线性函数参考（二、四轮其实是一样的） /* f(X, Y, Z) */ /* [0, 19] */ static uint32_t Ch(uint32_t X, uint32_t Y, uint32_t Z) { return (X \u0026 Y) ^ ((~X) \u0026 Z); } /* [20, 39] */ /* [60, 79] */ static uint32_t Parity(uint32_t X, uint32_t Y, uint32_t Z) { return X ^ Y ^ Z; } /* [40, 59] */ static uint32_t Maj(uint32_t X, uint32_t Y, uint32_t Z) { return (X \u0026 Y) ^ (X \u0026 Z) ^ (Y \u0026 Z); } 接着是每次计算所会涉及到的常量K，还记得在MD5中有个常量表T表，T表是根据公式计算得来的64个常量，而K就是直接给好的 K(t) = 5A827999 ( 0 \u003c= t \u003c= 19) K(t) = 6ED9EBA1 (20 \u003c= t \u003c= 39) K(t) = 8F1BBCDC (40 \u003c= t \u003c= 59) K(t) = CA62C1D6 (60 \u003c= t \u003c= 79) 文档也给的很干脆，每轮一个固定常量 下面该讲到具体的处理了，MD5算法每次计算改变的只是一个变量的值，但是SHA1每次计算则会改变五个变量的值 uint32_t temp = MoveLeft(A, 5) + Ch(B, C, D) + E + W[t] + K[0]; E = D; D = C; C = MoveLeft(B, 30); B = A; A = temp; 最终只需要将得到的a、b、c、d重新赋值再作为初始变量传递给下一分组计算即可 5 输出结果在经过分组计算后能够得到A、B、C、D、E，从低位字节A开始，高位字节E结束 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["SHA1算法"],"title":"从RFC3174中理解SHA1算法","uri":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/#5-输出结果"},{"categories":["加密算法研究"],"content":" 总结文中每个步骤都在对比MD5和SHA1的异同，可以看出，虽然结果上SHA1只是多了4个字节，但是在细节上还是有很大的提升，算法整体上更复杂了，变化也更多了，下面总体归纳下两个算法的异同 算法 MD5 SHA1 分组数据处理 使用同一套16组数据 基于16组数据的基础上变化得到额外64组数据 初始化常量 4个 5个 非线性函数 4个 4个 常量表 T常量表分配给64次计算，各不相同 K表分配给80次计算，每20次使用同一个常量 常量变化 每次计算重新给一个常量赋值 每次计算所有常量全部发生变化 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/:0:3","series":null,"tags":["SHA1算法"],"title":"从RFC3174中理解SHA1算法","uri":"/%E4%BB%8Erfc3174%E4%B8%AD%E7%90%86%E8%A7%A3sha1%E7%AE%97%E6%B3%95/#总结"},{"categories":["加密算法研究"],"content":" 一、前置知识点Base64算法是一种编码算法，它是采用常见的64个字符来表示做数据映射的表，分别是A-Z、a-z、+、/。 64对应的二进制是0b111111，也就是 2^6 = 64 换句话说，6个bit就能表示一个字符，而正常的字节对应的8bit，要把正常字符和编码后的字符串联起来的话那么就需要找出它们的最小公倍数，以最小公倍数所代表的长度来划分，那么8和6的公倍数是24，也就可以这么理解，3个正常字符实际上对应的是4个编码字符，举例说明下 lin的正常二进制编码 01101100|01101001|01101110 变成base64的编码 011011|000110|100101|101110 # 正常来说8bit组成一个字节，所以划分成base64的编码之后还需要在前面补两个0变成正常的8bit 变成十进制 27|6|37|46 获取映射表 bGlu 这样就得到了最终的编码，所以就可以理解正常字符中每三个字符会对应编码后的四个字符，如果按长度3来切分存在余数的话（例如1、2），就使用0来做填充，而填充的输出通常用=来表示，所以一般都能看到在base64编码后的字符存在=的情况，这样就表示字符长度非3的倍数（一般余数为1的话就是两个=） ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc4648%E4%B8%AD%E7%90%86%E8%A7%A3base64%E7%AE%97%E6%B3%95/:0:1","series":null,"tags":["Base64算法"],"title":"从RFC4648中理解Base64算法","uri":"/%E4%BB%8Erfc4648%E4%B8%AD%E7%90%86%E8%A7%A3base64%E7%AE%97%E6%B3%95/#一前置知识点"},{"categories":["加密算法研究"],"content":" 二、算法流程 1 分组并获取映射获取输入字符的长度，每3个字符为一组来进行处理 第一个字符的处理：获取字符的二进制前6位，并获取对应的映射 ret.push_back(base64_chars_[(bytes_to_encode[pos + 0] \u0026 0xfc) \u003e\u003e 2]); 第二个字符的处理：第一个字符还剩余两位，取出低位2个bit，同时左移四位并取出第二个字符的前4个bit ret.push_back(base64_chars_[((bytes_to_encode[pos + 0] \u0026 0x03) \u003c\u003c 4) + ((bytes_to_encode[pos + 1] \u0026 0xf0) \u003e\u003e 4)]); 第三个字符的处理：第二个字符的后4个bit还没取出，取出并取第三个字符的前2个bit ret.push_back(base64_chars_[((bytes_to_encode[pos + 1] \u0026 0x0f) \u003c\u003c 2) + ((bytes_to_encode[pos + 2] \u0026 0xc0) \u003e\u003e 6)]); 第四个字符的处理：直接取出剩余的低六位即可 ret.push_back(base64_chars_[ bytes_to_encode[pos + 2] \u0026 0x3f]); 3 尾端处理剩余两个字符的情况 ret.push_back(base64_chars_[(bytes_to_encode[pos + 1] \u0026 0x0f) \u003c\u003c 2]); ret.push_back(trailing_char); 剩余一个字符的情况 ret.push_back(base64_chars_[(bytes_to_encode[pos + 0] \u0026 0x03) \u003c\u003c 4]); ret.push_back(trailing_char); ret.push_back(trailing_char); ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc4648%E4%B8%AD%E7%90%86%E8%A7%A3base64%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["Base64算法"],"title":"从RFC4648中理解Base64算法","uri":"/%E4%BB%8Erfc4648%E4%B8%AD%E7%90%86%E8%A7%A3base64%E7%AE%97%E6%B3%95/#二算法流程"},{"categories":["加密算法研究"],"content":" 二、算法流程 1 分组并获取映射获取输入字符的长度，每3个字符为一组来进行处理 第一个字符的处理：获取字符的二进制前6位，并获取对应的映射 ret.push_back(base64_chars_[(bytes_to_encode[pos + 0] \u0026 0xfc) \u003e\u003e 2]); 第二个字符的处理：第一个字符还剩余两位，取出低位2个bit，同时左移四位并取出第二个字符的前4个bit ret.push_back(base64_chars_[((bytes_to_encode[pos + 0] \u0026 0x03) \u003c\u003c 4) + ((bytes_to_encode[pos + 1] \u0026 0xf0) \u003e\u003e 4)]); 第三个字符的处理：第二个字符的后4个bit还没取出，取出并取第三个字符的前2个bit ret.push_back(base64_chars_[((bytes_to_encode[pos + 1] \u0026 0x0f) \u003c\u003c 2) + ((bytes_to_encode[pos + 2] \u0026 0xc0) \u003e\u003e 6)]); 第四个字符的处理：直接取出剩余的低六位即可 ret.push_back(base64_chars_[ bytes_to_encode[pos + 2] \u0026 0x3f]); 3 尾端处理剩余两个字符的情况 ret.push_back(base64_chars_[(bytes_to_encode[pos + 1] \u0026 0x0f) \u003c\u003c 2]); ret.push_back(trailing_char); 剩余一个字符的情况 ret.push_back(base64_chars_[(bytes_to_encode[pos + 0] \u0026 0x03) \u003c\u003c 4]); ret.push_back(trailing_char); ret.push_back(trailing_char); ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc4648%E4%B8%AD%E7%90%86%E8%A7%A3base64%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["Base64算法"],"title":"从RFC4648中理解Base64算法","uri":"/%E4%BB%8Erfc4648%E4%B8%AD%E7%90%86%E8%A7%A3base64%E7%AE%97%E6%B3%95/#1-分组并获取映射"},{"categories":["加密算法研究"],"content":" 二、算法流程 1 分组并获取映射获取输入字符的长度，每3个字符为一组来进行处理 第一个字符的处理：获取字符的二进制前6位，并获取对应的映射 ret.push_back(base64_chars_[(bytes_to_encode[pos + 0] \u0026 0xfc) \u003e\u003e 2]); 第二个字符的处理：第一个字符还剩余两位，取出低位2个bit，同时左移四位并取出第二个字符的前4个bit ret.push_back(base64_chars_[((bytes_to_encode[pos + 0] \u0026 0x03) \u003c\u003c 4) + ((bytes_to_encode[pos + 1] \u0026 0xf0) \u003e\u003e 4)]); 第三个字符的处理：第二个字符的后4个bit还没取出，取出并取第三个字符的前2个bit ret.push_back(base64_chars_[((bytes_to_encode[pos + 1] \u0026 0x0f) \u003c\u003c 2) + ((bytes_to_encode[pos + 2] \u0026 0xc0) \u003e\u003e 6)]); 第四个字符的处理：直接取出剩余的低六位即可 ret.push_back(base64_chars_[ bytes_to_encode[pos + 2] \u0026 0x3f]); 3 尾端处理剩余两个字符的情况 ret.push_back(base64_chars_[(bytes_to_encode[pos + 1] \u0026 0x0f) \u003c\u003c 2]); ret.push_back(trailing_char); 剩余一个字符的情况 ret.push_back(base64_chars_[(bytes_to_encode[pos + 0] \u0026 0x03) \u003c\u003c 4]); ret.push_back(trailing_char); ret.push_back(trailing_char); ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc4648%E4%B8%AD%E7%90%86%E8%A7%A3base64%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["Base64算法"],"title":"从RFC4648中理解Base64算法","uri":"/%E4%BB%8Erfc4648%E4%B8%AD%E7%90%86%E8%A7%A3base64%E7%AE%97%E6%B3%95/#3-尾端处理"},{"categories":["加密算法研究"],"content":" 三、解码算法流程解码流程就可以当做编码流程的逆向过程，将每个编码根据映射表转化成索引-\u003e二进制，再组合起来即可 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc4648%E4%B8%AD%E7%90%86%E8%A7%A3base64%E7%AE%97%E6%B3%95/:0:3","series":null,"tags":["Base64算法"],"title":"从RFC4648中理解Base64算法","uri":"/%E4%BB%8Erfc4648%E4%B8%AD%E7%90%86%E8%A7%A3base64%E7%AE%97%E6%B3%95/#三解码算法流程"},{"categories":["加密算法研究"],"content":" 总结综合上面所讲到的MD5算法原理，可以看出Base64还是比较简单易懂的，与最终结果相关的正如上面所讲到的有一个关键点，理解它们的含义以及作用在后续我们对Base64算法进行魔改的时候是很有帮助的 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc4648%E4%B8%AD%E7%90%86%E8%A7%A3base64%E7%AE%97%E6%B3%95/:0:4","series":null,"tags":["Base64算法"],"title":"从RFC4648中理解Base64算法","uri":"/%E4%BB%8Erfc4648%E4%B8%AD%E7%90%86%E8%A7%A3base64%E7%AE%97%E6%B3%95/#总结"},{"categories":["加密算法研究"],"content":" 一、RC4概述RC4是在1987年提出，和DES算法一样。是一种对称加密算法，也就是说使用的密钥为单钥（或称为私钥）。但不同于DES算法的是。RC4不是对明文进行分组处理，而是通过字节流的方式依次加密明文中的每个字节，同样的，解密的时候也是依次对密文中的每个字节进行解密。 RC4算法的一个特点是可变密钥，可变范围在1~256字节，也就是8位~2048位 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc6229%E4%B8%AD%E7%90%86%E8%A7%A3rc4%E7%AE%97%E6%B3%95/:0:1","series":null,"tags":["RC4算法"],"title":"从RFC6229中理解RC4算法","uri":"/%E4%BB%8Erfc6229%E4%B8%AD%E7%90%86%E8%A7%A3rc4%E7%AE%97%E6%B3%95/#一rc4概述"},{"categories":["加密算法研究"],"content":" 二、RC4算法框架RC4算法简单、易于描述，主要使用一个S表来生成密钥流，分为密钥调度算法（KSA）和伪随机数生成算法（PRGA）两个步骤。其中KSA使用原始密钥生成S表，PRGA利用S表来产生密钥流序列。 上面已经说过了，原始密钥K是可变的，而加密单位的话以一个字节为准。 1 密钥调度算法（Key Scheduling Algorithm，KSA）密钥调度算法的作用是，利用原始密钥K来生成S表 这里的密钥K的长度为1~256字节。S表类似于一个数组，其大小为256，表示为S[0]~S[255]，其中每个S表单元可以存放一个字节（8位） S表的生成分为初始化和置换两部分： 初始化 首先对S表的每个单元依照编号从0~255依次填充（二进制序列）。即S[0]=0；S[1]=1；……S[255]=255 接着建立一个临时数组T，称为T表，其大小与S表相同。使用原始密钥K对T表进行填充。如果K的长度等于256，则直接将K赋值给T表。如果K的长度小于256，则T表剩余的部分继续使用密钥K循环填充，直到填满为止。假设密钥K=123，T表长度为7，则T表=1231231 用代码来描述的话如下 unsigned char S[256]; //状态向量S表 unsigned char T[256]; //临时向量T表 vector\u003cchar\u003e K; int keylen; //密钥长度，keylen个字节，取值范围为1-256 for(int i = 0; i \u003c 256; i++)//对S表、T表的每个单元进行填充 { //填充S表 S[i] = i; //填充T表，使用密钥K循环填充，keylen为密钥K的长度 T[i] = K[i % keylen]; } 置换 置换过程就是根据一定的规则，对S表中的单元交换位置，交换的规则为： 初始化一个变量j=0，然后对于S表的第i个单元，计算得j=(j+S[i]+T[i])mod256，括号中的j为上一次计算得出的j值 每次计算出j后，交换S[i]和S[j]的值 以上的代码如下： int j=0; for(int i=0;i\u003c256;++i){ j=(j+S[i]+T[i])%256; //cout\u003c\u003c\"j=\"\u003c\u003cj\u003c\u003cendl; S[i]=S[i]+S[j]; S[j]=S[i]-S[j]; S[i]=S[i]-S[j]; } 经过置换后，S表中的内容也没有发生实质性的变化，只是各个字节被打乱了位置而已 2 伪随机数生成算法（Pseudo-Random Generation Algorithm，PRGA）在经过KSA后，S表被建立了起来，之后的任务就是从S表中选取字节单元，输出密钥流序列 为了使生成的密钥流序列更加的随机，PRGA每生成一个字节的密钥流，就会打乱一次S表 生成密钥流、打乱S表的步骤如下： 初始化：首先初始化两个变量i=0，j=0 递增：然后每次在生成一字节的密钥流之前，i+=1（但不能超过256，需要mod256），j+=S[i]（但不能超过256，需要mod256） 交换打乱：交换S[i]和S[j]的值，用来打乱S表 输出：这时就可以输出一字节的密钥流，密钥流取自S表的第S[i]+S[j]的值取余256 重复上述步骤，即可生成多个字节的密钥流序列，代码如下： int i = 0,j = 0;//初始化i，j为0 while(true) { //i自增1 i = (i + 1) % 256; //j自增S[i] j = (j + S[i]) % 256; //交换，打乱S表 swap(S[i], S[j]); //使用变量t保存输出S表的第几个单元 t = (S[i] + S[j]) % 256; //输出一字节的密钥流序列k k = S[t]; } 通过以上方式，就可以得到一系列字节的流密钥序列。之后，使用一字节的流密钥序列与一字节的明文序列异或可以得到密文；同理，使用一字节的流密钥序列与一字节的密文序列异或可以得到明文 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc6229%E4%B8%AD%E7%90%86%E8%A7%A3rc4%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["RC4算法"],"title":"从RFC6229中理解RC4算法","uri":"/%E4%BB%8Erfc6229%E4%B8%AD%E7%90%86%E8%A7%A3rc4%E7%AE%97%E6%B3%95/#二rc4算法框架"},{"categories":["加密算法研究"],"content":" 二、RC4算法框架RC4算法简单、易于描述，主要使用一个S表来生成密钥流，分为密钥调度算法（KSA）和伪随机数生成算法（PRGA）两个步骤。其中KSA使用原始密钥生成S表，PRGA利用S表来产生密钥流序列。 上面已经说过了，原始密钥K是可变的，而加密单位的话以一个字节为准。 1 密钥调度算法（Key Scheduling Algorithm，KSA）密钥调度算法的作用是，利用原始密钥K来生成S表 这里的密钥K的长度为1~256字节。S表类似于一个数组，其大小为256，表示为S[0]~S[255]，其中每个S表单元可以存放一个字节（8位） S表的生成分为初始化和置换两部分： 初始化 首先对S表的每个单元依照编号从0~255依次填充（二进制序列）。即S[0]=0；S[1]=1；……S[255]=255 接着建立一个临时数组T，称为T表，其大小与S表相同。使用原始密钥K对T表进行填充。如果K的长度等于256，则直接将K赋值给T表。如果K的长度小于256，则T表剩余的部分继续使用密钥K循环填充，直到填满为止。假设密钥K=123，T表长度为7，则T表=1231231 用代码来描述的话如下 unsigned char S[256]; //状态向量S表 unsigned char T[256]; //临时向量T表 vector K; int keylen; //密钥长度，keylen个字节，取值范围为1-256 for(int i = 0; i \u003c 256; i++)//对S表、T表的每个单元进行填充 { //填充S表 S[i] = i; //填充T表，使用密钥K循环填充，keylen为密钥K的长度 T[i] = K[i % keylen]; } 置换 置换过程就是根据一定的规则，对S表中的单元交换位置，交换的规则为： 初始化一个变量j=0，然后对于S表的第i个单元，计算得j=(j+S[i]+T[i])mod256，括号中的j为上一次计算得出的j值 每次计算出j后，交换S[i]和S[j]的值 以上的代码如下： int j=0; for(int i=0;i\u003c256;++i){ j=(j+S[i]+T[i])%256; //cout\u003c\u003c\"j=\"\u003c","date":"2023-05-09","objectID":"/%E4%BB%8Erfc6229%E4%B8%AD%E7%90%86%E8%A7%A3rc4%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["RC4算法"],"title":"从RFC6229中理解RC4算法","uri":"/%E4%BB%8Erfc6229%E4%B8%AD%E7%90%86%E8%A7%A3rc4%E7%AE%97%E6%B3%95/#1-密钥调度算法key-scheduling-algorithmksa"},{"categories":["加密算法研究"],"content":" 二、RC4算法框架RC4算法简单、易于描述，主要使用一个S表来生成密钥流，分为密钥调度算法（KSA）和伪随机数生成算法（PRGA）两个步骤。其中KSA使用原始密钥生成S表，PRGA利用S表来产生密钥流序列。 上面已经说过了，原始密钥K是可变的，而加密单位的话以一个字节为准。 1 密钥调度算法（Key Scheduling Algorithm，KSA）密钥调度算法的作用是，利用原始密钥K来生成S表 这里的密钥K的长度为1~256字节。S表类似于一个数组，其大小为256，表示为S[0]~S[255]，其中每个S表单元可以存放一个字节（8位） S表的生成分为初始化和置换两部分： 初始化 首先对S表的每个单元依照编号从0~255依次填充（二进制序列）。即S[0]=0；S[1]=1；……S[255]=255 接着建立一个临时数组T，称为T表，其大小与S表相同。使用原始密钥K对T表进行填充。如果K的长度等于256，则直接将K赋值给T表。如果K的长度小于256，则T表剩余的部分继续使用密钥K循环填充，直到填满为止。假设密钥K=123，T表长度为7，则T表=1231231 用代码来描述的话如下 unsigned char S[256]; //状态向量S表 unsigned char T[256]; //临时向量T表 vector K; int keylen; //密钥长度，keylen个字节，取值范围为1-256 for(int i = 0; i \u003c 256; i++)//对S表、T表的每个单元进行填充 { //填充S表 S[i] = i; //填充T表，使用密钥K循环填充，keylen为密钥K的长度 T[i] = K[i % keylen]; } 置换 置换过程就是根据一定的规则，对S表中的单元交换位置，交换的规则为： 初始化一个变量j=0，然后对于S表的第i个单元，计算得j=(j+S[i]+T[i])mod256，括号中的j为上一次计算得出的j值 每次计算出j后，交换S[i]和S[j]的值 以上的代码如下： int j=0; for(int i=0;i\u003c256;++i){ j=(j+S[i]+T[i])%256; //cout\u003c\u003c\"j=\"\u003c","date":"2023-05-09","objectID":"/%E4%BB%8Erfc6229%E4%B8%AD%E7%90%86%E8%A7%A3rc4%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["RC4算法"],"title":"从RFC6229中理解RC4算法","uri":"/%E4%BB%8Erfc6229%E4%B8%AD%E7%90%86%E8%A7%A3rc4%E7%AE%97%E6%B3%95/#2-伪随机数生成算法pseudo-random-generation-algorithmprga"},{"categories":["加密算法研究"],"content":" 一、前置知识点SHA2-256算法是SHA第二代的算法，256指的是它的算法结果会产生256位数据，也就是32字节、64位长度的16进制字符。 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/:0:1","series":null,"tags":["SHA256算法"],"title":"从RFC6234中理解SHA2-256算法","uri":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/#一前置知识点"},{"categories":["加密算法研究"],"content":" 二、算法流程算法流程就不多做介绍，同其他哈希算法流程类似，都需要经历补位、填充长度以及分组，不同的是每轮循环所做的操作 1 补位基本一样，不做额外说明 2 记录信息长度同上 3 初始化变量依旧是从常量的初始化开始，根据结果256位来看，需要8个常量组成，常量的计算方式是取自自然数中前面8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分的前32位，举例看 \u003e\u003e\u003e 2**0.5-1 0.41421356237309515 0.41421356237309515=6*16^-1+a*16^-2+0\u002616^-3··· 于是, 质数2的平方根的小数部分取前32位就对应0x6a09e667，据此类推，初始化常量的值就是 m_state[0] = 0x6a09e667; m_state[1] = 0xbb67ae85; m_state[2] = 0x3c6ef372; m_state[3] = 0xa54ff53a; m_state[4] = 0x510e527f; m_state[5] = 0x9b05688c; m_state[6] = 0x1f83d9ab; m_state[7] = 0x5be0cd19; 4 处理分组数据还是同样的套路，输入的数据被分成每512位一组，而512位的数据又被拆分成每32位一小组，一共是16个小组，SHA256的循环轮次和MD5是相同的，但是SHA256和SHA1一样，除了初始的16组是原始的以外，剩余的组都通过额外的公式来计算得来 根据文档 For t = 0 to 15 Wt = M(i)t For t = 16 to 63 Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(w(t-15)) + W(t-16) c++实现 for (uint8_t i = 0, j = 0; i \u003c 16; i++, j += 4) { // Split data in 32 bit blocks for the 16 first words m[i] = (m_data[j] \u003c\u003c 24) | (m_data[j + 1] \u003c\u003c 16) | (m_data[j + 2] \u003c\u003c 8) | (m_data[j + 3]); } for (uint8_t k = 16 ; k \u003c 64; k++) { // Remaining 48 blocks m[k] = SHA256::sig1(m[k - 2]) + m[k - 7] + SHA256::sig0(m[k - 15]) + m[k - 16]; } uint32_t SHA256::sig0(uint32_t x) { return SHA256::rotr(x, 7) ^ SHA256::rotr(x, 18) ^ (x \u003e\u003e 3); } uint32_t SHA256::sig1(uint32_t x) { return SHA256::rotr(x, 17) ^ SHA256::rotr(x, 19) ^ (x \u003e\u003e 10); } 针对64轮次每轮同样有常量，而SHA256的常量计算方式如下（取自自然数中前面64个素数的立方根的小数部分的前32位） unsigned int K[64] = { 0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5, 0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5, 0xd807aa98,0x12835b01,0x243185be,0x550c7dc3, 0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174, 0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc, 0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da, 0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7, 0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967, 0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13, 0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85, 0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3, 0xd192e819,0xd6990624,0xf40e3585,0x106aa070, 0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5, 0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3, 0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208, 0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2 }; 看下主处理流程 3. Perform the main hash computation: For t = 0 to 63 T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt T2 = BSIG0(a) + MAJ(a,b,c) h = g g = f f = e e = d + T1 d = c c = b b = a a = T1 + T2 出现T1、T2两个中间变量，涉及到了4个函数 CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z) MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z) BSIG0(x) = ROTR^2(x) XOR ROTR^13(x) XOR ROTR^22(x) BSIG1(x) = ROTR^6(x) XOR ROTR^11(x) XOR ROTR^25(x) c++来实现 maj = SHA256::majority(state[0], state[1], state[2]); xorA = SHA256::rotr(state[0], 2) ^ SHA256::rotr(state[0], 13) ^ SHA256::rotr(state[0], 22); ch = choose(state[4], state[5], state[6]); xorE = SHA256::rotr(state[4], 6) ^ SHA256::rotr(state[4], 11) ^ SHA256::rotr(state[4], 25); sum = m[i] + K[i] + state[7] + ch + xorE; newA = xorA + maj + sum; newE = state[3] + sum; state[7] = state[6]; state[6] = state[5]; state[5] = state[4]; state[4] = newE; state[3] = state[2]; state[2] = state[1]; state[1] = state[0]; state[0] = newA; 最终只需要将得到的8个变量重新赋值再作为初始变量传递给下一分组计算即可 5 输出结果在经过分组计算后能够得到A、B、C、D、E、F、G、H，从低位字节A开始，高位字节E结束 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["SHA256算法"],"title":"从RFC6234中理解SHA2-256算法","uri":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/#二算法流程"},{"categories":["加密算法研究"],"content":" 二、算法流程算法流程就不多做介绍，同其他哈希算法流程类似，都需要经历补位、填充长度以及分组，不同的是每轮循环所做的操作 1 补位基本一样，不做额外说明 2 记录信息长度同上 3 初始化变量依旧是从常量的初始化开始，根据结果256位来看，需要8个常量组成，常量的计算方式是取自自然数中前面8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分的前32位，举例看 \u003e\u003e\u003e 2**0.5-1 0.41421356237309515 0.41421356237309515=6*16^-1+a*16^-2+0\u002616^-3··· 于是, 质数2的平方根的小数部分取前32位就对应0x6a09e667，据此类推，初始化常量的值就是 m_state[0] = 0x6a09e667; m_state[1] = 0xbb67ae85; m_state[2] = 0x3c6ef372; m_state[3] = 0xa54ff53a; m_state[4] = 0x510e527f; m_state[5] = 0x9b05688c; m_state[6] = 0x1f83d9ab; m_state[7] = 0x5be0cd19; 4 处理分组数据还是同样的套路，输入的数据被分成每512位一组，而512位的数据又被拆分成每32位一小组，一共是16个小组，SHA256的循环轮次和MD5是相同的，但是SHA256和SHA1一样，除了初始的16组是原始的以外，剩余的组都通过额外的公式来计算得来 根据文档 For t = 0 to 15 Wt = M(i)t For t = 16 to 63 Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(w(t-15)) + W(t-16) c++实现 for (uint8_t i = 0, j = 0; i \u003c 16; i++, j += 4) { // Split data in 32 bit blocks for the 16 first words m[i] = (m_data[j] \u003c\u003c 24) | (m_data[j + 1] \u003c\u003c 16) | (m_data[j + 2] \u003c\u003c 8) | (m_data[j + 3]); } for (uint8_t k = 16 ; k \u003c 64; k++) { // Remaining 48 blocks m[k] = SHA256::sig1(m[k - 2]) + m[k - 7] + SHA256::sig0(m[k - 15]) + m[k - 16]; } uint32_t SHA256::sig0(uint32_t x) { return SHA256::rotr(x, 7) ^ SHA256::rotr(x, 18) ^ (x \u003e\u003e 3); } uint32_t SHA256::sig1(uint32_t x) { return SHA256::rotr(x, 17) ^ SHA256::rotr(x, 19) ^ (x \u003e\u003e 10); } 针对64轮次每轮同样有常量，而SHA256的常量计算方式如下（取自自然数中前面64个素数的立方根的小数部分的前32位） unsigned int K[64] = { 0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5, 0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5, 0xd807aa98,0x12835b01,0x243185be,0x550c7dc3, 0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174, 0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc, 0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da, 0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7, 0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967, 0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13, 0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85, 0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3, 0xd192e819,0xd6990624,0xf40e3585,0x106aa070, 0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5, 0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3, 0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208, 0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2 }; 看下主处理流程 3. Perform the main hash computation: For t = 0 to 63 T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt T2 = BSIG0(a) + MAJ(a,b,c) h = g g = f f = e e = d + T1 d = c c = b b = a a = T1 + T2 出现T1、T2两个中间变量，涉及到了4个函数 CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z) MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z) BSIG0(x) = ROTR^2(x) XOR ROTR^13(x) XOR ROTR^22(x) BSIG1(x) = ROTR^6(x) XOR ROTR^11(x) XOR ROTR^25(x) c++来实现 maj = SHA256::majority(state[0], state[1], state[2]); xorA = SHA256::rotr(state[0], 2) ^ SHA256::rotr(state[0], 13) ^ SHA256::rotr(state[0], 22); ch = choose(state[4], state[5], state[6]); xorE = SHA256::rotr(state[4], 6) ^ SHA256::rotr(state[4], 11) ^ SHA256::rotr(state[4], 25); sum = m[i] + K[i] + state[7] + ch + xorE; newA = xorA + maj + sum; newE = state[3] + sum; state[7] = state[6]; state[6] = state[5]; state[5] = state[4]; state[4] = newE; state[3] = state[2]; state[2] = state[1]; state[1] = state[0]; state[0] = newA; 最终只需要将得到的8个变量重新赋值再作为初始变量传递给下一分组计算即可 5 输出结果在经过分组计算后能够得到A、B、C、D、E、F、G、H，从低位字节A开始，高位字节E结束 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["SHA256算法"],"title":"从RFC6234中理解SHA2-256算法","uri":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/#1-补位"},{"categories":["加密算法研究"],"content":" 二、算法流程算法流程就不多做介绍，同其他哈希算法流程类似，都需要经历补位、填充长度以及分组，不同的是每轮循环所做的操作 1 补位基本一样，不做额外说明 2 记录信息长度同上 3 初始化变量依旧是从常量的初始化开始，根据结果256位来看，需要8个常量组成，常量的计算方式是取自自然数中前面8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分的前32位，举例看 \u003e\u003e\u003e 2**0.5-1 0.41421356237309515 0.41421356237309515=6*16^-1+a*16^-2+0\u002616^-3··· 于是, 质数2的平方根的小数部分取前32位就对应0x6a09e667，据此类推，初始化常量的值就是 m_state[0] = 0x6a09e667; m_state[1] = 0xbb67ae85; m_state[2] = 0x3c6ef372; m_state[3] = 0xa54ff53a; m_state[4] = 0x510e527f; m_state[5] = 0x9b05688c; m_state[6] = 0x1f83d9ab; m_state[7] = 0x5be0cd19; 4 处理分组数据还是同样的套路，输入的数据被分成每512位一组，而512位的数据又被拆分成每32位一小组，一共是16个小组，SHA256的循环轮次和MD5是相同的，但是SHA256和SHA1一样，除了初始的16组是原始的以外，剩余的组都通过额外的公式来计算得来 根据文档 For t = 0 to 15 Wt = M(i)t For t = 16 to 63 Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(w(t-15)) + W(t-16) c++实现 for (uint8_t i = 0, j = 0; i \u003c 16; i++, j += 4) { // Split data in 32 bit blocks for the 16 first words m[i] = (m_data[j] \u003c\u003c 24) | (m_data[j + 1] \u003c\u003c 16) | (m_data[j + 2] \u003c\u003c 8) | (m_data[j + 3]); } for (uint8_t k = 16 ; k \u003c 64; k++) { // Remaining 48 blocks m[k] = SHA256::sig1(m[k - 2]) + m[k - 7] + SHA256::sig0(m[k - 15]) + m[k - 16]; } uint32_t SHA256::sig0(uint32_t x) { return SHA256::rotr(x, 7) ^ SHA256::rotr(x, 18) ^ (x \u003e\u003e 3); } uint32_t SHA256::sig1(uint32_t x) { return SHA256::rotr(x, 17) ^ SHA256::rotr(x, 19) ^ (x \u003e\u003e 10); } 针对64轮次每轮同样有常量，而SHA256的常量计算方式如下（取自自然数中前面64个素数的立方根的小数部分的前32位） unsigned int K[64] = { 0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5, 0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5, 0xd807aa98,0x12835b01,0x243185be,0x550c7dc3, 0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174, 0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc, 0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da, 0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7, 0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967, 0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13, 0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85, 0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3, 0xd192e819,0xd6990624,0xf40e3585,0x106aa070, 0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5, 0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3, 0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208, 0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2 }; 看下主处理流程 3. Perform the main hash computation: For t = 0 to 63 T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt T2 = BSIG0(a) + MAJ(a,b,c) h = g g = f f = e e = d + T1 d = c c = b b = a a = T1 + T2 出现T1、T2两个中间变量，涉及到了4个函数 CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z) MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z) BSIG0(x) = ROTR^2(x) XOR ROTR^13(x) XOR ROTR^22(x) BSIG1(x) = ROTR^6(x) XOR ROTR^11(x) XOR ROTR^25(x) c++来实现 maj = SHA256::majority(state[0], state[1], state[2]); xorA = SHA256::rotr(state[0], 2) ^ SHA256::rotr(state[0], 13) ^ SHA256::rotr(state[0], 22); ch = choose(state[4], state[5], state[6]); xorE = SHA256::rotr(state[4], 6) ^ SHA256::rotr(state[4], 11) ^ SHA256::rotr(state[4], 25); sum = m[i] + K[i] + state[7] + ch + xorE; newA = xorA + maj + sum; newE = state[3] + sum; state[7] = state[6]; state[6] = state[5]; state[5] = state[4]; state[4] = newE; state[3] = state[2]; state[2] = state[1]; state[1] = state[0]; state[0] = newA; 最终只需要将得到的8个变量重新赋值再作为初始变量传递给下一分组计算即可 5 输出结果在经过分组计算后能够得到A、B、C、D、E、F、G、H，从低位字节A开始，高位字节E结束 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["SHA256算法"],"title":"从RFC6234中理解SHA2-256算法","uri":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/#2-记录信息长度"},{"categories":["加密算法研究"],"content":" 二、算法流程算法流程就不多做介绍，同其他哈希算法流程类似，都需要经历补位、填充长度以及分组，不同的是每轮循环所做的操作 1 补位基本一样，不做额外说明 2 记录信息长度同上 3 初始化变量依旧是从常量的初始化开始，根据结果256位来看，需要8个常量组成，常量的计算方式是取自自然数中前面8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分的前32位，举例看 \u003e\u003e\u003e 2**0.5-1 0.41421356237309515 0.41421356237309515=6*16^-1+a*16^-2+0\u002616^-3··· 于是, 质数2的平方根的小数部分取前32位就对应0x6a09e667，据此类推，初始化常量的值就是 m_state[0] = 0x6a09e667; m_state[1] = 0xbb67ae85; m_state[2] = 0x3c6ef372; m_state[3] = 0xa54ff53a; m_state[4] = 0x510e527f; m_state[5] = 0x9b05688c; m_state[6] = 0x1f83d9ab; m_state[7] = 0x5be0cd19; 4 处理分组数据还是同样的套路，输入的数据被分成每512位一组，而512位的数据又被拆分成每32位一小组，一共是16个小组，SHA256的循环轮次和MD5是相同的，但是SHA256和SHA1一样，除了初始的16组是原始的以外，剩余的组都通过额外的公式来计算得来 根据文档 For t = 0 to 15 Wt = M(i)t For t = 16 to 63 Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(w(t-15)) + W(t-16) c++实现 for (uint8_t i = 0, j = 0; i \u003c 16; i++, j += 4) { // Split data in 32 bit blocks for the 16 first words m[i] = (m_data[j] \u003c\u003c 24) | (m_data[j + 1] \u003c\u003c 16) | (m_data[j + 2] \u003c\u003c 8) | (m_data[j + 3]); } for (uint8_t k = 16 ; k \u003c 64; k++) { // Remaining 48 blocks m[k] = SHA256::sig1(m[k - 2]) + m[k - 7] + SHA256::sig0(m[k - 15]) + m[k - 16]; } uint32_t SHA256::sig0(uint32_t x) { return SHA256::rotr(x, 7) ^ SHA256::rotr(x, 18) ^ (x \u003e\u003e 3); } uint32_t SHA256::sig1(uint32_t x) { return SHA256::rotr(x, 17) ^ SHA256::rotr(x, 19) ^ (x \u003e\u003e 10); } 针对64轮次每轮同样有常量，而SHA256的常量计算方式如下（取自自然数中前面64个素数的立方根的小数部分的前32位） unsigned int K[64] = { 0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5, 0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5, 0xd807aa98,0x12835b01,0x243185be,0x550c7dc3, 0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174, 0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc, 0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da, 0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7, 0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967, 0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13, 0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85, 0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3, 0xd192e819,0xd6990624,0xf40e3585,0x106aa070, 0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5, 0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3, 0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208, 0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2 }; 看下主处理流程 3. Perform the main hash computation: For t = 0 to 63 T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt T2 = BSIG0(a) + MAJ(a,b,c) h = g g = f f = e e = d + T1 d = c c = b b = a a = T1 + T2 出现T1、T2两个中间变量，涉及到了4个函数 CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z) MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z) BSIG0(x) = ROTR^2(x) XOR ROTR^13(x) XOR ROTR^22(x) BSIG1(x) = ROTR^6(x) XOR ROTR^11(x) XOR ROTR^25(x) c++来实现 maj = SHA256::majority(state[0], state[1], state[2]); xorA = SHA256::rotr(state[0], 2) ^ SHA256::rotr(state[0], 13) ^ SHA256::rotr(state[0], 22); ch = choose(state[4], state[5], state[6]); xorE = SHA256::rotr(state[4], 6) ^ SHA256::rotr(state[4], 11) ^ SHA256::rotr(state[4], 25); sum = m[i] + K[i] + state[7] + ch + xorE; newA = xorA + maj + sum; newE = state[3] + sum; state[7] = state[6]; state[6] = state[5]; state[5] = state[4]; state[4] = newE; state[3] = state[2]; state[2] = state[1]; state[1] = state[0]; state[0] = newA; 最终只需要将得到的8个变量重新赋值再作为初始变量传递给下一分组计算即可 5 输出结果在经过分组计算后能够得到A、B、C、D、E、F、G、H，从低位字节A开始，高位字节E结束 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["SHA256算法"],"title":"从RFC6234中理解SHA2-256算法","uri":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/#3-初始化变量"},{"categories":["加密算法研究"],"content":" 二、算法流程算法流程就不多做介绍，同其他哈希算法流程类似，都需要经历补位、填充长度以及分组，不同的是每轮循环所做的操作 1 补位基本一样，不做额外说明 2 记录信息长度同上 3 初始化变量依旧是从常量的初始化开始，根据结果256位来看，需要8个常量组成，常量的计算方式是取自自然数中前面8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分的前32位，举例看 \u003e\u003e\u003e 2**0.5-1 0.41421356237309515 0.41421356237309515=6*16^-1+a*16^-2+0\u002616^-3··· 于是, 质数2的平方根的小数部分取前32位就对应0x6a09e667，据此类推，初始化常量的值就是 m_state[0] = 0x6a09e667; m_state[1] = 0xbb67ae85; m_state[2] = 0x3c6ef372; m_state[3] = 0xa54ff53a; m_state[4] = 0x510e527f; m_state[5] = 0x9b05688c; m_state[6] = 0x1f83d9ab; m_state[7] = 0x5be0cd19; 4 处理分组数据还是同样的套路，输入的数据被分成每512位一组，而512位的数据又被拆分成每32位一小组，一共是16个小组，SHA256的循环轮次和MD5是相同的，但是SHA256和SHA1一样，除了初始的16组是原始的以外，剩余的组都通过额外的公式来计算得来 根据文档 For t = 0 to 15 Wt = M(i)t For t = 16 to 63 Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(w(t-15)) + W(t-16) c++实现 for (uint8_t i = 0, j = 0; i \u003c 16; i++, j += 4) { // Split data in 32 bit blocks for the 16 first words m[i] = (m_data[j] \u003c\u003c 24) | (m_data[j + 1] \u003c\u003c 16) | (m_data[j + 2] \u003c\u003c 8) | (m_data[j + 3]); } for (uint8_t k = 16 ; k \u003c 64; k++) { // Remaining 48 blocks m[k] = SHA256::sig1(m[k - 2]) + m[k - 7] + SHA256::sig0(m[k - 15]) + m[k - 16]; } uint32_t SHA256::sig0(uint32_t x) { return SHA256::rotr(x, 7) ^ SHA256::rotr(x, 18) ^ (x \u003e\u003e 3); } uint32_t SHA256::sig1(uint32_t x) { return SHA256::rotr(x, 17) ^ SHA256::rotr(x, 19) ^ (x \u003e\u003e 10); } 针对64轮次每轮同样有常量，而SHA256的常量计算方式如下（取自自然数中前面64个素数的立方根的小数部分的前32位） unsigned int K[64] = { 0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5, 0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5, 0xd807aa98,0x12835b01,0x243185be,0x550c7dc3, 0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174, 0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc, 0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da, 0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7, 0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967, 0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13, 0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85, 0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3, 0xd192e819,0xd6990624,0xf40e3585,0x106aa070, 0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5, 0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3, 0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208, 0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2 }; 看下主处理流程 3. Perform the main hash computation: For t = 0 to 63 T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt T2 = BSIG0(a) + MAJ(a,b,c) h = g g = f f = e e = d + T1 d = c c = b b = a a = T1 + T2 出现T1、T2两个中间变量，涉及到了4个函数 CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z) MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z) BSIG0(x) = ROTR^2(x) XOR ROTR^13(x) XOR ROTR^22(x) BSIG1(x) = ROTR^6(x) XOR ROTR^11(x) XOR ROTR^25(x) c++来实现 maj = SHA256::majority(state[0], state[1], state[2]); xorA = SHA256::rotr(state[0], 2) ^ SHA256::rotr(state[0], 13) ^ SHA256::rotr(state[0], 22); ch = choose(state[4], state[5], state[6]); xorE = SHA256::rotr(state[4], 6) ^ SHA256::rotr(state[4], 11) ^ SHA256::rotr(state[4], 25); sum = m[i] + K[i] + state[7] + ch + xorE; newA = xorA + maj + sum; newE = state[3] + sum; state[7] = state[6]; state[6] = state[5]; state[5] = state[4]; state[4] = newE; state[3] = state[2]; state[2] = state[1]; state[1] = state[0]; state[0] = newA; 最终只需要将得到的8个变量重新赋值再作为初始变量传递给下一分组计算即可 5 输出结果在经过分组计算后能够得到A、B、C、D、E、F、G、H，从低位字节A开始，高位字节E结束 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["SHA256算法"],"title":"从RFC6234中理解SHA2-256算法","uri":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/#4-处理分组数据"},{"categories":["加密算法研究"],"content":" 二、算法流程算法流程就不多做介绍，同其他哈希算法流程类似，都需要经历补位、填充长度以及分组，不同的是每轮循环所做的操作 1 补位基本一样，不做额外说明 2 记录信息长度同上 3 初始化变量依旧是从常量的初始化开始，根据结果256位来看，需要8个常量组成，常量的计算方式是取自自然数中前面8个素数(2,3,5,7,11,13,17,19)的平方根的小数部分的前32位，举例看 \u003e\u003e\u003e 2**0.5-1 0.41421356237309515 0.41421356237309515=6*16^-1+a*16^-2+0\u002616^-3··· 于是, 质数2的平方根的小数部分取前32位就对应0x6a09e667，据此类推，初始化常量的值就是 m_state[0] = 0x6a09e667; m_state[1] = 0xbb67ae85; m_state[2] = 0x3c6ef372; m_state[3] = 0xa54ff53a; m_state[4] = 0x510e527f; m_state[5] = 0x9b05688c; m_state[6] = 0x1f83d9ab; m_state[7] = 0x5be0cd19; 4 处理分组数据还是同样的套路，输入的数据被分成每512位一组，而512位的数据又被拆分成每32位一小组，一共是16个小组，SHA256的循环轮次和MD5是相同的，但是SHA256和SHA1一样，除了初始的16组是原始的以外，剩余的组都通过额外的公式来计算得来 根据文档 For t = 0 to 15 Wt = M(i)t For t = 16 to 63 Wt = SSIG1(W(t-2)) + W(t-7) + SSIG0(w(t-15)) + W(t-16) c++实现 for (uint8_t i = 0, j = 0; i \u003c 16; i++, j += 4) { // Split data in 32 bit blocks for the 16 first words m[i] = (m_data[j] \u003c\u003c 24) | (m_data[j + 1] \u003c\u003c 16) | (m_data[j + 2] \u003c\u003c 8) | (m_data[j + 3]); } for (uint8_t k = 16 ; k \u003c 64; k++) { // Remaining 48 blocks m[k] = SHA256::sig1(m[k - 2]) + m[k - 7] + SHA256::sig0(m[k - 15]) + m[k - 16]; } uint32_t SHA256::sig0(uint32_t x) { return SHA256::rotr(x, 7) ^ SHA256::rotr(x, 18) ^ (x \u003e\u003e 3); } uint32_t SHA256::sig1(uint32_t x) { return SHA256::rotr(x, 17) ^ SHA256::rotr(x, 19) ^ (x \u003e\u003e 10); } 针对64轮次每轮同样有常量，而SHA256的常量计算方式如下（取自自然数中前面64个素数的立方根的小数部分的前32位） unsigned int K[64] = { 0x428a2f98,0x71374491,0xb5c0fbcf,0xe9b5dba5, 0x3956c25b,0x59f111f1,0x923f82a4,0xab1c5ed5, 0xd807aa98,0x12835b01,0x243185be,0x550c7dc3, 0x72be5d74,0x80deb1fe,0x9bdc06a7,0xc19bf174, 0xe49b69c1,0xefbe4786,0x0fc19dc6,0x240ca1cc, 0x2de92c6f,0x4a7484aa,0x5cb0a9dc,0x76f988da, 0x983e5152,0xa831c66d,0xb00327c8,0xbf597fc7, 0xc6e00bf3,0xd5a79147,0x06ca6351,0x14292967, 0x27b70a85,0x2e1b2138,0x4d2c6dfc,0x53380d13, 0x650a7354,0x766a0abb,0x81c2c92e,0x92722c85, 0xa2bfe8a1,0xa81a664b,0xc24b8b70,0xc76c51a3, 0xd192e819,0xd6990624,0xf40e3585,0x106aa070, 0x19a4c116,0x1e376c08,0x2748774c,0x34b0bcb5, 0x391c0cb3,0x4ed8aa4a,0x5b9cca4f,0x682e6ff3, 0x748f82ee,0x78a5636f,0x84c87814,0x8cc70208, 0x90befffa,0xa4506ceb,0xbef9a3f7,0xc67178f2 }; 看下主处理流程 3. Perform the main hash computation: For t = 0 to 63 T1 = h + BSIG1(e) + CH(e,f,g) + Kt + Wt T2 = BSIG0(a) + MAJ(a,b,c) h = g g = f f = e e = d + T1 d = c c = b b = a a = T1 + T2 出现T1、T2两个中间变量，涉及到了4个函数 CH( x, y, z) = (x AND y) XOR ( (NOT x) AND z) MAJ( x, y, z) = (x AND y) XOR (x AND z) XOR (y AND z) BSIG0(x) = ROTR^2(x) XOR ROTR^13(x) XOR ROTR^22(x) BSIG1(x) = ROTR^6(x) XOR ROTR^11(x) XOR ROTR^25(x) c++来实现 maj = SHA256::majority(state[0], state[1], state[2]); xorA = SHA256::rotr(state[0], 2) ^ SHA256::rotr(state[0], 13) ^ SHA256::rotr(state[0], 22); ch = choose(state[4], state[5], state[6]); xorE = SHA256::rotr(state[4], 6) ^ SHA256::rotr(state[4], 11) ^ SHA256::rotr(state[4], 25); sum = m[i] + K[i] + state[7] + ch + xorE; newA = xorA + maj + sum; newE = state[3] + sum; state[7] = state[6]; state[6] = state[5]; state[5] = state[4]; state[4] = newE; state[3] = state[2]; state[2] = state[1]; state[1] = state[0]; state[0] = newA; 最终只需要将得到的8个变量重新赋值再作为初始变量传递给下一分组计算即可 5 输出结果在经过分组计算后能够得到A、B、C、D、E、F、G、H，从低位字节A开始，高位字节E结束 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["SHA256算法"],"title":"从RFC6234中理解SHA2-256算法","uri":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/#5-输出结果"},{"categories":["加密算法研究"],"content":" 总结在了解了MD5、SHA1算法之后再来看SHA2-256算法的话，很明显能发现SHA2-256结合了前两个算法，包括MD5的每轮次的不同常量以及SHA1的数据分组方式以及每轮次计算方式，并且来降低了计算的轮次，引入更多的空间来替换计算时间效率的提升 ","date":"2023-05-09","objectID":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/:0:3","series":null,"tags":["SHA256算法"],"title":"从RFC6234中理解SHA2-256算法","uri":"/%E4%BB%8Erfc6234%E4%B8%AD%E7%90%86%E8%A7%A3sha2-256%E7%AE%97%E6%B3%95/#总结"},{"categories":["加密算法研究"],"content":" 一、CRC算法概述 循环冗余校验（Cyclic Redundancy Check， CRC）是一种根据网络数据包或计算机文件等数据产生简短固定位数校验码的一种信道编码技术，主要用来检测或校验数据传输或者保存后可能出现的错误。它是利用除法及余数的原理来作错误侦测的。 ––维基百科 在对信息的处理过程中，我们可以将要被处理的数据块M看成一个n阶的二进制多项式，其形式如下 $M=a_{n-1}x^{n-1}+a_{n-2}x^{n-2}+a_{n-3}x^{n-3}+……+a_1x^1+a_0$ CRC校验就是基于这种多项式进行的运算，以GF(2)(The integers modulo 2)多项式算术为数学基础，即(模-2)除法的余数运算（其实说白了就是异或Xor），使用的除数不同，CRC的类型也就不一样。CRC传输实际上就是在长度为 k 的数据后面添加供差错检测(Frame Check Sequence) 用的 r 位冗余码（Redundant code 没错CRC里面的R就是这个），使原数据构成 n = k + r 位并发送出去, 此方式又叫（n, k）码。可以证明存在一个最高次幂为n-k=r的多项式G(x), 根据G(x)可以生成k位信息的校验码，而 G(x) 叫做这个CRC码的生成多项式( Poly )。而根据 k 值的不同，就形成了不同的CRC码的生成多项式，以下为各种常用的多项表达式： $crc-4=x^4+x+1$ $crc-8=x^8+x^5+x^4+1$ $crc-32=x^32+x^26+x^2+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x^1+1$ 这些多项表达式的值便是(模-2)除法的除数，这里选取CRC-32多项式（即为对应除数）格式，通过取余做操，获取CRC检验码 ","date":"2023-05-09","objectID":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/:0:1","series":null,"tags":["CRC32算法"],"title":"理解CRC32算法","uri":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/#一crc算法概述"},{"categories":["加密算法研究"],"content":" 二、CRC32算法框架CRC32校验计算框架如下： 选择一个生成多项式G(x) 假设该生成多项式G(x)的二进制数有k位，在发送的数据帧B(x)(设为m位)后加k-1个0，得到新二进制串H(x)，H(x)位数应该为m+k-1。 H(x)“模2除法”除以G(x)，所得到的余数(记为F(x))就是原数据帧的CRC校验码，又称FCS(帧校验序列)。注意，F(x)的位数只能比G(x)少一位，0不能省略。 将F(x)附加到B(x)后面，组成新帧N(x),然后发送到接收端。 接收端将N(x)以“模2除法”除以G(x)，如果没有余数，则表明没有出错(因为在发送端发送数据帧之前就已附加了一个数,做了去余处理(也就已经能整除了),所以结果应该没有余数。如果有余数,则表明该帧在传输过程中出现了差错)。 1 多项式选择如上面所示，常见CRC标准如下 通常多项式也会使用二进制来表示，计算方式是x的最高幂次对应二进制数的最高位，以下各位对应多项式的各幂次，有此幂次项对应1，无此幂次项对应0。可以看出：x的最高幂次为R，转换成对应的二进制数有R+1位 2 模2除法CRC校验是基于多项式进行的运算，其加减法运算以2为模GF(2) ，加减时不进（借）位，实际上与逻辑异或（XOR）运算是一致, XOR是将参加运算的两个数据，按二进制位进行“异或”运算。 异或运算规则（^）规则如下： 0^0=0； 0^1=1； 1^0=1； 1^1=0； 即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。 3 计算示例以$G(x)=x^4+x^3+1$为例，设原数据为10110011 $G(x)=x^4+x^3+1$, 二进制比特串为11001。（在X的n次方不为0处2的n次方的位=1) 因为校验码4位，所以10110011后面需加4个0，得到101100110000，用“模2除法” (即逻辑亦或^) 即可得出结果： 即CRC^101100110000得到101100110100，并发送到接收端 接收端收到101100110100后除以11001(以“模2除法”方式去除),余数为0则无差错 4 CRC的实现方式一般来说CRC有多种实现方式，通常有直接生成法和查表法两种 直接生成法 适用于CRC次幂较小的格式，当CRC次幂逐渐增高时，因为其复杂的XOR逻辑运算会拖累系统运行速度，不再建议使用直接生成法，取而代之的是查表法——将数据块M 的一部分提前运算好，并将结果存入数组中，系统开始执行运算时，相当于省去了之前的操作，直接从类似中间的位置开始计算，所以会提高效率 生成CRC码表的方式如下： int make_crc32_table() { uint32_t c; int i = 0; int bit = 0; for(i = 0; i \u003c 256; i++) { c = (uint32_t)i; for(bit = 0; bit \u003c 8; bit++) { if(c\u00261) { c = (c \u003e\u003e 1)^(0xEDB88320); } else { c = c \u003e\u003e 1; } } uiCRC32_Table[i] = c; } } ","date":"2023-05-09","objectID":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["CRC32算法"],"title":"理解CRC32算法","uri":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/#二crc32算法框架"},{"categories":["加密算法研究"],"content":" 二、CRC32算法框架CRC32校验计算框架如下： 选择一个生成多项式G(x) 假设该生成多项式G(x)的二进制数有k位，在发送的数据帧B(x)(设为m位)后加k-1个0，得到新二进制串H(x)，H(x)位数应该为m+k-1。 H(x)“模2除法”除以G(x)，所得到的余数(记为F(x))就是原数据帧的CRC校验码，又称FCS(帧校验序列)。注意，F(x)的位数只能比G(x)少一位，0不能省略。 将F(x)附加到B(x)后面，组成新帧N(x),然后发送到接收端。 接收端将N(x)以“模2除法”除以G(x)，如果没有余数，则表明没有出错(因为在发送端发送数据帧之前就已附加了一个数,做了去余处理(也就已经能整除了),所以结果应该没有余数。如果有余数,则表明该帧在传输过程中出现了差错)。 1 多项式选择如上面所示，常见CRC标准如下 通常多项式也会使用二进制来表示，计算方式是x的最高幂次对应二进制数的最高位，以下各位对应多项式的各幂次，有此幂次项对应1，无此幂次项对应0。可以看出：x的最高幂次为R，转换成对应的二进制数有R+1位 2 模2除法CRC校验是基于多项式进行的运算，其加减法运算以2为模GF(2) ，加减时不进（借）位，实际上与逻辑异或（XOR）运算是一致, XOR是将参加运算的两个数据，按二进制位进行“异或”运算。 异或运算规则（^）规则如下： 0^0=0； 0^1=1； 1^0=1； 1^1=0； 即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。 3 计算示例以$G(x)=x^4+x^3+1$为例，设原数据为10110011 $G(x)=x^4+x^3+1$, 二进制比特串为11001。（在X的n次方不为0处2的n次方的位=1) 因为校验码4位，所以10110011后面需加4个0，得到101100110000，用“模2除法” (即逻辑亦或^) 即可得出结果： 即CRC^101100110000得到101100110100，并发送到接收端 接收端收到101100110100后除以11001(以“模2除法”方式去除),余数为0则无差错 4 CRC的实现方式一般来说CRC有多种实现方式，通常有直接生成法和查表法两种 直接生成法 适用于CRC次幂较小的格式，当CRC次幂逐渐增高时，因为其复杂的XOR逻辑运算会拖累系统运行速度，不再建议使用直接生成法，取而代之的是查表法——将数据块M 的一部分提前运算好，并将结果存入数组中，系统开始执行运算时，相当于省去了之前的操作，直接从类似中间的位置开始计算，所以会提高效率 生成CRC码表的方式如下： int make_crc32_table() { uint32_t c; int i = 0; int bit = 0; for(i = 0; i \u003c 256; i++) { c = (uint32_t)i; for(bit = 0; bit \u003c 8; bit++) { if(c\u00261) { c = (c \u003e\u003e 1)^(0xEDB88320); } else { c = c \u003e\u003e 1; } } uiCRC32_Table[i] = c; } } ","date":"2023-05-09","objectID":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["CRC32算法"],"title":"理解CRC32算法","uri":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/#1-多项式选择"},{"categories":["加密算法研究"],"content":" 二、CRC32算法框架CRC32校验计算框架如下： 选择一个生成多项式G(x) 假设该生成多项式G(x)的二进制数有k位，在发送的数据帧B(x)(设为m位)后加k-1个0，得到新二进制串H(x)，H(x)位数应该为m+k-1。 H(x)“模2除法”除以G(x)，所得到的余数(记为F(x))就是原数据帧的CRC校验码，又称FCS(帧校验序列)。注意，F(x)的位数只能比G(x)少一位，0不能省略。 将F(x)附加到B(x)后面，组成新帧N(x),然后发送到接收端。 接收端将N(x)以“模2除法”除以G(x)，如果没有余数，则表明没有出错(因为在发送端发送数据帧之前就已附加了一个数,做了去余处理(也就已经能整除了),所以结果应该没有余数。如果有余数,则表明该帧在传输过程中出现了差错)。 1 多项式选择如上面所示，常见CRC标准如下 通常多项式也会使用二进制来表示，计算方式是x的最高幂次对应二进制数的最高位，以下各位对应多项式的各幂次，有此幂次项对应1，无此幂次项对应0。可以看出：x的最高幂次为R，转换成对应的二进制数有R+1位 2 模2除法CRC校验是基于多项式进行的运算，其加减法运算以2为模GF(2) ，加减时不进（借）位，实际上与逻辑异或（XOR）运算是一致, XOR是将参加运算的两个数据，按二进制位进行“异或”运算。 异或运算规则（^）规则如下： 0^0=0； 0^1=1； 1^0=1； 1^1=0； 即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。 3 计算示例以$G(x)=x^4+x^3+1$为例，设原数据为10110011 $G(x)=x^4+x^3+1$, 二进制比特串为11001。（在X的n次方不为0处2的n次方的位=1) 因为校验码4位，所以10110011后面需加4个0，得到101100110000，用“模2除法” (即逻辑亦或^) 即可得出结果： 即CRC^101100110000得到101100110100，并发送到接收端 接收端收到101100110100后除以11001(以“模2除法”方式去除),余数为0则无差错 4 CRC的实现方式一般来说CRC有多种实现方式，通常有直接生成法和查表法两种 直接生成法 适用于CRC次幂较小的格式，当CRC次幂逐渐增高时，因为其复杂的XOR逻辑运算会拖累系统运行速度，不再建议使用直接生成法，取而代之的是查表法——将数据块M 的一部分提前运算好，并将结果存入数组中，系统开始执行运算时，相当于省去了之前的操作，直接从类似中间的位置开始计算，所以会提高效率 生成CRC码表的方式如下： int make_crc32_table() { uint32_t c; int i = 0; int bit = 0; for(i = 0; i \u003c 256; i++) { c = (uint32_t)i; for(bit = 0; bit \u003c 8; bit++) { if(c\u00261) { c = (c \u003e\u003e 1)^(0xEDB88320); } else { c = c \u003e\u003e 1; } } uiCRC32_Table[i] = c; } } ","date":"2023-05-09","objectID":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["CRC32算法"],"title":"理解CRC32算法","uri":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/#2-模2除法"},{"categories":["加密算法研究"],"content":" 二、CRC32算法框架CRC32校验计算框架如下： 选择一个生成多项式G(x) 假设该生成多项式G(x)的二进制数有k位，在发送的数据帧B(x)(设为m位)后加k-1个0，得到新二进制串H(x)，H(x)位数应该为m+k-1。 H(x)“模2除法”除以G(x)，所得到的余数(记为F(x))就是原数据帧的CRC校验码，又称FCS(帧校验序列)。注意，F(x)的位数只能比G(x)少一位，0不能省略。 将F(x)附加到B(x)后面，组成新帧N(x),然后发送到接收端。 接收端将N(x)以“模2除法”除以G(x)，如果没有余数，则表明没有出错(因为在发送端发送数据帧之前就已附加了一个数,做了去余处理(也就已经能整除了),所以结果应该没有余数。如果有余数,则表明该帧在传输过程中出现了差错)。 1 多项式选择如上面所示，常见CRC标准如下 通常多项式也会使用二进制来表示，计算方式是x的最高幂次对应二进制数的最高位，以下各位对应多项式的各幂次，有此幂次项对应1，无此幂次项对应0。可以看出：x的最高幂次为R，转换成对应的二进制数有R+1位 2 模2除法CRC校验是基于多项式进行的运算，其加减法运算以2为模GF(2) ，加减时不进（借）位，实际上与逻辑异或（XOR）运算是一致, XOR是将参加运算的两个数据，按二进制位进行“异或”运算。 异或运算规则（^）规则如下： 0^0=0； 0^1=1； 1^0=1； 1^1=0； 即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。 3 计算示例以$G(x)=x^4+x^3+1$为例，设原数据为10110011 $G(x)=x^4+x^3+1$, 二进制比特串为11001。（在X的n次方不为0处2的n次方的位=1) 因为校验码4位，所以10110011后面需加4个0，得到101100110000，用“模2除法” (即逻辑亦或^) 即可得出结果： 即CRC^101100110000得到101100110100，并发送到接收端 接收端收到101100110100后除以11001(以“模2除法”方式去除),余数为0则无差错 4 CRC的实现方式一般来说CRC有多种实现方式，通常有直接生成法和查表法两种 直接生成法 适用于CRC次幂较小的格式，当CRC次幂逐渐增高时，因为其复杂的XOR逻辑运算会拖累系统运行速度，不再建议使用直接生成法，取而代之的是查表法——将数据块M 的一部分提前运算好，并将结果存入数组中，系统开始执行运算时，相当于省去了之前的操作，直接从类似中间的位置开始计算，所以会提高效率 生成CRC码表的方式如下： int make_crc32_table() { uint32_t c; int i = 0; int bit = 0; for(i = 0; i \u003c 256; i++) { c = (uint32_t)i; for(bit = 0; bit \u003c 8; bit++) { if(c\u00261) { c = (c \u003e\u003e 1)^(0xEDB88320); } else { c = c \u003e\u003e 1; } } uiCRC32_Table[i] = c; } } ","date":"2023-05-09","objectID":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["CRC32算法"],"title":"理解CRC32算法","uri":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/#3-计算示例"},{"categories":["加密算法研究"],"content":" 二、CRC32算法框架CRC32校验计算框架如下： 选择一个生成多项式G(x) 假设该生成多项式G(x)的二进制数有k位，在发送的数据帧B(x)(设为m位)后加k-1个0，得到新二进制串H(x)，H(x)位数应该为m+k-1。 H(x)“模2除法”除以G(x)，所得到的余数(记为F(x))就是原数据帧的CRC校验码，又称FCS(帧校验序列)。注意，F(x)的位数只能比G(x)少一位，0不能省略。 将F(x)附加到B(x)后面，组成新帧N(x),然后发送到接收端。 接收端将N(x)以“模2除法”除以G(x)，如果没有余数，则表明没有出错(因为在发送端发送数据帧之前就已附加了一个数,做了去余处理(也就已经能整除了),所以结果应该没有余数。如果有余数,则表明该帧在传输过程中出现了差错)。 1 多项式选择如上面所示，常见CRC标准如下 通常多项式也会使用二进制来表示，计算方式是x的最高幂次对应二进制数的最高位，以下各位对应多项式的各幂次，有此幂次项对应1，无此幂次项对应0。可以看出：x的最高幂次为R，转换成对应的二进制数有R+1位 2 模2除法CRC校验是基于多项式进行的运算，其加减法运算以2为模GF(2) ，加减时不进（借）位，实际上与逻辑异或（XOR）运算是一致, XOR是将参加运算的两个数据，按二进制位进行“异或”运算。 异或运算规则（^）规则如下： 0^0=0； 0^1=1； 1^0=1； 1^1=0； 即：参加运算的两个对象，如果两个相应位为“异”（值不同），则该位结果为1，否则为0。 3 计算示例以$G(x)=x^4+x^3+1$为例，设原数据为10110011 $G(x)=x^4+x^3+1$, 二进制比特串为11001。（在X的n次方不为0处2的n次方的位=1) 因为校验码4位，所以10110011后面需加4个0，得到101100110000，用“模2除法” (即逻辑亦或^) 即可得出结果： 即CRC^101100110000得到101100110100，并发送到接收端 接收端收到101100110100后除以11001(以“模2除法”方式去除),余数为0则无差错 4 CRC的实现方式一般来说CRC有多种实现方式，通常有直接生成法和查表法两种 直接生成法 适用于CRC次幂较小的格式，当CRC次幂逐渐增高时，因为其复杂的XOR逻辑运算会拖累系统运行速度，不再建议使用直接生成法，取而代之的是查表法——将数据块M 的一部分提前运算好，并将结果存入数组中，系统开始执行运算时，相当于省去了之前的操作，直接从类似中间的位置开始计算，所以会提高效率 生成CRC码表的方式如下： int make_crc32_table() { uint32_t c; int i = 0; int bit = 0; for(i = 0; i \u003c 256; i++) { c = (uint32_t)i; for(bit = 0; bit \u003c 8; bit++) { if(c\u00261) { c = (c \u003e\u003e 1)^(0xEDB88320); } else { c = c \u003e\u003e 1; } } uiCRC32_Table[i] = c; } } ","date":"2023-05-09","objectID":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/:0:2","series":null,"tags":["CRC32算法"],"title":"理解CRC32算法","uri":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/#4-crc的实现方式"},{"categories":["加密算法研究"],"content":" 三、思考如上面所理解的那样，CRC算法关键在于码表，但是码表也分动态生成和静态表，若是动态生成表，则应留意生成多项式，若是静态表，则会在数据段留下整个表 ","date":"2023-05-09","objectID":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/:0:3","series":null,"tags":["CRC32算法"],"title":"理解CRC32算法","uri":"/%E7%90%86%E8%A7%A3crc32%E7%AE%97%E6%B3%95/#三思考"},{"categories":["加密算法研究"],"content":" 写法 算法常量 编码表 算法流程 ","date":"2023-05-09","objectID":"/%E6%8E%A2%E8%AE%A8%E5%85%B3%E4%BA%8Ebase64%E7%AE%97%E6%B3%95%E7%9A%84%E9%AD%94%E6%94%B9%E6%96%B9%E5%BC%8F/:0:0","series":null,"tags":["Base64算法"],"title":"探讨关于Base64算法的魔改方式","uri":"/%E6%8E%A2%E8%AE%A8%E5%85%B3%E4%BA%8Ebase64%E7%AE%97%E6%B3%95%E7%9A%84%E9%AD%94%E6%94%B9%E6%96%B9%E5%BC%8F/#"},{"categories":["加密算法研究"],"content":" 写法 函数名 算法常量 CRC码表 多项式的二进制 算法流程 CRC码表生成方式 ","date":"2023-05-09","objectID":"/%E6%8E%A2%E8%AE%A8%E5%85%B3%E4%BA%8Ecrc32%E7%AE%97%E6%B3%95%E7%9A%84%E9%AD%94%E6%94%B9%E6%96%B9%E5%BC%8F/:0:0","series":null,"tags":["CRC32算法"],"title":"探讨关于CRC32算法的魔改方式","uri":"/%E6%8E%A2%E8%AE%A8%E5%85%B3%E4%BA%8Ecrc32%E7%AE%97%E6%B3%95%E7%9A%84%E9%AD%94%E6%94%B9%E6%96%B9%E5%BC%8F/#"},{"categories":["加密算法研究"],"content":" 写法 函数名 常量初始化方式 算法常量 IV 转换变量 T常量表 算法流程 非线性函数 ","date":"2023-05-09","objectID":"/%E6%8E%A2%E8%AE%A8%E5%85%B3%E4%BA%8Emd5%E7%AE%97%E6%B3%95%E7%9A%84%E9%AD%94%E6%94%B9%E6%96%B9%E5%BC%8F/:0:0","series":null,"tags":["MD5算法"],"title":"探讨关于MD5算法的魔改方式","uri":"/%E6%8E%A2%E8%AE%A8%E5%85%B3%E4%BA%8Emd5%E7%AE%97%E6%B3%95%E7%9A%84%E9%AD%94%E6%94%B9%E6%96%B9%E5%BC%8F/#"},{"categories":["加密算法研究"],"content":" 写法 算法常量 S盒长度、值 算法流程 数据交换 流数据异或 ","date":"2023-05-09","objectID":"/%E6%8E%A2%E8%AE%A8%E5%85%B3%E4%BA%8Erc4%E7%AE%97%E6%B3%95%E7%9A%84%E9%AD%94%E6%94%B9%E6%96%B9%E5%BC%8F/:0:0","series":null,"tags":["RC4算法"],"title":"探讨关于RC4算法的魔改方式","uri":"/%E6%8E%A2%E8%AE%A8%E5%85%B3%E4%BA%8Erc4%E7%AE%97%E6%B3%95%E7%9A%84%E9%AD%94%E6%94%B9%E6%96%B9%E5%BC%8F/#"},{"categories":["加密算法研究"],"content":" 写法 函数名 常量初始化方式 算法常量 IV K常量表 算法流程 分组数据变化的步函数 非线性函数 每次计算时初始化变量赋值方式 ","date":"2023-05-09","objectID":"/%E6%8E%A2%E8%AE%A8%E5%85%B3%E4%BA%8Esha1%E7%AE%97%E6%B3%95%E7%9A%84%E9%AD%94%E6%94%B9%E6%96%B9%E5%BC%8F/:0:0","series":null,"tags":["SHA1算法"],"title":"探讨关于SHA1算法的魔改方式","uri":"/%E6%8E%A2%E8%AE%A8%E5%85%B3%E4%BA%8Esha1%E7%AE%97%E6%B3%95%E7%9A%84%E9%AD%94%E6%94%B9%E6%96%B9%E5%BC%8F/#"},{"categories":["加密算法研究"],"content":" 写法 函数名 常量初始化方式 算法常量 IV K常量表 算法流程 分组数据变化的步函数 非线性函数 每次计算时初始化变量赋值方式 ","date":"2023-05-09","objectID":"/%E6%8E%A2%E8%AE%A8%E5%85%B3%E4%BA%8Esha256%E7%AE%97%E6%B3%95%E7%9A%84%E9%AD%94%E6%94%B9%E6%96%B9%E5%BC%8F/:0:0","series":null,"tags":["SHA256算法"],"title":"探讨关于SHA256算法的魔改方式","uri":"/%E6%8E%A2%E8%AE%A8%E5%85%B3%E4%BA%8Esha256%E7%AE%97%E6%B3%95%E7%9A%84%E9%AD%94%E6%94%B9%E6%96%B9%E5%BC%8F/#"}]